<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Практика по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" TITLE="Программа курса (Откроется в новом окне)">Программа</A> |
                                                  <A HREF="../../Теория/theory.htm">Теория</A> |
                                                  <strong>Практика</strong>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
    <P class="margined">
        <FONT SIZE=4>
            <CENTER>
            </CENTER>
        </FONT>
        <table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../practice.htm">Оглавление</A>
                 <div> <p><a><b><span>Индивидуальная практическая работа №1 </span></b></a><span><b><span>Организация ввода вывода данных, пакет </span></b></span><span><b><span>java</span></b></span><span><b><span>.</span></b></span><span><b><span>utils</span></b></span><span><b><span> </span></b></span><span><b><span><o:p></o:p></span></b></span></p> <span></span> <p><b><span>1. Цель работы<o:p></o:p></span></b></p> <p><span>Ознакомиться с принципами ООП, организация ввода вывода данных и получить практические знания.<o:p></o:p></span></p> <p><b><span>2. Учебный материал по практической<o:p></o:p></span></b></p> <p><span>Основными принципами ООП являются понятия <span>объект</span> и<span> класс</span>. Программа на языке Java состоит из классов, а каждый класс, в свою очередь, представляет объект реального света. Например, в качестве объекта возьмем <i>робота</i>, в этом случае, в классе Robot, представляющем этот объект, будут описаны его характеристики и поведение, то есть <span>атрибуты</span> и <span>методы</span>.<o:p></o:p></span></p> <p><span>Класс Robot может состоять из таких атрибутов как:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>ID</span><span>;</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>имя</span><span>;</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>тип</span><span>.</span><span><o:p></o:p></span></p> <p><span>Также класс Robot будет содержать методы, отвечающие за его поведение. К примеру, на начальном этапе робот умеет:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>спрашивать имя</span><span>;</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>приветствовать по имени</span><span>;</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>выполнять какую-либо работу</span><span>.</span><span><o:p></o:p></span></p> <p><span>Абстракция<o:p></o:p></span></p> <p><span>При описании поведения какого-либо объекта, нужно выбрать подходящий для решения конкретной задачи <span>уровень абстракции</span>. Объекты реального света могут быть достаточно сложны, чтобы описать все их характеристики, более того, решение конкретных задач потребует лишь наличие некоторых из них. Таким образом, мы должны абстрагироваться от некоторых конкретных деталей объекта. Но также важно, чтобы абстракция не была слишком обобщенной и позволила правильно моделировать поведение объекта.<o:p></o:p></span></p> <p><b><span>3 главных принципа,</span></b><span> на которых строится объектно-ориентированное программирование:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>инкапсуляция;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>наследование;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>полиморфизм.<o:p></o:p></span></p> <p><span>Инкапсуляция</span><span> это механизм, объединяющий атрибуты и методы (которые составляют объект) и охраняющий их от внешнего вмешательства. Инкапсуляция — защитная оболочка, позволяющая обращаться к атрибутам и методам класса только внутри этого класса или при помощи специально спроектированного интерфейса.<o:p></o:p></span></p> <p><span>Атрибуты или методы класса могут быть <span>открытыми (public)</span> или <span>закрытыми (private)</span>. Закрытые атрибуты и методы могут быть доступны только внутри класса, в котором они находятся, они не доступны той части программного кода, которая находится вне этого класса. Открытые атрибуты и методы доступны, в том числе, и коду программы вне класса. Таким образом, открытые методы используются для предоставления контролируемого интерфейса к закрытым элементам класса.<o:p></o:p></span></p> <p><span>Например, представим, что у нашего робота на голове находятся светодиоды, которые меняют цвет по голосовой команде «Измени цвет». Мы не можем ни как по-другому повлиять на смену цвета диодов, потому что этого не позволят настройки приватности. Мы можем повлиять на смену цвета, только при помощи конкретной голосовой команды, которая в данном случае является интерфейсом к светодиодам.<o:p></o:p></span></p> <p><span>Наследование</span><span> помогает избежать дублирования кода в случае, если нам нужно создать объект на основе уже существующего. В этом случае говорится, что новый объект (<span>дочерний</span>) унаследовал свойства уже существующего (<span>родительского</span>). Если атрибуты или поведение существующего объекта нужно частично изменить, то их можно просто переопределить.<o:p></o:p></span></p> <p><span>Например, на основе уже существующего объекта Robot мы можем создать новый объект CoffeRobot, который будет варить кофе. Новый робот будет иметь все атрибуты и методы что и предыдущий, плюс содержать дополнительный метод «Варить кофе».<o:p></o:p></span></p> <p><span>Полиморфизм <o:p></o:p></span></p> <p><span>Если мы имеем объекты, которые принадлежат одной и той же ветви иерархии (были унаследованы), то для них можно использовать единый интерфейс, который будет для каждого объекта производить однотипное действие, но результат для каждого объекта будет различным (зависящим от этого конкретного объекта).<o:p></o:p></span></p> <p><span>Например, если мы при помощи наследования создадим серию роботов разных типов (робот, который варит кофе; робот, который моет пол; робот, который поливает цветы), а потом каждому роботу дадим команду «работай», то каждый робот в ответ на ту же самую команду будет делать различные действия, в соответствии с его типом. То есть, единым интерфейсом здесь является объект Robot с методом «работать», а то, как именно он будет работать, зависит от его реализации.<o:p></o:p></span></p> <p><span>class Dat</span><span>е</span><span> { <o:p></o:p></span></p> <p><span><span> </span>private int dd = 1; <o:p></o:p></span></p> <p><span><span> </span>private int mm = 1; <o:p></o:p></span></p> <p><span><span> </span>private int yy = 1;<o:p></o:p></span></p> <p><span><span> </span>public void Init (int d, int m, int y) {<o:p></o:p></span></p> <p><span><span> </span>dd = d; mm = m; yy = y;}<o:p></o:p></span></p> <p><span><span> </span>public int getDay () {return dd;}<o:p></o:p></span></p> <p><span><span> </span>public int getMonth () {return mm;}<o:p></o:p></span></p> <p><span><span> </span>public int getYear () {return yy;}<o:p></o:p></span></p> <p><span><span> </span></span><span>}<o:p></o:p></span></p> <p><span><span> </span>Считывание информации с клавиатуры производится путем использования класса </span><span>Scanner</span><span>.<o:p></o:p></span></p> <p><span><br> public class Main {<br> public static void main(String[] args) {<br> Scanner sc = new Scanner(System.in);<o:p></o:p></span></p> <p><span> int i = 2;<br> System.out.print("</span><span>Введите</span><span> </span><span>целое</span><span> </span><span>число</span><span>: ");<br> if(sc.hasNextInt()) { <o:p></o:p></span></p> <p><span> i = sc.nextInt();<o:p></o:p></span></p> <p><span> System.out.println(i*2);<br> } else {<br> System.out.println("</span><span>Вы</span><span> </span><span>ввели</span><span> </span><span>не</span><span> </span><span>целое</span><span> </span><span>число</span><span>");<br> }<br> }<br> }<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>При программировании на Java операций над группой однотипных объектов важно выбирать наиболее эффективную структуру данных (класс) для хранения этих объектов. В языке java определены специальные классы для хранения однотипных объектов, которые называются коллекциями, определяющими такие структуры как список, множество, очередь.<o:p></o:p></span></p> <p><span>Выбор определенного класса для работы с коллекциями определяет набор методов, которые будут доступны для объекта этого класса. Например, если используется список (который определяет интерфейс List), то существуют богатый выбор для его реализации: ArrayList, LinkedList, Vector, Stack. Конкретный выбор реализации списка сказывается на эффективности манипуляций с объектами списка. Так, ArrayList хранит элементы в виде массива, а значит, доступ и замена будет выполняться относительно быстро. В то же время LinkedList хранит элементы в виде связного списка, что влечет за собой относительно медленный поиск элементов и быструю операцию добавления/удаления.<o:p></o:p></span></p> <p><span>Интерфейс </span><span>Collection</span><span> содержит набор общих методов, которые используются в большинстве коллекций. Рассмотрим основные из них:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>add</span><span>(</span><span>Object</span><span> </span><span>item</span><span>) – добавляет в коллекцию<span> </span>новый элемент, если элементы коллекции<span> </span>каким-то образом упорядочены, новый<span> </span>элемент добавляется в конец коллекции;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>clear</span><span>() – удаляет все элементы коллекции;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>contains</span><span>(</span><span>Object</span><span> </span><span>obj</span><span>) – возвращает </span><span>true</span><span>, если<span> </span>объект </span><span>obj</span><span> содержится в коллекции и<span> </span></span><span>false</span><span>, если нет;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>isEmpty</span><span>() – проверяет, пуста ли коллекция;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>remove</span><span>(</span><span>Object</span><span> </span><span>obj</span><span>) – удаляет из коллекции<span> </span>элемент </span><span>obj</span><span>, возвращает </span><span>false</span><span>, если такого<span> </span>элемента в коллекции не нашлось;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>size</span><span>() – возвращает количество<span> </span>элементов коллекции.<o:p></o:p></span></p> <p><span>Интерфейс </span><span>List</span><span> описывает упорядоченный список. Элементы списка пронумерованы, начиная с нуля и к конкретному элементу можно обратиться по целочисленному индексу. Интерфейс </span><span>List</span><span> является наследником интерфейса </span><span>Collection</span><span>, поэтому содержит все его методы и добавляет к ним несколько своих:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>add</span><span>(</span><span>int</span><span> </span><span>index</span><span>, </span><span>Object</span><span> </span><span>item</span><span>) – вставляет элемент<span> </span></span><span>item</span><span> в позицию </span><span>index</span><span>, при этом список раздвигается (все элементы, начиная с<span> </span>позиции </span><span>index</span><span>, увеличивают свой индекс<span> </span>на 1);<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>get</span><span>(</span><span>int</span><span> </span><span>index</span><span>) – возвращает объект,<span> </span>находящийся в позиции </span><span>index</span><span>;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>indexOf</span><span>(</span><span>Object</span><span> </span><span>obj</span><span>) – возвращает индекс<span> </span>первого появления элемента </span><span>obj</span><span> в списке;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>lastIndexOf</span><span>(</span><span>Object</span><span> </span><span>obj</span><span>) – возвращает индекс<span> </span>последнего появления элемента </span><span>obj</span><span> в<span> </span>списке;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>add</span><span>(</span><span>int</span><span> </span><span>index</span><span>, </span><span>Object</span><span> </span><span>item</span><span>) – заменяет элемент,<span> </span>находящийся в позиции </span><span>index</span><span> объектом<span> </span></span><span>item</span><span>;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>subList</span><span>(</span><span>int</span><span> </span><span>from</span><span>, </span><span>int</span><span> </span><span>to</span><span>) – возвращает новый<span> </span>список, представляющий собой часть<span> </span>данного (начиная с позиции </span><span>from</span><span> до позиции<span> </span></span><span>to</span><span>-1 включительно).<o:p></o:p></span></p> <p><span>Интерфейс </span><span>Set</span><span> описывает множество. Элементы множества не упорядочены, множество не может содержать двух одинаковых элементов. Интерфейс </span><span>Set</span><span> унаследован от интерфейса </span><span>Collection</span><span>, но никаких новых методов не добавляет. Изменяется только смысл метода </span><span>add</span><span>(</span><span>Object</span><span> </span><span>item</span><span>) – он не добавляет объект </span><span>item</span><span>, если он уже присутствует во множестве.<o:p></o:p></span></p> <p><span>Интерфейс </span><span>Queue</span><span> описывает очередь. Элементы могут добавляться в очередь только с одного конца, а извлекаться с другого (аналогично очереди в магазине). Интерфейс </span><span>Queue</span><span> так же унаследован от интерфейса </span><span>Collection</span><span>. Специфические для очереди методы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>poll</span><span>() – возвращает первый элемент и<span> </span>удаляет его из очереди.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>peek</span><span>() – возвращает первый элемент<span> </span>очереди, не удаляя его.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>offer</span><span>(</span><span>Object</span><span> </span><span>obj</span><span>) – добавляет в конец<span> </span>очереди новый элемент и возвращает<span> </span></span><span>true</span><span>, если вставка удалась.<o:p></o:p></span></p> <p><span>Vector</span><span> (вектор) – набор упорядоченных элементов, к каждому из которых можно обратиться по индексу. По сути эта коллекция представляет собой обычный список. Класс </span><span>Vector</span><span> реализует интерфейс </span><span>List</span><span>, основные методы которого названы выше. К этим методам добавляется еще несколько. Например, метод </span><span>firstElement</span><span>() позволяет обратиться к первому элементу вектора, метод </span><span>lastElement</span><span>() – к его последнему элементу. Метод </span><span>removeElementAt</span><span>(</span><span>int</span><span> </span><span>pos</span><span>) удаляет элемент в заданной позиции, а метод </span><span>removeRange</span><span>(</span><span>int</span><span> </span><span>begin</span><span>, </span><span>int</span><span> </span><span>end</span><span>) удаляет несколько подряд идущих элементов. Все эти операции можно было бы осуществить комбинацией базовых методов интерфейса </span><span>List</span><span>, так что функциональность принципиально не меняется.<o:p></o:p></span></p> <p><span>Класс </span><span>ArrayList</span><span> – аналог класса </span><span>Vector</span><span>. Он представляет собой список и может использоваться в тех же ситуациях. Основное отличие в том, что он не синхронизирован и одновременная работа нескольких параллельных процессов с объектом этого класса не рекомендуется. В обычных же ситуациях он работает быстрее.<o:p></o:p></span></p> <p><span>Для навигации по коллекциям в </span><span>Java</span><span> предусмотрено специальное архитектурное решение, получившее свою реализацию в интерфейсе </span><span>Iterator</span><span>. Идея заключается в том, что к коллекции «привязывается» объект, единственное назначение которого — выдать все элементы этой коллекции в некотором порядке, не раскрывая ее внутреннюю структуру.<o:p></o:p></span></p> <p><span>Интерфейс </span><span>Iterator</span><span> имеет всего три метода:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>next</span><span>() – возвращает очередной элемент<span> </span>коллекции, к которой «привязан» итератор<span> </span>(и делает его текущим). Порядок перебора определяет сам итератор.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>hasNext</span><span>() – возвращает </span><span>true</span><span>, если перебор<span> </span>элементов еще не закончен<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>remove</span><span>() – удаляет текущий элемент.<o:p></o:p></span></p> <p><span>Интерфейс </span><span>Collection</span><span> помимо рассмотренных ранее методов, имеет метод </span><span>iterator</span><span>(), который возвращает итератор для данной коллекции, готовый к ее обходу. С помощью такого итератора можно обработать все элементы любой коллекции следующим простым способом:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Iterator iter = coll.iterator(); // coll - коллекция<o:p></o:p></span></p> <p><span>while</span><span> (</span><span>iter</span><span>.</span><span>hasNext</span><span>()) {<o:p></o:p></span></p> <p><span>// обрабатываем объект, возвращаемый методом </span><span>iter</span><span>.</span><span>next</span><span>()<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Для коллекций, элементы которых проиндексированы, определен более функциональный итератор, позволяющий двигаться как в прямом, так и в обратном направлении, а также добавлять в коллекцию элементы. Такой итератор имеет интрефейс </span><span>ListIterator</span><span>, унаследованный от интерфейса </span><span>Iterator</span><span> и дополняющий его следующими методами:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>previous</span><span>() – возвращает предыдущий<span> </span>элемент (и делает его текущим);<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>hasPrevious</span><span>() – возвращает </span><span>true</span><span>, если<span> </span>предыдущий элемент существует (т.е.<span> </span>текущий элемент не является первым<span> </span>элементом для данного итератора);<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>add</span><span>(</span><span>Object</span><span> </span><span>item</span><span>) – добавляет новый элемент<span> </span>перед текущим элементом;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>set</span><span>(</span><span>Object</span><span> </span><span>item</span><span>) – заменяет текущий элемент;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>nextIndex</span><span>() и </span><span>previousIndex</span><span>() – служат для<span> </span>получения индексов следующего и<span> </span>предыдущего элементов соответственно.<o:p></o:p></span></p> <p><span>В интерфейсе </span><span>List</span><span> определен метод </span><span>listIterator</span><span>(), возвращающий итератор </span><span>ListIterator</span><span> для обхода данного списка.<o:p></o:p></span></p> <p><span>Интерфейс </span><span>Map</span><span> из пакета </span><span>java</span><span>.</span><span>util</span><span> описывает коллекцию, состоящую из пар «ключ – значение», которые широко используются для хранения настроек в файлах конфигурации (см., например, /</span><span>etc</span><span>/</span><span>services</span><span>). У каждого ключа только одно значение, что соответствует математическому понятию однозначной функции или отображения (</span><span>M</span><span>ар). Интерфейс </span><span>Map</span><span> содержит следующие методы, работающие с ключами и значениями:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>boolean containsKey (Object key) — проверяет<span> </span>наличие ключа key;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>boolean containsValue (Object value) — проверяет<span> </span>наличие значения value;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>Set</span><span> </span><span>entry</span><span> </span><span>Set</span><span>() – представляет коллекцию<span> </span>в виде множества, каждый элемент которого<span> </span>– пара из данного отображения, с которой<span> </span>можно работать методами вложенного<span> </span>интерфейса </span><span>Map</span><span>.</span><span>Entry</span><span>;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>О</span><span>bject</span><span> </span><span>get</span><span>(</span><span>Object</span><span> </span><span>key</span><span>) – возвращает значение,<span> </span>отвечающее ключу </span><span>key</span><span>; </span><span>S</span><span> </span><span>et</span><span> </span><span>key</span><span> </span><span>S</span><span> </span><span>et</span><span>() –<span> </span>представляет ключи коллекции в виде<span> </span>множества;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>Object</span><span> </span><span>put</span><span> (</span><span>Object</span><span> </span><span>key</span><span>, </span><span>Object</span><span> </span><span>value</span><span> ) — добавляет<span> </span>пару « </span><span>key</span><span> — </span><span>value</span><span> », если такой пары не<span> </span>было, и заменяет значение ключа </span><span>key</span><span>, если<span> </span>такой ключ уже есть в коллекции;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>void</span><span> </span><span>putAll</span><span> (</span><span>Map</span><span> </span><span>m</span><span>) – добавляет к коллекции<span> </span>все пары из отображения </span><span>m</span><span>;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>collection</span><span> </span><span>values</span><span> () – представляет все<span> </span>значения в виде коллекции.<o:p></o:p></span></p> <p><span>В интерфейс </span><span>M</span><span>ар вложен интерфейс </span><span>Map</span><span>.</span><span>Entry</span><span>. Этот интерфейс описывает методы работы с парами, полученными методом </span><span>entrySet</span><span>() из объекта типа </span><span>Map</span><span>.<o:p></o:p></span></p> <p><span>Методы </span><span>getKey</span><span>() и </span><span>getValue</span><span>() позволяют получить ключ и значение пары, метод </span><span>setValue</span><span> (О</span><span>bject</span><span> </span><span>value</span><span>) меняет значение в данной паре.<o:p></o:p></span></p> <p><span>Для того чтобы просить работа с массивами объектов, в созданной нами модели, мы будем использовать коллекции. Коллекции нужны для того, чтобы автоматический резервировать память хранения, выполнение операции сортировки, добавления и удаления. <o:p></o:p></span></p> <p><span>1) Определить типы коллекций которые нам нужны. Какую коллекцию использовать зависит от логики работы нашей программы для хранения не повторяющихся объектов лучше использовать Set для хранения несортированных данных лучше подходит List, коллекция Map используется для быстрого доступа к объектам коллекции по ключам<o:p></o:p></span></p> <p><span>2) Добавим в классы модели методы давления и удаления зависимых объектов. Также добавим конструкторы с параметрами для создания и одновременной инициализации объектов<o:p></o:p></span></p> <p><span>3) Также мы можем определить порядок для хранения объектов. Для этого создайте компаратор для коллекции которые должны хранится в опридененном порядке. <o:p></o:p></span></p> <p><span>То, что коллекция хранить объекты в определенном порядке требует сортировать объекты после каждой операции добавление и удаления, что замедляет её работу. Такой вариант использования коллекции оправдан если в приложении часто выполняются операции чтения списка и редко изменяются данные. Альтернативное решение - хранить несортированную коллекцию и добавить метод который сортирует коллекцию каждый раз перед тем, как возвращает список объектов. Такой подход оправдан если в программе часто добавляются и удаляются объекты, и редко требуется сортированный список. <o:p></o:p></span></p> <p><b><span>3. Порядок выполнения работы<o:p></o:p></span></b></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Ознакомиться с учебным материалом<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>В </span><span>ide</span><span> </span><span>Eclipse</span><span> создать проект.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Создать класс, описать в нем поля, при вводе данных с клавиатуры записывать данные в поля объекта и добавлять объект в коллекцию.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>4.<span> </span></span></span><![endif]><span>Продемонстрировать результат работы преподавателю.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>5.<span> </span></span></span><![endif]><span>Согласовать с преподавателем содержание отчёта и подготовить его.<o:p></o:p></span></p> <p><b><span>4. Контрольные вопросы</span></b><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Что такое ООП?<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Какие принципы ООП вы знаете? Расскажите о каждом из них<o:p></o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Принцип работы стека?<o:p></o:p></span></p> <p><![if !supportLists]><span><span>4.<span> </span></span></span><![endif]><span>Какие принципы ООП вы использовали в своей работе?<o:p></o:p></span></p> <p><o:p> </o:p></p> </div> 
                <p>&nbsp;</p>
        </table>
 <A HREF="../practice.htm">Оглавление</A>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>