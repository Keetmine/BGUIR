<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Практика по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" TITLE="Программа курса (Откроется в новом окне)">Программа</A> |
                                                  <A HREF="../../Теория/theory.htm">Теория</A> |
                                                  <strong>Практика</strong>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
    <P class="margined">
        <FONT SIZE=4>
            <CENTER>
            </CENTER>
        </FONT>
        <table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../practice.htm">Оглавление</A>
                <p>&nbsp;</p>
                 <div> <p><a><b><span>Лабораторная работа 3 Совместное использование ресурсов вычислительной системы несколькими процессами.<o:p></o:p></span></b></a></p> <span></span> <p><b><span>1. Цель работы<o:p></o:p></span></b></p> <p><span>Изучить особенности функционирования подсистемы управления процессами и получить практические навыки по её использованию.<o:p></o:p></span></p> <p><b><span>2. Учебный материал по лабораторной<o:p></o:p></span></b></p> <p><span>Во<span>зможность синхронизации как бы встроена в каждый объект, создаваемый приложением <span>Java</span>. Для этого объекты снабжаются защелками, которые могут быть использованы для блокировки потоков, обращающихся к этим объектам.<o:p></o:p></span></span></p> <p><span>Чтобы воспользоваться защелками, вы можете объявить соответствующий метод как <span>synchronized</span>, сделав его синхронизированным:<o:p></o:p></span></p> <p><span><span>public</span></span><span> <span>synchronized</span> <span>void</span> <span>decrement</span>()<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span>. . .<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span>При вызове синхронизированного метода соответствующий ему объект (в котором он определен) блокируется для использования другими синхронизированными методами. В результате предотвращается одновременная запись двумя методами значений в область памяти, принадлежащую данному объекту.<o:p></o:p></span></p> <p><span>Использование синхронизированных методов - достаточно простой способ синхронизации потоков, обращающихся к общим критическим ресурсам, наподобие описанного выше банковского счета.<o:p></o:p></span></p> <p><span>Заметим, что не обязательно синхронизовать весь метод - можно выполнить синхронизацию только критичного фрагмента кода.<o:p></o:p></span></p> <p><span>. . .<o:p></o:p></span></p> <p><span><span>synchronized(</span></span><span>Account)<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span><span>if(</span><span>Account.check</span>(3000000))<o:p></o:p></span></p> <p><span><span> </span><span>Account.decrement(</span>3000000);<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span>. . .<o:p></o:p></span></p> <p><span>Здесь синхронизация выполняется для объекта <span>Account</span>.<o:p></o:p></span></p> <p><b><span>Блокировка потока<o:p></o:p></span></b></p> <p><span>Синхронизированный поток, определенный как метод типа <span>synchronized</span>, может переходить в заблокированное состояние автоматически при попытке обращения к ресурсу, занятому другим синхронизированным методом, либо при выполнении некоторых операций ввода или вывода. Однако в ряде случаев полезно иметь более тонкие средства синхронизации, допускающие явное использование по запросу приложения.<o:p></o:p></span></p> <p><b><span>Блокировка на заданный период времени<o:p></o:p></span></b></p> <p><span>С помощью метода <span>sleep</span> можно заблокировать поток на заданный период времени:<o:p></o:p></span></p> <p><span><span>try</span></span><span><o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span><span><span>Thread.sleep</span></span><span>(</span>500);<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span><span>catch</span></span><span> (<span>InterruptedException</span> <span>ee</span>)<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span>. . .<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span>В данном примере работа потока <span>Thread</span> приостанавливается на 500 миллисекунд. Заметим, что во время ожидания приостановленный поток не отнимает ресурсы процессора.<o:p></o:p></span></p> <p><span>Так как метод <span>sleep</span> может создавать исключение <span>InterruptedException</span>, необходимо предусмотреть его обработку. Для этого мы использовали операторы <span>try</span> и <span>catch</span>.<o:p></o:p></span></p> <p><b><span>Временная приостановка и возобновление работы<o:p></o:p></span></b></p> <p><span>Методы <span>suspend</span> и <span>resume</span> позволяют, соответственно, временно приостанавливать и возобновлять работу потока.<o:p></o:p></span></p> <p><span>В следующем фрагменте кода поток <span>m_Rectangles</span> приостанавливает свою работу, когда курсор мыши оказывается над окном <span>аплета</span>:<o:p></o:p></span></p> <p><span><span>public</span></span><span> <span>boolean</span> <span>mouseEnter</span>(Event <span>evt</span>,<o:p></o:p></span></p> <p><span><span> </span><span><span>int</span></span> x, <span>int</span> y)<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span><span>if</span> (<span>m_Rectangles</span> != null)<o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span><span>m_<span>Rectangles.suspend</span></span><span>(</span>);<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><span> </span><span>return</span> true;<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span>Работа потока возобновляется, когда курсор мыши покидает окно <span>аплета</span>:<o:p></o:p></span></p> <p><span><span>public</span></span><span> <span>boolean</span> <span>mouseExit</span>(Event <span>evt</span>,<o:p></o:p></span></p> <p><span><span> </span><span><span>int</span></span> x, <span>int</span> y)<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span><span>if</span> (<span>m_Rectangles</span> != null)<o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span><span>m_<span>Rectangles.resume</span></span><span>(</span>);<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><span> </span><span>return</span> true;<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><b><span>Ожидание извещения<o:p></o:p></span></b></p> <p><span>Если вам нужно организовать взаимодействие потоков таким образом, чтобы один поток управлял работой другого или других потоков, вы можете воспользоваться методами <span>wait</span>, <span>notify</span> и <span>notifyAll</span>, определенными в классе <span>Object</span>.<o:p></o:p></span></p> <p><span>Метод <span>wait</span> может использоваться либо с параметром, либо без параметра. Этот метод переводит поток в состояние ожидания, в котором он будет находиться до тех пор, пока для потока не будет вызван извещающий метод <span>notify</span>, <span>notifyAll</span>, или пока не истечет период времени, указанный в параметре метода <span>wait</span>.<o:p></o:p></span></p> <p><span>Как пользоваться методами <span>wait</span>, <span>notify</span> и <span>notifyAll</span>?<o:p></o:p></span></p> <p><span>Метод, который будет переводиться в состояние ожидания, должен быть синхронизированным, то есть его следует описать как <span>synchronized</span>:<o:p></o:p></span></p> <p><span><span>public</span></span><span> synchronized void run()<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span><span>while</span> (true)<o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span>. . .<o:p></o:p></span></p> <p><span><span> </span><span>try</span><o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span><span><span>this.wait</span></span><span>(</span>);<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><span> </span><span>catch</span> (<span>InterruptedException</span> e)<o:p></o:p></span></p> <p><span><span> </span></span><span>{<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span>В этом примере внутри метода <span>run</span> определен цикл, вызывающий метод <span>wait</span> без параметров. Каждый раз при очередном проходе цикла метод <span>run</span> переводится в состояние ожидания до тех пор, пока другой поток не выполнит извещение с помощью метода <span>notify</span>.<o:p></o:p></span></p> <p><span>Ниже мы привели пример потока, <span>вызывающией</span> метод <span>notify</span>:<o:p></o:p></span></p> <p><span><span>public</span></span><span> void run()<o:p></o:p></span></p> <p><span>{<o:p></o:p></span></p> <p><span><span> </span><span>while</span> (true)<o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span><span>try</span><o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span><span><span>Thread.sleep</span></span><span>(</span>30);<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><span> </span><span>catch</span> (<span>InterruptedException</span> e)<o:p></o:p></span></p> <p><span><span> </span></span><span>{<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span><span> </span><span>synchronized</span>(<span>STask</span>)<o:p></o:p></span></p> <p><span><span> </span>{<o:p></o:p></span></p> <p><span><span> </span><span>STask.notify</span>();<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span><span> </span>}<o:p></o:p></span></p> <p><span>}<o:p></o:p></span></p> <p><span>Этот поток реализован в рамках отдельного класса, конструктору которого передается ссылка на поток, вызывающую метод <span>wait</span>. Эта ссылка хранится в поле <span>STask</span>.<o:p></o:p></span></p> <p><span>Обратите внимание, что хотя сам метод <span>run</span> не синхронизированный, вызов метода <span>notify</span> выполняется в синхронизированном режиме. В качестве объекта синхронизации выступает поток, для которого вызывается метод <span>notify</span>.<o:p></o:p></span></p> <p><b><span>Ожидание завершения потока<o:p></o:p></span></b></p> <p><span>С помощью метода <span>join</span> вы можете выполнять ожидание завершения работы потока, для которой этот метод вызван.<o:p></o:p></span></p> <p><span>Существует три определения метода <span>join</span>:<o:p></o:p></span></p> <p><span><span>public</span></span><span> final void join();<o:p></o:p></span></p> <p><span><span>public</span></span><span> final void join(long <span>millis</span>);<o:p></o:p></span></p> <p><span><span>public</span></span><span> final void join(long <span>millis</span>,<o:p></o:p></span></p> <p><span><span> </span></span><span><span><span>int</span></span></span><span><span> <span>nanos</span>);</span></span><span><o:p></o:p></span></p> <p><span>Первый из них выполняет ожидание без ограничения во времени, для второго ожидание будет прервано принудительно через <span>millis</span> миллисекунд, а для третьего - через <span>millis</span> миллисекунд и <span>nanos</span> наносекунд. Учтите, что реально вы не сможете указывать время с точностью до наносекунд, так как дискретность системного таймера компьютера намного больше.<o:p></o:p></span></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>3. Порядок выполнения работы<o:p></o:p></span></b></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Ознакомиться с учебным материалом<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>В </span><span>ide</span><span> </span><span>Eclipse</span><span> создать проект.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Создать два потока и счет в 5 тысяч. Сделать проверку в каждом из потоков о состоянии счета и если он больше 4 тысяч тогда снять 3 тысячи с него и просмотреть результат.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>4.<span> </span></span></span><![endif]><span>Синхронизировать метод или блок так чтобы вывод денег был корректен для обоих потоков.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>5.<span> </span></span></span><![endif]><span>Продемонстрировать результат работы преподавателю.</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>6.<span> </span></span></span><![endif]><span>Согласовать с преподавателем содержание отчёта и подготовить его.</span><span><o:p></o:p></span></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>4. Контрольные вопросы<o:p></o:p></span></b></p> <p><span>1. Зачем нужна синхронизация потоков? <o:p></o:p></span></p> <p><span>2. Как можно синхронизировать потоки?<o:p></o:p></span></p> <p><span>3. Зачем нужна блокировка потока?</span></p> </div> 
 <A HREF="../practice.htm">Оглавление</A>
                <p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>