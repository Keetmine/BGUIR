<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Практика по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" TITLE="Программа курса (Откроется в новом окне)">Программа</A> |
                                                  <A HREF="../../Теория/theory.htm">Теория</A> |
                                                  <strong>Практика</strong>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
    <P class="margined">
        <FONT SIZE=4>
            <CENTER>
            </CENTER>
        </FONT>
        <table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../practice.htm">Оглавление</A>
                <p>&nbsp;</p>
                 <div> 

<p><b><span>Лабораторная работа 7 Создание первичного и суррогатного ключей</span></b></p>
<p><b><span>1. Цель работы<o:p></o:p></span></b></p> <p><span>Освоить способы создания первичного ключа; суррогатного ключа, с помощью последовательностей; отработать ввод данных, создание связей и индексов, изменение структуры таблицы с контрольными ограничениями, создание представлений.<o:p></o:p></span></p> <p><b><span>2. </span></b><b><span>Учебный материал по лабораторной</span></b><span><o:p></o:p></span></p> <p><span>Создать</span><span> </span><span>таблицы</span><span> </span><span>CUSTOMER, ARTIST </span><span>и</span><span> CUSTOMER_ARTIST_INT<o:p></o:p></span></p> <p><span>CREATE TABLE CUSTOMER (<o:p></o:p></span></p> <p><span><span>CustomerID</span></span><span><span> </span><span>int</span><span> </span>NOT NULL,<o:p></o:p></span></p> <p><span>Name<span> </span><span>varchar</span> (25)<span> </span>NOT NULL,<o:p></o:p></span></p> <p><span>Street<span> </span><span>varchar</span> (30)<span> </span>NULL,<o:p></o:p></span></p> <p><span>City<span> </span><span>varchar</span> (35)<span> </span>NULL,<o:p></o:p></span></p> <p><span>State<span> </span><span>varchar</span> (2)<span> </span>NULL,<o:p></o:p></span></p> <p><span>Zip<span> </span><span>varchar</span> (5)<span> </span>NULL,<o:p></o:p></span></p> <p><span><span>Area_Code</span></span><span><span> </span><span>varchar</span> (3)<span> </span>NULL,<o:p></o:p></span></p> <p><span>Phone Number<span> </span><span>varchar</span>(S)<span> </span>NULL;<o:p></o:p></span></p> <p><span>ALTER TABLE CUSTOMER<o:p></o:p></span></p> <p><span>ADD CONSTRAINT</span><span>Е</span><span> <span>CustomerPK</span> PRIMARY KEY (<span>CustomerID</span>);<o:p></o:p></span></p> <p><span>CREATE INDEX <span>CustonerNameIndex</span> ON CUSTOMER (Name);<o:p></o:p></span></p> <p><span>CREATE TABLE<span> ARTIST (</span><o:p></o:p></span></p> <p><span><span>ArfistID</span></span><span><span> </span><span>int</span></span><span><span> </span>PRIMARY KEY,<o:p></o:p></span></p> <p><span>Name<span> </span><span>varchar</span> (25)<span> </span>NOT NULL,<o:p></o:p></span></p> <p><span>Nationality<span><span> </span><span>varchar</span> (30)</span><span> </span>NULL,<o:p></o:p></span></p> <p><span>Birthdate<span> </span>date<span> </span>NULL,<o:p></o:p></span></p> <p><span><span>DeceasedDate</span></span><span><span> </span>date<span> </span>NULL);<o:p></o:p></span></p> <p><span>CREATE UNIQUE INDEX Artist <span>NameIndex</span> ON ARTIST (Name);<o:p></o:p></span></p> <p><span>CREATE TABLE CUSTOMER_ARTIST_INT (<o:p></o:p></span></p> <p><span><span>ArtistID</span></span><span><span> </span><span>int</span><span> </span>NOT NULL,<o:p></o:p></span></p> <p><span><span>CustomerID</span></span><span><span> </span><span>int</span><span> </span>NOT NULL);<o:p></o:p></span></p> <p><span>ALTER</span><span> TABLE CUSTOMER) _ARTIST_INT<o:p></o:p></span></p> <p><span>ADD CONSTRAINT <span>CustomerArtistPK</span> PRIMARY KEY (<span>ArttstID</span>,<o:p></o:p></span></p> <p><span><span>CustomerID</span></span><span>),<o:p></o:p></span></p> <p><span>В отчете пояснить два способа создания первичного ключа.<o:p></o:p></span></p> <p><span>Для создания композитного первичного ключа можно использовать только первый метод, поскольку <span>в </span></span><span>CREATE</span><span> </span><span>TABLE</span><span> можно указывать свойство </span><span>PRIMARY</span><span> </span><span>KEY</span><span> только для одного столбца.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Для упрощения работы создайте файл </span><span><span>Createl</span></span><span>.</span><span><span>sql</span></span><span> для его запуска с помощью </span><span>Start</span><span> </span><span><span>Createl</span></span><span><o:p></o:p></span></p> <p><span>Отобразите структуру всех трех таблиц на экране.<o:p></o:p></span></p> <p><a><span>Создание суррогатных ключей с помощью последовательностей</span></a><span><o:p></o:p></span></p> <p><span>Create Sequence <span>CustID</span> Increment by 1 start with 100:<o:p></o:p></span></p> <p><span>Вспомним, что Метод </span><span><span>NextVal</span></span><span> выдает следующее значение в последовательности, а метод </span><span><span>CurrVal</span></span><span> выдает текущее значение в последовательности.<o:p></o:p></span></p> <p><span>Вставим</span><span> </span><span>строку</span><span> </span><span>в</span><span> </span><span>таблицу</span><span> CUSTOMER<o:p></o:p></span></p> <p><span>INSERT INTO CUSTOMER <span>CustomerID</span>, Name, <span>Area_Code</span>, <span>Phorie_Nuniber</span>)<o:p></o:p></span></p> <p><span>VALUES<span> </span>(<span>CustID.NextVal</span>, 'Mary Jones', '350', '555-1234'):<o:p></o:p></span></p> <p><span>Этот оператор создаст в таблице </span><span>CUSTOMER</span><span> строку, где столбцу </span><span><span>CustomerID</span></span><span> будет присвоено следующее значение в последовательности </span><span><span>CustID</span></span><span>. <span>Выполнив этот оператор можно считать</span> только что созданную строку с помощью метода </span><span><span>CurrVaL</span></span><span>:<o:p></o:p></span></p> <p><span>SELEC</span><span>Т</span><span> * FROM<span> </span>CUSTOMER WHERE <span>CustomerID</span> = <span>CustID.CurrVal</span>;<o:p></o:p></span></p> <p><span>Здесь метод </span><span><span>CustID</span></span><span>.</span><span><span>CurrVal</span></span><span> возвращает текущее значение в последовательности, то есть только что использованное значение.<o:p></o:p></span></p> <p><span>Использование последовательностей не гарантирует корректности значений суррогатных ключей (могут быть пропущенные или повторяющиеся значения).<o:p></o:p></span></p> <p><span>Создайте с помощью </span><span>SQL</span><span> </span><span>Plus</span><span> следующие последовательности:</span><span><o:p></o:p></span></p> <p><span>Create Sequence <span>CustID</span> Increment by 1 start with 1000;<o:p></o:p></span></p> <p><span>Create Sequence <span>ArtistID</span> Increment by 1 start with 1;<o:p></o:p></span></p> <p><span>Create Sequence <span>WorkID</span> Increment by 1 start with 500;<o:p></o:p></span></p> <p><span>Create Sequence <span>TransID</span> Increment by 1 start with 100;<o:p></o:p></span></p> <p><a><span>Ввод данных</span></a><span><o:p></o:p></span></p> <p><span>Запустите файл </span><span><span>ACIns</span></span><span>.</span><span><span>sql</span></span><span>, предварительно набрав и ПРОВЕРИВ текст:<o:p></o:p></span></p> <p><span>INSERT INTO ARTIST (<span>ArtlstID</span>, Name, Nationality) Values<o:p></o:p></span></p> <p><span>(<span>ArtistID.NextVal</span>, 'Tobey', 'US');<o:p></o:p></span></p> <p><span>INSERT INTO ARTIST (<span>ArtistID</span>, Name, Nationality) Values<o:p></o:p></span></p> <p><span>(<span>ArtistID.NextVal</span>, <span>Miro</span>, <span>'Spanish'</span>);<o:p></o:p></span></p> <p><span>INSERT INTO ARTIST (<span>ArtistID</span>, Name, Nationality) Values<o:p></o:p></span></p> <p><span>(<span>ArtistID.NextVal</span>, ‘<span>Frings</span>', 'US');<o:p></o:p></span></p> <p><span>INSERT INTO ARTIST (<span>ArtistID</span>, Name, Nationality) Values<o:p></o:p></span></p> <p><span>(<span>ArtistID.NextVal</span>, 'Foster', 'English'):<o:p></o:p></span></p> <p><span>INSERT INTO ARTIST (<span>ArtistID</span>, Name, Nationality) Values<o:p></o:p></span></p> <p><span>(<span>ArtistID.NextVal</span>, 'van <span>Vronkin</span>', 'US'):<o:p></o:p></span></p> <p><span>INSERT INTO CUSTOMER (<span>CustomerID</span>, Name, <span>Area__Code</span>, Phone Number) Values<o:p></o:p></span></p> <p><span>(<span>CustID.NextVal</span>, 'Jeffrey <span>Janes'</span>, ‘206’, 555-1234');<o:p></o:p></span></p> <p><span>INSERT INTO CUSTOMER (<span>CustomerID</span>, Name, <span>Area__Code</span>, Phone Number) Values<o:p></o:p></span></p> <p><span>(<span>CustID.NextVal</span>, 'David Smith', '206', ‘555-443');<o:p></o:p></span></p> <p><span>INSERT INTO CUSTOMER (<span>CustomerID</span>, Name, <span>Area__Code</span>, Phone Number) Values<o:p></o:p></span></p> <p><span>(<span>CustID.NextVal</span>, 'Tiffany Twilight', '360', ‘555-1040');<o:p></o:p></span></p> <p><span>Отобразите</span><span> </span><span>на</span><span> </span><span>экране</span><span> </span><span>столбцы</span><span> <span>ArtistID</span>, Name, Nationality </span><span>из</span><span> </span><span>таблицы</span><span> ARTIST;<o:p></o:p></span></p> <p><span><span>CustomerID</span></span><span>, Name, <span>AreaCode</span>, <span>PhoneNumber</span> </span><span>из</span><span> </span><span>таблицы</span><span> CUSTOMER.<o:p></o:p></span></p> <p><a><span>Создание связей</span></a><span><o:p></o:p></span></p> <p><span>В <span>Oracle</span> связи создаются путем введения ограничений целостности по внешнему ключу. Например, следующие sql-операторы определяют связь между таблицами </span><span>CUSTOMER</span><span> и </span><span>CUSTOMER</span><span>_</span><span>ARTIST</span><span>_</span><span>INT</span><span> и между таблицами </span><span>ARTIST</span><span> и </span><span>CUSTOMER</span><span>_</span><span>ARTIST</span><span>_</span><span>INT</span><span>:<o:p></o:p></span></p> <p><span>ALTER TABLE CUSTOMER_ARTIST_INT ADD CONSTRAINT <span>ArtlstIntFK</span><o:p></o:p></span></p> <p><span>FOREIGN <span>KEY(</span><span>ArtistID</span>) REFERENCES ARTIST ON DELETE CASCADE;<o:p></o:p></span></p> <p><span>ALTER TABLE CUSTOMER_ARTIST_INT ADD CONSTRAINT <span>CustonerIntFK</span><o:p></o:p></span></p> <p><span>FOREIGN <span>KEY(</span><span>CustomerID</span>) REFERENCES CUSTOMER ON DELETE CASCADE;<o:p></o:p></span></p> <p><span>Ограничениям даны имена </span><span><span>ArtistIntFK</span></span><span> и </span><span><span>CustomerIntFK</span></span><span>. Эти имена не играют особой роли для </span><span>Oracle</span><span> и могут выбираться разработчиком. Обратите внимание, что для родительской таблицы указан только столбец, являющийся внешним ключом. </span><span><span>Oracle</span><span> предполагает, что внешний ключ будет связан с первичным ключом родительской таблицы, поэтому указывать столбец первичного ключа нет необходимости.</span></span><span> Фраза </span><span>ON</span><span> </span><span>DELETE</span><span> </span><span>CASCADE</span><span> указывает на то, что при удалении строк из родительской таблицы соответствующие строки дочерних таблиц должны быть также удалены. Слово </span><span>cascade</span><span> (каскад) используется здесь потому, что удаление идет каскадом от родительской таблицы <span>к</span> дочерней.<o:p></o:p></span></p> <p><span>Введите эти операторы в редактор </span><span>SQL</span><span> </span><span>Plus</span><span> и заполните несколько строк таблицы пересечения. Теперь, если вы удалите данные о покупателе или художнике, соответствующие строки в таблице пересечения будут также удалены.<o:p></o:p></span></p> <p><span>Создайте таблицы </span><span>WORK</span><span> и </span><span>TRANSACTION</span><span>, Обратите внимание, что в определениях ограничений по внешнему ключу отсутствует фраза </span><span>ON</span><span> </span><span>DELETE</span><span> </span><span>CASCADE</span><span>. Так, ограничение </span><span><span>ArtistFK</span></span><span> сделает невозможным удаление тех строк в таблице </span><span>ARTIST</span><span>, которые имеют дочерние строки и таблице </span><span>WORK</span><span>. Ограничения </span><span><span>WorkFK</span></span><span> и </span><span><span>CustomerFK</span></span><span> функционируют сходным образом.<o:p></o:p></span></p> <p><span>CREATE</span><span> </span><span>TABLE</span><span><span> </span></span><span>WORK</span><span> (<o:p></o:p></span></p> <p><span><span>WorkID</span></span><span><span> </span><span>int</span><span> </span><span> </span>PRIMARY KEY,<o:p></o:p></span></p> <p><span>Description<span> </span><span><span>varchar</span></span><span>(</span>1000)<span> </span>NULL,<o:p></o:p></span></p> <p><span>Title<span> </span><span><span>varchar</span></span><span>(</span>25)<span> </span><span> </span>NOT NULL,<o:p></o:p></span></p> <p><span>Copy<span> </span><span><span>varchar</span></span><span>(</span>8)<span> </span><span> </span><span> </span>NOT NULL,<o:p></o:p></span></p> <p><span><span>ArtistID</span></span><span><span> </span><span>int</span><span> </span><span> </span>NOT NULL);<o:p></o:p></span></p> <p><span>ALTER TABLE WORK ADD CONSTRAINT <span>ArtistFK</span><o:p></o:p></span></p> <p><span>FOREIGN KEY (<span>ArtistID</span>) REFERENCES ARTIST:<o:p></o:p></span></p> <p><span>CREATE TABLE<span> </span>TRANSACTION (<o:p></o:p></span></p> <p><span><span>TransactionID</span></span><span><span> </span><span>int</span><span> </span>PRIMARY KEY,<o:p></o:p></span></p> <p><span><span>DateAcqulred</span></span><span><span> </span>date<span> </span>NOT NULL,<o:p></o:p></span></p> <p><span><span>AcquisitionPrice</span></span><span><span> </span><span>number(</span>7.2)<span> </span>NULL,<o:p></o:p></span></p> <p><span><span>PurchaseDate</span></span><span><span> </span>date<span> </span>NULL,<o:p></o:p></span></p> <p><span><span>SalesPrice</span></span><span><span> </span><span>number(</span>7.2)<span> </span>NULL,<o:p></o:p></span></p> <p><span><span>CustomerID</span></span><span><span> </span><span>int</span><span> </span>NULL,<o:p></o:p></span></p> <p><span>Work ID<span> </span><span>int</span><span> </span>NOT NULL);<o:p></o:p></span></p> <p><span>ALTER TABLE TRANSACTION ADD CONSTRAINT <span>WorkFK</span><o:p></o:p></span></p> <p><span>FOREIGN KEY (<span>WorkID</span>) REFERENCES WORK;<o:p></o:p></span></p> <p><span>ALTER TABLE TRANSACTION ADD CONSTRAINT <span>CustomerFK</span><o:p></o:p></span></p> <p><span>FOREIGN KEY (<span>CustomerID</span>) REFERENCES CUSTOMER;<o:p></o:p></span></p> <p><span>Оператор </span><span>ALTER</span><span> можно также использовать для удаления ограничения. Оператор</span><span> ALTER TABLE MYTABLE DROP CONSTRAINT <span>MyConstraint</span> </span><span>удалит</span><span> </span><span>ограничение</span><span> <span>MyConstraint</span> </span><span>из</span><span> </span><span>таблицы</span><span> <span>MyTable</span>.<o:p></o:p></span></p> <p><a><span>Создание индексов</span></a><span><o:p></o:p></span></p> <p><span>Создайте индекс по столбцу </span><span>Name</span><span> таблицы </span><span>CUSTOMER</span><span>:<o:p></o:p></span></p> <p><span>CREATE INDEX <span>CustNameIdx</span> ON <span>CUSTOMER(</span>Name);<o:p></o:p></span></p> <p><span>Индексу дано имя </span><span><span>CustNameIdx</span></span><span>. Имя не играет роли для </span><span>Oracle</span><span>. Чтобы создать уникальный индекс, перед ключевым словом </span><span>INDEX</span><span> используют ключевое слово </span><span>UNIQUE</span><span>. Например, чтобы гарантировать, что ни одно произведение не:6удет записано дважды в таблицу </span><span>WORK</span><span>, можно создать уникальный индекс по столбцам (</span><span>Title</span><span>, </span><span>Copy</span><span>, </span><span><span>ArtistID</span></span><span>):<o:p></o:p></span></p> <p><span><span>С</span></span><span>REATE UNIQUE INDEX <span>WorkUniqueIndex</span> ON WORK (Title, Copy, <span>ArtistID</span>);<o:p></o:p></span></p> <p><a><span>Изменение структуры таблиц, контрольные ограничения</span></a><span><o:p></o:p></span></p> <p><span>После создания таблицы ее структуру можно изменять с помощью оператора </span><span>ALTER</span><span> </span><span>TABLE</span><span>. Будьте, однако, осторожны с этим оператором, поскольку при его использовании возможна потеря данных,<o:p></o:p></span></p> <p><span>Добавление или удаление столбца:<o:p></o:p></span></p> <p><span>ALTER TABLE MYTABLE ADD C1 <span>NUMBER(</span>4);<o:p></o:p></span></p> <p><span>ALTER TABLE MYTABLE DROP COLUMN C1;<o:p></o:p></span></p> <p><a><span>Ограничения на модификацию столбцов таблиц</span></a><span><o:p></o:p></span></p> <p><span>Чтобы добавить непустой (NOT NULL) столбец, сначала создают его в таблице как пустой, заполняют все его строки данными, а затем объявляют непустым (</span><span>NOT</span><span> </span><span>NULL</span><span>) с помощью предложения </span><span>MODIFY</span><span>. <o:p></o:p></span></p> <p><span>Модифицируем таблицу ARTIST. Мы установили для столбцов <span>BirthDate</span> (дата рождения) и <span>DeceasedDate</span> (дата смерти) тип данных <span>Date</span>. Допустим, что пользователям базы данных не нужно, чтобы и этих столбцах хранилась полная дата, а нужен только год рождения или смерти художника. Предположим также, что из представленных в галерее художников нет ни одного, кто бы родился или умер ранее 1400 года или позже 2100 года.<o:p></o:p></span></p> <p><span>Пока </span><span>эти столбцы имеют пустые значения, что позволяет нам менять тип данных, не удаляя сами столбцы<span>.:</span><o:p></o:p></span></p> <p><span>ALTER TABLE ARTIST MODIFY <span>BirthDate</span> <span>Number(</span>4);<o:p></o:p></span></p> <p><span>ALTER TABLE ARTIST MODIFY <span>DeceasedDate</span> <span>Number(</span>4);<o:p></o:p></span></p> <p><span>Следующие два оператора устанавливают пределы значений столбцов <span>BirthDate</span> и <span>DeceasedDate</span>:<o:p></o:p></span></p> <p><span>ALTER TABLE ARTIST ADD CONSTRAINT <span>BDLimit</span> CHECK (<span>BirthDate</span> BETWEEN 1400 AND 2100):<o:p></o:p></span></p> <p><span>ALTER TABLE ARTIST ADD CONSTRAINT <span>DDLimit</span> CHECK (<span>DeceasedDate</span> BETWEEN 1400 AND 2100).<o:p></o:p></span></p> <p><span>Выполним</span><span> </span><span>команды</span><span> </span><span>обновления</span><span>:<o:p></o:p></span></p> <p><span>UPDATE ARTIST SET <span>BirthDate</span> = 1870 WHERE Name = '<span>Miro</span>':<o:p></o:p></span></p> <p><span>UPDATE ARTIST SET <span>BirthDate</span> = 1270 WHERE Name = 'Tobey':<o:p></o:p></span></p> <p><span>Первое обновление пройдет успешно, а второе нарушит ограничение и поэтому не будет выполнено. Попробуйте запустить эти операторы и посмотрите, каковы будут результаты.<o:p></o:p></span></p> <p><a><span>Представления</span></a><span><o:p></o:p></span></p> <p><span>Важное ограничение </span><span>SQL</span><span>-представлений состоит в том, что они могут содержать не более одного многозначного пути.<o:p></o:p></span></p> <p><span>Определим представление, соединяющее три таблицы, с наложенным условием на столбцы </span><span><span>AcquisitionPrice</span></span><span> и </span><span><span>CustomerID</span></span><span>. Это <span>представления соединения</span> – они базируются на соединениях.<o:p></o:p></span></p> <p><span>CREATE</span><span> </span><span>VIEW</span><span> </span><span><span>ExpensiveArt</span></span><span> </span><span>AS</span><span><o:p></o:p></span></p> <p><span>SELECT<span> </span>Name, Copy, Title<o:p></o:p></span></p> <p><span>FROM<span> </span>ARTIST, WORK, TRANSACTION<o:p></o:p></span></p> <p><span>WHERE<span> </span><span>ARTIST.ArtistID</span><span> </span>=<span> </span><span>WORK.ArtistID</span> AND<o:p></o:p></span></p> <p><span><span>WORK.WorkID</span></span><span><span> </span>=<span> </span><span>TRANSACTION.WorkID</span> AND<o:p></o:p></span></p> <p><span><span>AcquisitionPrice</span></span><span><span> </span>><span> </span>10000 AND<o:p></o:p></span></p> <p><span><span>CustomerID</span></span><span> </span><span>IS</span><span> </span><span>NULL</span><span>;<o:p></o:p></span></p> <p><span>Вообще говоря, представления, основанные на одной таблице, допускают обновление данных. Если это почему-либо нежелательно, вы можете создать представление только для чтения, добавив выражение </span><span>WITH</span><span> </span><span>READ</span><span> </span><span>ONLY</span><span> в конец определения представления. Так</span><span>, </span><span>выражение</span><span> <span><o:p></o:p></span></span></p> <p><span>CREATE VIEW V1 AS SELECT * FROM ARTIST WITH READ ONLY;<o:p></o:p></span></p> <p><span>создаст представление, доступное только для чтения.<o:p></o:p></span></p> <p><span>Иногда для обновления данных и представлении можно использовать </span><span>SQL</span><span>-оператор </span><span>UPDATE</span><span>, но это возможно только в особых обстоятельствах и только в том случае, если изменение затрагивает только одну таблицу.<o:p></o:p></span></p> <p><span>В общем же случае оператор </span><span>UPDATE</span><span> не может использоваться для обновления данных о представлении. Для этих целей потребуется написать специальный триггер, называемый замещающим триггером (триггер </span><span>INSTEAD</span><span> </span><span>OF</span><span>)<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>3. Порядок выполнения работы: <o:p></o:p></span></b></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Ознакомиться с учебным материалом<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Вывести на экран информацию о таблицах пользователя<o:p></o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Вывести на экран информацию о структуре одной из таблиц<o:p></o:p></span></p> <p><![if !supportLists]><span><span>4.<span> </span></span></span><![endif]><span>Вывести в отчет информацию физических <span>атрибутах</span> таблицы </span><span>Artist</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>5.<span> </span></span></span><![endif]><span>Ввести данные для следующих ситуаций:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>a.<span> </span></span></span><![endif]><span>На склад поступили репродукции картин 2-х русских художниках. Как минимум одно произведение - первого художника и два произведения - второго. (Прошу обратить внимание, что требуются данные о реальных художниках!)<o:p></o:p></span></p> <p><![if !supportLists]><span><span>b.<span> </span></span></span><![endif]><span>Сначала появился первый покупатель и приобрел картину первого художника. Затем появился другой покупатель и приобрел репродукции второго художника. Сделки были оформлены.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>6.<span> </span></span></span><![endif]><span>Внести данные в соответствующие таблицы, в том числе отобразить предпочтения покупателя к картинам определенных художников.<span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>7.<span> </span></span></span><![endif]><span>Последовательно отобразить содержимое всех таблиц<o:p></o:p></span></p> <p><![if !supportLists]><span><span>8.<span> </span></span></span><![endif]><span>Согласов<a></a>ать с преподавателем содержание отчёта и подготовить его.</span><span><o:p></o:p></span></p> </div> 
 <A HREF="../practice.htm">Оглавление</A>              
  <p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>