<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Практика по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" TITLE="Программа курса (Откроется в новом окне)">Программа</A> |
                                                  <A HREF="../../Теория/theory.htm">Теория</A> |
                                                  <strong>Практика</strong>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
    <P class="margined">
        <FONT SIZE=4>
            <CENTER>
            </CENTER>
        </FONT>
        <table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../practice.htm">Оглавление</A>
                <p>&nbsp;</p>
                 <div> 
<p><b><span>Лабораторная работа 9 Создание триггеров  </span></b></p>
<p><b><span>1. Цель работы<o:p></o:p></span></b></p> <p><span>Формирование практических умений по созданию триггеров для БД </span><span>ORACLE</span><span>.<i><o:p></o:p></i></span></p> <p><b><span>2. Учебный материал по <span>лабораторной</span></span></b><span><o:p></o:p></span></p> <p><a><span>Триггеры</span></a><span><o:p></o:p></span></p> <p><span>Триггеры в </span><span>Oracle</span><span> — это процедуры на языке </span><span>Java</span><span> или </span><span>SQL</span><span>, которые вызываются при выполнении определенных действий с базой данных. </span><span>Oracle</span><span> поддерживает несколько типов триггеров: одни запускаются командами </span><span>SQL</span><span>, создающими в базе данных новые структуры, например таблицы, другие запускаются единожды на уровне таблицы, когда происходит изменение строк таблицы, третьи запускаются по одному разу для каждой измененной строки. Последние называются <span>строчными триггерами</span> (</span><span>row</span><span> </span><span>triggers</span><span>); их мы и будем рассматривать здесь. </span><span>Oracle</span><span> поддерживает три вида триггеров: предваряющие (триггеры </span><span>BEFORE</span><span>), завершающие (триггеры </span><span>AFTER</span><span>) и замещающие (триггеры </span><span>INSTEAD</span><span> </span><span>OF</span><span>). Рассмотрим примеры каждого из этих типов.<span><o:p></o:p></span></span></p> <p><a><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Создайте в таблице TRANSACTION новый столбец под именем </span></a><span><span><span>AskingPrice</span></span></span><span><span> типа <span>Number</span>(7, 2). <o:p></o:p></span></span></p> <p><span><span>Пример предваряющего триггера</span></span><span><o:p></o:p></span></p> <p><span>В листинге 1 показан предваряющий триггер, который используется для задания значения строки перед обновлением. В</span><span> </span><span>листинге</span><span> 1 </span><span>триггер</span><span> <span>New_Price</span> </span><span>определен</span><span> </span><span>фразой</span><span><o:p></o:p></span></p> <p><span><span> </span><span>Before Insert or Update of <span>AcquisitionPrice</span> ON TRANSACTION.</span> <o:p></o:p></span></p> <p><span>Эта фраза, являясь правильной, содержит неопределенность. Она означает «ПЕРЕД (любой) вставкой в транзакции или ПЕРЕД обновлением </span><span><span>AcquisitionPrice</span></span><span> в транзакции запустить триггер». Таким образом, триггер будет запущен при любой вставке или при обновлении столбца </span><span><span>AcquisitionPrice</span></span><span>. Обновления других столбцов не вызовут запуска триггера.<span><o:p></o:p></span></span></p> <p><span>Листинг 1.</span><span> Предваряющий триггер </span><span>New</span><span>_</span><span>Price</span><span><o:p></o:p></span></p> <p><span>CREATE OR REPLACE TRIGGER <span>New_Price</span><o:p></o:p></span></p> <p><span>BEFORE INSERT OR UPDATE of <span>Acquisitionprice</span> ON TRANSACTION<o:p></o:p></span></p> <p><span>FOR</span><span> </span><span>EACH</span><span> </span><span>ROW</span><span><o:p></o:p></span></p> <p><span>/* Устанавливаем новое значение </span><span><span>AskingPrice</span></span><span> перед вставкой или обновлением */<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>BEGIN<o:p></o:p></span></p> <p><span><span>:<span>new.AskingPrice</span></span></span><span> := :<span>new.AcquistionPrice</span> * 2;<o:p></o:p></span></p> <p><span>END</span><span>;<o:p></o:p></span></p> <p><span>Фраза </span><span>FOR</span><span> </span><span>EACH</span><span> </span><span>ROW</span><span> (для каждой строки) указывает, что данный триггер является строчным. Логика его работы проста: новое значение </span><span><span>AskingPrice</span></span><span> вычисляется как удвоенное новое значение </span><span><span>AcquisitionPrice</span></span><span>.<span><o:p></o:p></span></span></p> <p><span>Префикс </span><span>new</span><span> доступен только для триггеров. Он обозначает новое значение столбца в команде </span><span>INSERT</span><span> или </span><span>UPDATE</span><span>. Так, </span><span>new</span><span>.</span><span><span>AcquisitionPrice</span></span><span> обозначает новое значение </span><span><span>AcquisitionPrice</span></span><span> (заданное пользователем). Для обновлений и удалений существую также префикс </span><span>old</span><span>, обозначающий значение столбца до выполнения команды </span><span>UPDATE</span><span> или </span><span>DELETE</span><span>.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Создайте триггер<o:p></o:p></span></p> <p><span>Создайте триггер в файле </span><span>Trig</span><span>1.</span><span><span>sql</span></span><span>. Запустите файл в </span><span>SQL</span><span> </span><span>Plus</span><span> - триггер скомпилируется. Если не будет ошибок компиляции, триггер будет сохранен в базе данных и станет активным. Обновите столбец </span><span><span>AcquisitionPrice</span></span><span> и затем выберите строки, которые вы обновили. Значение столбца </span><span><span>AskingPrice</span></span><span> будет задано триггером.<o:p></o:p></span></p> <p><span>Если у вас будут ошибки компиляции, вы сможете их увидеть, введя команду </span><span>Show</span><span> </span><span>Errors</span><span>, как это делалось<a> ранее с хранимыми процедурами.<o:p></o:p></a></span></p> <p><span><span>Пример завершающего триггера</span></span><span><o:p></o:p></span></p> <p><span>В листинге 2 показан пример завершающего триггера. Логика его такова: </span><span><span>View</span><span> </span><span>Ridge</span><span> определяет произведение, предназначенное для продажи, как любое произведение, имеющее строку в таблице </span><span>TRANSACTION</span><span> с пустым значением </span><span><span>CustomerID</span></span><span>.</span></span><span> Задача этого триггера — гарантировать, что такая строка в таблице </span><span>TRANSACTION</span><span> будет существовать, когда в базу данных будет записываться произведение. Этот триггер, запускаемый при создании строки в таблице </span><span>WORK</span><span>, проверяет таблицу </span><span>TRANSACTION</span><span> и не производит никаких действий, если находит в ней подходящую строку.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Листинг 2.</span><span> Завершающий триггер </span><span>On</span><span>_</span><span>Work</span><span>_</span><span><span>lnsert</span></span><span><o:p></o:p></span></p> <p><span>CREATE OR REPLACE TRIGGER <span>On_WORK_Insert</span><o:p></o:p></span></p> <p><span>AFTER INSERT ON WORK<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>FOR EACH ROW<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>DECLARE<o:p></o:p></span></p> <p><span><span><span>rowcount</span></span></span><span><span> </span>integer(2);<o:p></o:p></span></p> <p><span>BEGIN<o:p></o:p></span></p> <p><span>/* <span>Счи</span></span><span>таем</span><span> <span>доступные</span> </span><span>строки</span><span> */<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>SELECT<span> </span>Count (*) INTO <span>rowcount</span><o:p></o:p></span></p> <p><span>FROM<span> </span>TRANSACTION<o:p></o:p></span></p> <p><span>WHERE<span> </span><span>CustomerID</span> IS NULL AND WorkID5:new.WorkID;<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>IF</span><span> </span><span><span>rowcoiint</span></span><span> > 0 </span><span>Then</span><span> /* Строка существует, ничего не<o:p></o:p></span></p> <p><span>предпринимаем */<o:p></o:p></span></p> <p><span>DBMS</span><span>_</span><span>OUTPUT</span><span>.</span><span>PUT</span><span>_</span><span>LINE</span><span> ('Подходящая строка в таблице </span><span>TRANSACTION</span><span> существует -- никаких действий не предпринято.');<o:p></o:p></span></p> <p><span>RETURN</span><span>;<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>ELSE</span><span> /* Нужно добавить новую строку */<o:p></o:p></span></p> <p><span>INSERT INTO TRANSACTION (<span>TransactionID</span>. <span>DateAcquired</span>, <span>WorkID</span>)<o:p></o:p></span></p> <p><span>VALUES (<span>TransID.NextVal</span> <span>SysDate</span><span>. :</span><span>new.WorkID</span>):<o:p></o:p></span></p> <p><span>END</span><span> </span><span>IF</span><span>;<o:p></o:p></span></p> <p><span>END</span><span>;<o:p></o:p></span></p> <p><span>/<o:p></o:p></span></p> <p><span>Логика работы триггера элементарна. Он подсчитывает количество подходящих строк, и если это количество больше нуля, то ничего не предпринимается;<o:p></o:p></span></p> <p><span>если оно равно нулю, в таблице TRANSACTION создается новая строка с соответствующими данными. Обратите внимание на то, как префикс<span> :</span><span>new</span> используется в части VALUES оператора INSERT.<o:p></o:p></span></p> <p><span>Пример замещающего триггера<o:p></o:p></span></p> <p><span>Замещающие триггеры используются для обновления представлений, Рассмотрим представление, определенное в листинге 3. Оно соединяет в себе четыре таблицы и, как представление соединения, не может быть обновлено без помощи соответствующего триггера.<o:p></o:p></span></p> <p><span>Листинг</span><span> 3. </span><span>Определение</span><span> </span><span>представления</span><span> <span>CustomerPurchases</span><o:p></o:p></span></p> <p><span>CREATE VIEM <span>CustomerPurchases</span> AS<o:p></o:p></span></p> <p><span>SELECT<span> </span><span>CUSTOMER.Name</span> <span>CustName</span>, Copy, Title, <span>ARTIST.Name</span> <span>ArtistName</span><o:p></o:p></span></p> <p><span>FROM<span> </span>CUSTOMER, TRANSACTION, WORK, ARTIST<o:p></o:p></span></p> <p><span>WHERE<span> </span><span>CUSTOMER.CustomerID</span> = <span>TRANSACTION.CustomerID</span> AND<o:p></o:p></span></p> <p><span><span>TRANSACTION.WorkID</span></span><span> = <span>WORK.WorkID</span> AND<o:p></o:p></span></p> <p><span><span>WORK.ArtistID</span></span><span> = <span>ARTIST.ArtiStID</span>;<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Создать представление и вывести содержащиеся в нем данные<o:p></o:p></span></p> <p><span>Обратите внимание на фразу SELECT в определении этого представления. Она задает синонимы для столбцов <span>CUSTOMER.Name</span> (синоним <span>CustName</span>) и <span>ARTIST.Name</span> (синоним <span>ArtistName</span>). Если бы это не было сделано, в представлении оказалось бы одна столбца с именем <span>Name</span>, а такое недопустимо.<o:p></o:p></span></p> <p><span>Исследуйте данные выведенные в представлении; подумайте, что должно произойти, когда пользователь попытается обновить столбец <span>Title</span>. Название «<span>Mystic</span> <span>Fabric</span>» фигурирует в трех строках, но в таблице WORK имеется только две строки с таким названием. Что должна сделать <span>Oracle</span>, когда пользователь обновит столбец <span>Title</span>? Должна ли она обновить строки в таблице WORK, на <span>котором</span> основано это представление? Или она должна создать в таблице WORK новые строки и связать их со строками данного представления? А может, необходимо сделать что-то другое?<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Невозможно написать для СУБД обобщенный код, который бы корректно обрабатывал каждую возможную ситуацию.<o:p></o:p></span></p> <p><span>Замещающие триггеры позволяют разработчику задать действия, которые необходимо предпринять при попытке обновить представление в конкретном приложении. В листинге 4 показан пример такого триггера, который обрабатывает обновления столбца </span><span>Title</span><span> представления </span><span><span>CustomerPurchases</span></span><span>. Поскольку замещающие триггеры, в отличие от предваряющих, не могут содержать фразу </span><span>UPDATE</span><span> </span><span>OF</span><span>, мы должны написать код, определяющий, был ли изменен столбец </span><span>Title</span><span>.<o:p></o:p></span></p> <p><span>Листинг</span><span> 4.</span><span> </span><span>Замещающий</span><span> </span><span>триггер</span><span> <span>Title_Update</span><o:p></o:p></span></p> <p><span>CREATE OR REPLACE TRIGGER <span>Title_Update</span><o:p></o:p></span></p> <p><span>INSTEAD OF UPDATE ON <span>CustomerPurchases</span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>FOR EACH ROW<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>BEGIN</span><span><o:p></o:p></span></p> <p><span>/* Ничего не делаем, кроме случая, когда обновляется столбец </span><span>Title</span><span> */<o:p></o:p></span></p> <p><span><span>IF :<span>new.Title</span></span></span><span> 5 :<span>old.Title</span> THEN<o:p></o:p></span></p> <p><span>RETURN;<o:p></o:p></span></p> <p><span>END IF;<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>UPDATE<span> </span>WORK<o:p></o:p></span></p> <p><span>SET<span> </span>Title <span>= :</span>new.Tit1e<o:p></o:p></span></p> <p><span>WHERE<span> </span>Title <span>= :</span><span>old.Title</span>;<o:p></o:p></span></p> <p><span>END;<o:p></o:p></span></p> <p><span>Если пользователь обновляет столбец </span><span>Title</span><span>, то соответствующее изменение вносится в таблицу </span><span>WORK</span><span>. Обратите внимание, что запуск триггера происходит при обновлении представления </span><span><span>CustomerPurchases</span></span><span>, но <span>само обновление</span> производится в таблице </span><span>WORK</span><span> — одной из таблиц, на которой базируется это представление. Как раз для таких действий и предназначаются замещающие триггеры,<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Этот триггер может приводить к неожиданным результатам. Если</span><span> </span><span>пользователь</span><span> </span><span>введет</span><span>:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>UPDATE <span>CustomerPurchases</span> SET Title = '<span>аа</span>'. Copy = '1/3' WHERE Title = 'bb';<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>то будет произведено обновление столбца </span><span>Title</span><span>, но ничего не произойдет со столбцом </span><span>Copy</span><span>. Лучше было бы выдать пользователю сообщение, предупреждающее о таком эффекте.<o:p></o:p></span></p> <p><a><span>Обработка исключений</span></a><span><o:p></o:p></span></p> <p><span>В лекциях опущена тема обработки исключений в </span><span>PL</span><span>/</span><span>SQL</span><span>. Однако, обработка исключений важна и полезна. Дело в том, что эта тема является слишком обширной, чтобы обсуждать ее подробно. Однако если вы в будущем собираетесь программировать на </span><span>PL</span><span>/</span><span>SQL</span><span>, обязательно изучите этот важный вопрос. Обработка исключений может использоваться в любых видах процедур на PL/SQL, но особо она полезна в предваряющих и замещающих триггерах для отмены незафиксированных обновлений. Исключения необходимы потому, что в <span>Oracle</span> откат транзакции невозможно произвести в теле триггера. Вместо этого можно использовать исключения для генерации предупреждений и сообщений об ошибках. Исключения также дают <span>Oracle</span> больше информации о том, что делает триггер.<o:p></o:p></span></p> <p><span>Например, триггер, изображенный в листинге 4, имеет странную особенность. Если</span><span> </span><span>вы</span><span> </span><span>введете</span><span><o:p></o:p></span></p> <p><span>UPDATE <span>CustomerPurchases</span> SET Copy = '5/5' WHERE Title = 'Mystic Fabric';<o:p></o:p></span></p> <p><span>триггер не обновит ни одной строки. Однако <span>Oracle</span> сообщит, что все строки представления, имеющие в столбце <span>Title</span> название «<span>Mystic</span> <span>Fabric</span>», были обновлены. Это было обусловлено тем, что триггеру были переданы все строки, и <span>Oracle</span> не знала, какая из них вызвала обновление, а какая нет. Если же вы включите в этот триггер код, генерирующий исключение, <span>Oracle</span> будет знать, что строка не была обновлена, и выдаст правильно<a>е количество обновленных строк.<o:p></o:p></a></span></p> <p><span><span>Словарь данных</span></span><span><o:p></o:p></span></p> <p><span><span>Oracle</span></span><span> поддерживает исчерпывающий словарь метаданных. Этот словарь описывает структуру таблиц, последовательностей, представлений, индексов, ограничений, хранимых процедур и многого другого. Он также содержит исходные тексты процедур, функций и триггеров. И это еще не все.<o:p></o:p></span></p> <p><span>В таблице DICT словаря метаданных содержатся данные, описывающие сам словарь. Вы можете запрашивать данные из этой таблицы, чтобы узнать больше о содержимом словаря данных, но имейте в виду, что она имеет большие размеры. Например, если вы запросите имена всех таблиц словаря данных, вам будет возвращено более 800 строк.<o:p></o:p></span></p> <p><span>Предположим, Вы хотите узнать, какие таблицы с информацией о пользовательских и системных таблицах имеются в словаре данных. В</span><span> </span><span>этом</span><span> </span><span>вам</span><span> </span><span>поможет</span><span> </span><span>следующий</span><span> </span><span>запрос</span><span>;<o:p></o:p></span></p> <p><span>SELECT<span> </span><span>Table_Name</span>, Contents<o:p></o:p></span></p> <p><span>FROM<span> </span>DICT<o:p></o:p></span></p> <p><span>WHERE<span> </span><span>Table_Name</span> LIKE (‘%<span>TABLES%</span>’);<o:p></o:p></span></p> <p><span>Будет возвращено около двадцати пяти строк. Одна из таблиц будет называться USER_TABLES. Чтобы увидеть столбцы этой таблицы, введите<o:p></o:p></span></p> <p><span>DESC<span> </span>USER_</span><span>T</span><span>ABLES:<o:p></o:p></span></p> <p><span>Вы можете использовать эту стратегию для получения из словаря метаданных информации об интересующих вас объектах и структурах. В таблице перечислены многие из представлений и указано их назначение. Таблицы USER_SOURCE и USER_TRIGGERS полезны, когда требуется узнать, исходные тексты каких процедур и триггеров хранятся в настоящий момент в базе данных.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Таблица.<span> </span><span> </span>Некоторые полезные таблицы из словаря данных </span><span>Oracle</span><span><o:p></o:p></span></p> <table border="1" cellspacing="0" cellpadding="0" style="margin:0 auto;"> <tr> <td width="180" valign="top"> <p><span>Имя таблицы<o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Содержимое<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>DICT<o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Метаданные, описывающие словарь данных<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER</span><span>_</span><span>CATALOG</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Список таблиц, представлений, последовательностей и других структур, принадлежащих пользователю<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_TABLES</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Структуры таблиц пользователя<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_TAB_COLUMNS</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Потомок таблицы </span><span>USER</span><span>_</span><span>TABLES</span><span>. Содержит данные о столбцах таблиц. Синонимом является</span><span> COLS</span><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_VIEWS</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Пользовательские представления<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_CONSTRAINTS</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Пользовательские ограничения<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_CONS_COLUMNS</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Потомок таблицы </span><span>USER</span><span>_</span><span>CONSTRAINTS</span><span>. Содержит столбцы, на которые наложены ограничения<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_TRIGGERS</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Метаданные, описывающие триггеры, Запрашивайте столбцы </span><span>Trigger</span><span>_</span><span>Name</span><span>, </span><span>Trigger</span><span>_</span><span>Type</span><span> и </span><span>Trigger</span><span>_</span><span>Event</span><span>. Предупреждение'. </span><span>Trigger</span><span>_</span><span>Body</span><span> в действительности не содержит исходного кода триггера.<o:p></o:p></span></p> </td> </tr> <tr> <td width="180" valign="top"> <p><span>USER_SOURCE</span><span><o:p></o:p></span></p> </td> <td width="444" valign="top"> <p><span>Чтобы получить те<span>кст пр</span>оцедуры </span><span>MYTRIGGER</span><span>. введите<o:p></o:p></span></p> <p><span>SELECT Text<o:p></o:p></span></p> <p><span>FROM USER_SOURCE<o:p></o:p></span></p> <p><span>WHERE Name='MYTRIGGER'<o:p></o:p></span></p> <p><span><span> </span>AND<o:p></o:p></span></p> <p><span><span> </span>Type='PROCEDURE'</span><span><o:p></o:p></span></p> </td> </tr> </table> <p><span><o:p> </o:p></span></p> <p><b><span>3. Порядок выполнения работы<o:p></o:p></span></b></p> <p><span>1. Ознакомиться с учебным материалом<o:p></o:p></span></p> <p><span>2. Создать в таблице TRANSACTION новый столбец под именем <span>AskingPrice</span> типа <span>Number</span>(7, 2)<o:p></o:p></span></p> <p><span>3. Создать триггер<o:p></o:p></span></p> <p><span>4. С<a></a>оздать представление и вывести содержащиеся в нем данные<o:p></o:p></span></p> <p><span>5. Самостоятельно исследовать словарь метаданных. <span>(Имейте в виду, что <span>Oracle</span> записывает все имена в верхнем регистре.</span> <span>Если<span> </span>вы<span> </span>ищете<span> </span>триггер<span> <span>On_Customer__Insert</span>,<span> </span></span><span>вам</span><span> </span>следует<span> </span>искать<span> </span>имя<span> ON_CUSTOMER_INSERT)</span></span></span><span><o:p></o:p></span></p> <p><span>6. <span>Согласовать с преподавателем содержание отчёта и подготовить его.</span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><o:p> </o:p></p> </div> 
 <A HREF="../practice.htm">Оглавление</A>                
<p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>