<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Практика по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" TITLE="Программа курса (Откроется в новом окне)">Программа</A> |
                                                  <A HREF="../../Теория/theory.htm">Теория</A> |
                                                  <strong>Практика</strong>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
    <P class="margined">
        <FONT SIZE=4>
            <CENTER>
            </CENTER>
        </FONT>
        <table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../practice.htm">Оглавление</A>
                 <div> <p><a><b><span>Практическая работа №2 </span></b></a><span><b><span>Использование системных функций для работы с файловой системой.<o:p></o:p></span></b></span></p> <span></span> <p><b><span>1. Цель работы<o:p></o:p></span></b></p> <p><span>Изучение системы ввода/вывода платформы Java и средств для работы с потоками данных.<b><o:p></o:p></b></span></p> <p><b><span>2. Учебный материал по практической<o:p></o:p></span></b></p> <p><span>Для того чтобы отвлечься от особенностей конкретных устройств ввода/вывода, в Java употребляется понятие потока (stream). Считается, что в программу идет входной поток (input stream) символов Unicode или просто байтов, воспринимаемый в программе методами read(). Из программы методами write о или print (), println() выводится выходной поток (output stream) символов или байтов. При этом неважно, куда направлен поток: на консоль, на принтер, в файл или в сеть, методы write () и print () ничего об этом не знают.<o:p></o:p></span></p> <p><span>Можно представить себе поток как трубу, по которой в одном направлении последовательно "текут" символы или байты, один за другим. Методы read () , write () , print (), println () взаимодействуют с одним концом трубы, другой конец соединяется с источником или приемником данных конструкторами классов, в которых реализованы эти методы. <o:p></o:p></span></p> <p><span>Конечно, полное игнорирование особенностей устройств ввода/вывода сильно замедляет передачу информации. Поэтому в Java все-таки выделяется файловый ввод/вывод, вывод на печать, сетевой поток.<o:p></o:p></span></p> <p><span>Три потока определены в классе system статическими полями in, out и err. Их можно использовать без всяких дополнительных определений. Они называются соответственно стандартным вводом (stdin), стандартным выводом (stdout) и стандартным выводом сообщений (stderr). Эти стандартные потоки могут быть соединены с разными конкретными устройствами ввода и вывода.<o:p></o:p></span></p> <p><span>Потоки out и err — это экземпляры класса PrintStream, организующего выходной поток байтов. Эти экземпляры выводят информацию на консоль методами print (), println () и write (), которых в классе Printstream имеется около двадцати для разных типов аргументов.<o:p></o:p></span></p> <p><span>Поток err предназначен для вывода системных сообщений программы: трассировки, сообщений об ошибках или, просто, о выполнении каких-то этапов программы. Такие сведения обычно заносятся в специальные журналы, log-файлы, а не выводятся на консоль. В Java есть средства переназначения потока, например, с консоли в файл.<o:p></o:p></span></p> <p><span>Поток in — это экземпляр класса InputStream. Он назначен на клавиатурный ввод с консоли методами read(). Класс InputStream абстрактный, поэтому реально используется какой-то из его подклассов.<o:p></o:p></span></p> <p><span>Понятие потока оказалось настолько удобным и облегчающим программирование ввода/вывода, что в Java предусмотрена возможность создания потоков, направляющих символы или байты не на внешнее устройство, а в массив или из массива, т. е. связывающих программу с областью оперативной памяти. Более того, можно создать поток, связанный со строкой типа string, находящейся, опять-таки, в оперативной памяти. Кроме того, можно создать канал (pipe) обмена информацией между подпроцессами.<o:p></o:p></span></p> <p><span>Еще один вид потока — поток байтов, составляющих объект Java. Его можно направить в файл или передать по сети,'а потом восстановить в оперативной памяти. Эта операция называется сериализацией (serialization) объектов. <o:p></o:p></span></p> <p><span>Методы организации потоков собраны в классы пакета java.io. Кроме классов, организующих поток, в пакет java.io входят классы с методами преобразования потока, например, можно преобразовать поток байтов, образующих целые числа, в поток этих чисел.<o:p></o:p></span></p> <p><span>В Java есть целых четыре иерархии классов для создания, преобразования и слияния потоков:<o:p></o:p></span></p> <p><span>Reader — абстрактный класс, в котором собраны самые общие методы символьного ввода;<o:p></o:p></span></p> <p><span>Writer — абстрактный класс, в котором собраны самые общие методы символьного вывода;<o:p></o:p></span></p> <p><span>InputStream — абстрактный класс с общими методами байтового ввода; <o:p></o:p></span></p> <p><span>OutputStream — абстрактный класс с общими методами байтового вывода.<o:p></o:p></span></p> <p><span>Классы входных потоков Reader и inputstream определяют по три метода ввода:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>read () — возвращает один символ или байт, взятый из входного потока, в виде целого значения типа int; если поток уже закончился, возвращает -1;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>read (chart] buf) — заполняет заранее определенный массив buf символами из входного потока; в классе inputstream массив типа bytet] и заполняется он байтами; метод возвращает фактическое число взятых из потока элементов или -1, если поток уже закончился;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>read (char[] buf, int offset, int len) — заполняет часть символьного или байтового массива buf, начиная с индекса offset, число взятых из потока элементов равно len; метод возвращает фактическое число взятых из потока элементов или -1.<o:p></o:p></span></p> <p><span>Эти методы выбрасывают IOException, если произошла ошибка ввода/вывода.<o:p></o:p></span></p> <p><span>Четвертый метод skip (long n) "проматывает" поток с текущей позиции на п символов или байтов вперед. Эти элементы потока не вводятся методами read(). Метод возвращает реальное число пропущенных элементов, которое может отличаться от п, например поток может закончиться.<o:p></o:p></span></p> <p><span>Текущий элемент потока можно пометить методом mark (int n), а затем вернуться к помеченному элементу методом reset о, но не более чем через п элементов. Не все подклассы реализуют эти методы, поэтому перед расстановкой пометок следует обратиться к логическому методу marksupported (), который возвращает true, если реализованы методы расстановки и возврата к пометкам.<o:p></o:p></span></p> <p><span>Классы выходных потоков Writer и OutputStream определяют по три почти одинаковых метода вывода:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>write (char[] buf) — выводит массив в выходной поток, в классе Outputstream массив имеет тип byte[];<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>write (char[] buf, int offset, int len) — выводит len элементов массива buf, начиная с элемента с индексом offset;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>write (int elem) в классе Writer - выводит 16, а в классе Outputstream 8 младших битов аргумента elem в выходной поток;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>write (string s) — выводит строку s в выходной поток;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>write (String s, int offset, int len) — выводит len символов строки s, начиная с символа с номером offset.<o:p></o:p></span></p> <p><span>Многие подклассы классов Writer и OutputStream осуществляют буферизованный вывод. При этом элементы сначала накапливаются в буфере, в оперативной памяти, и выводятся в выходной поток только после того, как буфер заполнится. Это удобно для выравнивания скоростей вывода из программы и вывода потока, но часто надо вывести информацию в поток еще до заполнения буфера. Для этого предусмотрен метод flush(). Данный метод сразу же выводит все содержимое буфера в поток. Наконец, по окончании работы с потоком его необходимо закрыть методом closed.<o:p></o:p></span></p> <p><span>Классы, входящие в иерархии потоков ввода/вывода, показаны на рисунок 1 и 2.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shapetype id="_x0000_t75"
 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
 filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="Рисунок_x0020_151" o:spid="_x0000_i1025" type="#_x0000_t75"
 style='width:368.25pt;height:119.25pt;visibility:visible'>
 <v:imagedata src="PR2.files/image001.png" o:title=""/>
</v:shape><![endif]--><img src="PR2.files/image002.jpg" v:shapes="Рисунок_x0020_151"></span><span><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок 1. Иерархия символьных потоков<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_152"
 o:spid="_x0000_i1026" type="#_x0000_t75" style='width:324.75pt;height:160.5pt;
 visibility:visible'>
 <v:imagedata src="PR2.files/image003.png" o:title=""/>
</v:shape><![endif]--><img src="PR2.files/image004.jpg" v:shapes="Рисунок_x0020_152"></span><span><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок 2. Классы байтовых потоков<o:p></o:p></span></p> <p style="text-align: center;"><span><o:p> </o:p></span></p> <p><span>Все классы пакета java.io можно разделить на две группы: классы, создающие поток (data sink), и классы, управляющие потоком (data processing). Классы, создающие потоки, в свою очередь, можно разделить на пять групп:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>1)<span> </span></span></span><![endif]><span><span> </span>классы, создающие потоки, связанные с файлами:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FileReader;<span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FilelnputStream;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FileWriter;<span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FileOutputstream;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>RandomAccessFile.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2)<span> </span></span></span><![endif]><span><span> </span>Классы, создающие потоки, связанные с массивами:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>CharArrayReader</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>ByteArraylnputStream</span><span>;</span><span> <o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>CharArrayWriter</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>ByteArrayOutputStream</span><span>.</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>3)<span> </span></span></span><![endif]><span><span> </span>Классы, создающие каналы обмена информацией между подпроцессами:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PipedReader</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PipedlnputStream</span><span>;</span><span> <o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PipedWriter</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PipedOutputStream</span><span>.</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>4)<span> </span></span></span><![endif]><span><span> </span>Классы, создающие символьные потоки, связанные со строкой:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>StringReader</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>StringWriter</span><span>.</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>5)<span> </span></span></span><![endif]><span><span> </span>Классы, создающие байтовые потоки из объектов Java:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>ObjectlnputStream</span><span>;</span><span> <o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>ObjectOutputStream</span><span>.</span><span><o:p></o:p></span></p> <p><span>Классы, управляющие потоком, получают в своих конструкторах уже имеющийся поток и создают новый, преобразованный поток. Можно представлять их себе как "переходное кольцо", после которого идет труба другого диаметра.<o:p></o:p></span></p> <p><span>Четыре класса созданы специально для преобразования потоков:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FilterReader</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FilterlnputStream</span><span>;</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FilterWriter</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>FilterOutputStream</span><span>.</span><span><o:p></o:p></span></p> <p><span>Сами по себе эти классы бесполезны — они выполняют тождественное преобразование. Их следует расширять, переопределяя методы ввода/вывода. Но для байтовых фильтров есть полезные расширения, которым соответствуют некоторые символьные классы.<o:p></o:p></span></p> <p><span>Четыре класса выполняют буферизованный ввод/вывод:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>BufferedReader<span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>BufferedlnputStream <o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>BufferedWriter<span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>BufferedOutputStream<o:p></o:p></span></p> <p><span>Два класса преобразуют поток байтов, образующих восемь простых типов Java, в эти самые типы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>DatalnputStream</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>DataOutputStream</span><span>.</span><span><o:p></o:p></span></p> <p><span>Два класса содержат методы, позволяющие вернуть несколько символов или байтов во входной поток:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PushbackReader</span><span>;</span><span><span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PushbacklnputStream</span><span>.</span><span><o:p></o:p></span></p> <p><span>Два класса связаны с выводом на строчные устройства — экран дисплея, принтер:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PrintWriter<span> </span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>PrintStream<o:p></o:p></span></p> <p><span>Два класса связывают байтовый и символьный потоки:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>InputStreamReader — преобразует входной байтовый поток в символьный поток;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>OutputStreamWriter — преобразует выходной символьный поток в байтовый поток.<o:p></o:p></span></p> <p><span>Класс StreamTokenizer позволяет разобрать входной символьный поток на отдельные элементы (tokens) подобно тому, как класс stringTokenizer, рассмотренный нами в главе 5, разбирал строку.<o:p></o:p></span></p> <p><span>Из управляющих классов выделяется класс sequenceinputstream, сливающий несколько потоков, заданных в конструкторе, в один поток, и класс<o:p></o:p></span></p> <p><span>LineNumberReader, "умеющий" читать выходной символьный поток построчно. Строки в потоке разделяются символами '\n' и/или '\г'.<o:p></o:p></span></p> <p><span>Для вывода на консоль мы всегда использовали метод println() класса InputStream, никогда не определяя экземпляры этого класса. Мы просто использовали статическое поле out класса System, которое является объектом класса PrintStream. Исполняющая система Java связывает это поле с консолью.<o:p></o:p></span></p> <p><span>Консоль является байтовым устройством, и символы Unicode перед выводом на консоль должны быть преобразованы в байты. Для символов Latin 1 с кодами '\u0000' — '\u00FF' при этом просто откидывается нулевой старший байт и выводятся байты '0х00' —'0xFF'. Для кодов кириллицы, которые лежат в диапазоне '\u0400 1 —'\u04FF 1 кодировки Unicode, и других национальных алфавитов производится преобразование по кодовой таблице, соответствующей установленной на компьютере лакали.<o:p></o:p></span></p> <p><span>Трудности с отображением кириллицы возникают, если вывод на консоль производится в кодировке, отличной от локали. Именно так происходит в русифицированных версиях MS Windows NT/2000. Обычно в них устанавливается локаль с кодовой страницей СР1251, а вывод на консоль происходит в кодировке СР866.<o:p></o:p></span></p> <p><span>В этом случае надо заменить PrintStream, который не может работать с символьным потоком, на PrintWriter и "вставить переходное кольцо" между потоком символов Unicode и потоком байтов system, out, выводимых на консоль, в виде объекта класса OutputStreamWriter. В конструкторе этого объекта следует указать нужную кодировку.<o:p></o:p></span></p> <p><span>Класс PrintStream буферизует выходной поток. Второй аргумент true его конструктора вызывает принудительный сброс содержимого буфера в выходной поток после каждого выполнения метода println(). Но после print() буфер не сбрасывается! Для сброса буфера после каждого print() надо писать flush().<o:p></o:p></span></p> <p><span>Поскольку файлы в большинстве современных операционных систем понимаются как последовательность байтов, для файлового ввода/вывода создаются байтовые потоки с помощью классов Fi</span><span>l</span><span>einputstream и FiieOutputstream. Это особенно удобно для бинарных файлов, хранящих байт-коды, архивы, изображения, звук.<o:p></o:p></span></p> <p><span>Но очень много файлов содержат тексты, составленные из символов. Несмотря на то, что символы могут храниться в кодировке Unicode, эти тексты чаще всего записаны в байтовых кодировках. Поэтому и для текстовых файлов можно использовать байтовые потоки. В таком случае со стороны программы придется организовать преобразование байтов в символы и обратно.<o:p></o:p></span></p> <p><span>Чтобы облегчить это преобразование, в пакет java.io введены классы FineReader и FileWriter. Они организуют преобразование потока: со стороны программы потоки символьные, со стороны файла — байтовые. Это происходит потому, что данные классы расширяют классы InputStreamReader и OutputstreamWriter, соответственно, значит, содержат "переходное кольцо" внутри себя. Несмотря на различие потоков, использование классов файлового ввода/вывода очень похоже.<o:p></o:p></span></p> <p><span>В конструкторах всех четырех файловых потоков задается имя файла в виде строки типа string или ссылка на объект класса File. Конструкторы не только создают объект, но и отыскивают файл и открывают его. <o:p></o:p></span></p> <p><span>При неудаче выбрасывается исключение класса FileNotFoundException, но конструктор класса FileWriter выбрасывает более общее исключение IOException.<o:p></o:p></span></p> <p><span>После открытия выходного потока типа FileWriter или FileQutputStEeam содержимое файла, если он был не пуст, стирается. Для того чтобы можно было делать запись в конец файла, и в том и в другом классе предусмотрен конструктор с двумя аргументами. Если второй аргумент равен true, то происходит дозапись в конец файла, если false, то файл заполняется новой информацией. По окончании работы с файлом поток следует закрыть методом close ().<o:p></o:p></span></p> <p><span>Преобразование потоков в классах FileReader и FileWriter выполняется по кодовым таблицам установленной на компьютере локали. Для правильного ввода кирилицы надо применять FileReader, a нe FileInputStream. Если файл содержит текст в кодировке, отличной от локальной кодировки, то придется вставлять "переходное кольцо" вручную.<o:p></o:p></span></p> <p><span>Операции ввода/вывода по сравнению с операциями в оперативной памяти выполняются очень медленно. Для компенсации в оперативной памяти выделяется некоторая промежуточная область — буфер, в которой постепенно накапливается информация. Когда буфер заполнен, его содержимое быстро переносится процессором, буфер очищается и снова заполняется информацией.<o:p></o:p></span></p> <p><span>Житейский пример буфера — почтовый ящик, в котором накапливаются письма. Мы бросаем в него письмо и уходим по своим делам, не дожидаясь приезда почтовой машины. Почтовая машина периодически очищает почтовый ящик, перенося сразу большое число писем. Представьте себе город, в котором нет почтовых ящиков, и толпа людей с письмами в руках дожидается приезда почтовой машины. Классы файлового ввода/вывода не занимаются буферизацией. Для этой цели есть четыре специальных класса BufferedXxx, перечисленных выше.<o:p></o:p></span></p> <p><b><span>3. Порядок выполнения работы<o:p></o:p></span></b></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Ознакомиться с учебным материалом<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>В </span><span>ide</span><span> </span><span>Eclipse</span><span> создать проект.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Реализовать в проекте: создание файлов, чтение данных из файла и запись данных в файл.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>4.<span> </span></span></span><![endif]><span>Продемонстрировать результат работы преподавателю.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>5.<span> </span></span></span><![endif]><span>Согласовать с преподавателем содержание отчёта и подготовить его.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>4. Контрольные вопросы<o:p></o:p></span></b></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Как организованна работа с файлами в языке </span><span>java</span><span>?<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Расскажи алгоритм чтения данных из файла.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>3.<span> </span></span></span><![endif]><span>Какие классы для буферизованный ввода/выводы данных вы знаете?<o:p></o:p></span></p> <p><![if !supportLists]><span><span>4.<span> </span></span></span><![endif]><span>Опишите как проходит декодирование файла из битового в символьный потоки.<o:p></o:p></span></p> <p><o:p> </o:p></p> </div> 
                <p>&nbsp;</p>
        </table>
 <A HREF="../practice.htm">Оглавление</A>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>