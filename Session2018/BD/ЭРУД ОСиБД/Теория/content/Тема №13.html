<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Теория по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" >Программа</A> | 
                                                    <strong>Теория</strong>|
                                                  <A HREF="../../Практика/practice.htm">Практика</A>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
    <P class="margined">
        <FONT SIZE=4>
            <CENTER>
            </CENTER>
        </FONT>
<table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
                <p>&nbsp;</p>
 <A HREF="../theory.htm">Оглавление</A>
                 <div> <p style="text-align: center;"><b><span>Тема 13. Основы SQL<o:p></o:p></span></b></p> <p style="text-align: center;"><a><b><span>13.1 Язык SQL. Операторы SQL<o:p></o:p></span></b></a></p> <p><span><span>Текущая версия стандарта языка </span></span><span><span>SQL</span></span><span><span> принята в 1992 г. (Официальное название стандарта – Международный стандарт языка баз данных </span></span><span><span>SQL</span></span><span><span> (1992) (</span></span><span><span>International</span></span><span><span> </span></span><span><span>Standart</span></span><span><span> </span></span><span><span>Database</span></span><span><span> </span></span><span><span>Language</span></span><span><span> </span></span><span><span>SQL</span></span><span><span>), неофициальное название – </span></span><span><span>SQL</span></span><span><span>/92, или </span></span><span><span>SQL</span></span><span><span>-92, или </span></span><span><span>SQL</span></span><span><span>2). Документ, описывающий стандарт, содержит более 600 страниц. <o:p></o:p></span></span></p> <p><span><span>Язык SQL стал фактически стандартным языком доступа к базам данных. Все СУБД, претендующие на название "реляционные", реализуют тот или иной диалект SQL. Многие нереляционные системы также имеют в настоящее время средства доступа к реляционным данным. Целью стандартизации является переносимость приложений между различными СУБД. <o:p></o:p></span></span></p> <p><span><span>В настоящее время, ни одна система не реализует стандарт SQL в полном объеме. Кроме того, во всех диалектах языка имеются возможности, не являющиеся стандартными. Таким образом, можно сказать, что каждый диалект – это надмножество некоторого подмножества стандарта SQL. Это затрудняет переносимость приложений, разработанных для одних СУБД в другие СУБД. <o:p></o:p></span></span></p> <p><span><span>Язык SQL оперирует терминами, несколько отличающимися от терминов реляционной теории, например, вместо "отношений" используются "таблицы", вместо "кортежей" - "строки", вместо "атрибутов" - "колонки" или "столбцы". <o:p></o:p></span></span></p> <p><span><span>Стандарт языка SQL, хотя и основан на реляционной теории, но во многих местах отходит он нее. Например, отношение в реляционной модели данных не допускает наличия одинаковых кортежей, а таблицы в терминологии SQL могут иметь одинаковые строки. Имеются и другие отличия. <o:p></o:p></span></span></p> <p><span><span>Язык SQL является реляционно полным. Это означает, что любой оператор реляционной алгебры может быть выражен подходящим оператором SQL. <o:p></o:p></span></span></p> <p><span><span>Основу языка SQL составляют операторы, условно разбитые не несколько групп по выполняемым функциям. <o:p></o:p></span></span></p> <p><span><span>Можно выделить следующие группы операторов (перечислены не все операторы SQL).<o:p></o:p></span></span></p> <p><span><span> <o:p></o:p></span></span></p> <p><span><i><span>Операторы DDL (Data Definition Language) - операторы определения объектов базы данных<o:p></o:p></span></i></span></p> <p><span><span>CREATE SCHEMA - создать схему базы данных <o:p></o:p></span></span></p> <p><span><span>DROP SHEMA - удалить схему базы данных <o:p></o:p></span></span></p> <p><span><span>CREATE TABLE - создать таблицу <o:p></o:p></span></span></p> <p><span><span>ALTER TABLE - изменить таблицу <o:p></o:p></span></span></p> <p><span><span>DROP TABLE - удалить таблицу <o:p></o:p></span></span></p> <p><span><span>CREATE DOMAIN - создать домен <o:p></o:p></span></span></p> <p><span><span>ALTER DOMAIN - изменить домен <o:p></o:p></span></span></p> <p><span><span>DROP DOMAIN - удалить домен <o:p></o:p></span></span></p> <p><span><span>CREATE COLLATION - создать последовательность <o:p></o:p></span></span></p> <p><span><span>DROP COLLATION - удалить последовательность <o:p></o:p></span></span></p> <p><span><span>CREATE VIEW - создать представление <o:p></o:p></span></span></p> <p><span><span>DROP VIEW - удалить представление <o:p></o:p></span></span></p> <p><span><span> <o:p></o:p></span></span></p> <p><span><i><span>Операторы DML (Data Manipulation Language) - операторы манипулирования данными:<o:p></o:p></span></i></span></p> <p><span><span>SELECT – отобрать строки из таблиц;<o:p></o:p></span></span></p> <p><span><span>INSERT – добавить строки в таблицу;<o:p></o:p></span></span></p> <p><span><span>UPDATE – изменить строки в таблице; <o:p></o:p></span></span></p> <p><span><span>DELETE – удалить строки в таблице;<o:p></o:p></span></span></p> <p><span><span>COMMIT – зафиксировать внесенные изменения;<o:p></o:p></span></span></p> <p><span><span>ROLLBACK – откатить внесенные изменения.<o:p></o:p></span></span></p> <p><span><span><span> </span><o:p></o:p></span></span></p> <p><span><i><span>Операторы защиты и управления данными:<o:p></o:p></span></i></span></p> <p><span><span>CREATE ASSERTION – создать ограничение;<o:p></o:p></span></span></p> <p><span><span>DROP ASSERTION – удалить ограничение;<o:p></o:p></span></span></p> <p><span><span>GRANT – предоставить привилегии пользователю или приложению на манипулирование объектами;<o:p></o:p></span></span></p> <p><span><span>REVOKE – отменить привилегии пользователя или приложения.<o:p></o:p></span></span></p> <p><span><span> <o:p></o:p></span></span></p> <p><span><span>Кроме того, есть группы операторов установки параметров сеанса, получения информации о базе данных, операторы статического SQL, операторы динамического SQL.<o:p></o:p></span></span></p> <p><span><span>Наиболее важными для пользователя являются операторы манипулирования данными (DML).<o:p></o:p></span></span></p> <span></span> <h3 style="text-align: center;"><span>13.2 Операторы для работы с таблицами<o:p></o:p></span></h3> <p style="text-align: center;"><b><span>13.2.1 Оператор создания таблицы<o:p></o:p></span></b></p> <p><span>Синтаксис оператора <b><i>создания таблицы </i></b>и пример его использования представлены на рис.1.<o:p></o:p></span></p> <p><span>Обязательными операндами оператора являются имя создаваемой таб­лицы и имя хотя бы одного столбца (поля) с указанием типа данных, хранимых в этом столбце.<o:p></o:p></span></p> <p><span>При создании таблицы для отдельных полей могут указываться некоторые дополнительные правила контроля вводимых в них значений. Конструкция </span><span>NOT</span><span> </span><span>NULL</span><span> (не пустое) служит именно таким целям и для столбца таблицы означает, что в этом столбце должно быть определено значение.<o:p></o:p></span></p> <p><span>Опция </span><b><span>PRIMARY</span></b><b><span> </span></b><b><span>KEY</span></b><span> позволяет объявить поле первичным ключом.<o:p></o:p></span></p> <p><span>В общем случае в разных СУБД могут использоваться различные типы данных. В интерфейсе </span><span>ODBC</span><span> поддерживаются свои стандартные типы данных, например, символьные (</span><span>SQL</span><span>_</span><span>CHAR</span><span>, </span><span>SQL</span><span>_</span><span>VARCHAR</span><span>, </span><span>SQL</span><span>_</span><span>LONGVARCHAR</span><span>) и др. При работе с БД некоторой СУБД посредством интерфейса </span><span>ODBC</span><span> выполняется автоматическое пре­образование стандартных типов данных, поддерживаемых интерфейсом, в типы данных источников и обратно. При необходимости обмен данными между программой и источником данных может вестись без преобразования — во внутреннем формате данных источника.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>CREATE TABLE <</span><span>имя</span><span> </span><span>таблицы</span><span>></span><span><o:p></o:p></span></p> <p><span>(<</span><span>имя</span><span> </span><span>столбца</span><span>> <</span><span>тип</span><span> </span><span>данных</span><span>> [NOT NULL] [</span><span>PRIMARY KEY<span>]</span><o:p></o:p></span></p> <p><span>[,<</span><span>имя</span><span> </span><span>столбца</span><span>> <</span><span>тип</span><span> </span><span>данных</span><span>> [NOT NULL</span><span>] [</span><span> PRIMARY KEY<span>]]... )<o:p></o:p></span></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример. </span></b><span>Пусть требуется создать таблицу </span><span>goods</span><span> описания товаров, имеющую поля: </span><span>kod</span><span> — код товара (является первичным ключом), </span><span>type</span><span> — вид товара, </span><span>comp</span><span>_</span><span>id</span><span> — идентификатор компании-производителя, </span><span>name</span><span> - название товара и </span><span>price</span><span> — цена товара. Оператор определения таблицы имеет следующий вид:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>goods</span><span> (</span><span>kod</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span> </span><span>PRIMARY</span><span> </span><span>KEY</span><span>, <o:p></o:p></span></p> <p><span>type SQL_CHAR(8) NOT NULL,<o:p></o:p></span></p> <p><span>comp_id SQL_CHAR(10) NOT NULL, <o:p></o:p></span></p> <p><span>name SQL_VARCHAR(20), price SQL_DECIMAL(8,2))<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><span>Рис. 1 Синтаксис оператора <span>создания таблицы<b><i> </i></b></span>и пример его использования<o:p></o:p></span></p> <p style="text-align: center;"><b><span>13.2.2 Оператор изменения структуры таблиц<o:p></o:p></span></b></p> <p><span>Синтаксис оператора <b><i>изменения структуры</i></b> <b><i>таблицы </i></b>и пример его использования представлены на рис.2.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>ALTER</span><span> </span><span>TABLE</span><span> <имя таблицы><o:p></o:p></span></p> <p><span>( <</span><span>ADD</span><span> | </span><span>MODIFY</span><span> | </span><span>DROP</span><span>> <имя столбца> [<тип данных>] [</span><span>NOT</span><span> </span><span>NULL</span><span>]<o:p></o:p></span></p> <p><span>[,<</span><span>ADD</span><span> | </span><span>MODIFY</span><span> | </span><span>DROP</span><span>> <имя столбца> [<тип данных>] [</span><span>NOT</span><span> </span><span>NULL</span><span>]]...)<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример. </span></b><span>Добавление поля таблицы. Пусть в созданной ранее таблице </span><span>goods</span><span> необходимо добавить поле </span><span>number</span><span>, отводимое для хранения величины запаса товара. Для этого следует запи­сать оператор вида:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>goods</span><span> (</span><span>ADD</span><span> </span><span>number</span><span> </span><span>SQL</span><span>_</span><span>INTEGER</span><span>)<o:p></o:p></span></p> <p style="text-align: center;"><span>Рис. 2 Синтаксис оператора изменения структуры <span>таблицы<b><i> </i></b></span>и пример его использования<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Изменение структуры таблицы может состоять в добавлении (</span><span>ADD</span><span>), изме­нении (</span><span>MODIFY</span><span>) или удалении (</span><span>DROP</span><span>) одного или нескольких столбцов таблицы. Правила записи оператора </span><span>ALTER</span><span> </span><span>TABLE</span><span> такие же, как и оператора </span><span>CREATE</span><span> </span><span>TABLE</span><span>. При удалении столбца указывать <тип данных> не нужно.<o:p></o:p></span></p> <p style="text-align: center;"><b><span>13.2.3 Оператор удаления таблицы<o:p></o:p></span></b></p> <p><span>Синтаксис оператора <b><i>удаления таблицы </i></b>и пример его использования представлены на рис.3.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>DROP</span><span> </span><span>TABLE</span><span> <имя таблицы><o:p></o:p></span></p> <p><b><span>Пример. У</span></b><span>дале­ние таблицы с именем </span><span>items</span><span>:<o:p></o:p></span></p> <p><span>DROP</span><span> </span><span>TABLE</span><span> </span><span>items</span><span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><span>Рис. 3. Синтаксис оператора <span>удаления таблицы<b><i> </i></b></span>и пример его использования<o:p></o:p></span></p> <p style="text-align: center;"><b><span>13.2.4 Отбор данных из одной таблицы<o:p></o:p></span></b></p> <p><span>Выбрать все данные из таблицы поставщиков (ключевые слова <b><i>SELECT</i></b>… <b><i>FROM</i></b>…): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT *<o:p></o:p></span></p> <p><span><span> </span>FROM P;<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В результате получим новую таблицу, содержащую полную копию данных из исходной таблицы P. <o:p></o:p></span></p> <p><b><span> </span></b><b><span>Пример.</span></b><span> Выбрать все строки из таблицы поставщиков, удовлетворяющих некоторому условию (ключевое слово </span><b><i><span>WHERE</span></i></b><span>…): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span> *<o:p></o:p></span></p> <p><span><span> </span></span><span>FROM</span><span> </span><span>P</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>WHERE</span><span> </span><span>P</span><span>.</span><span>PNUM</span><span> > 2;<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В качестве условия в разделе WHERE можно использовать сложные логические выражения, использующие поля таблиц, константы, сравнения (>, <, = и т.д.), скобки, союзы AND и OR, отрицание NOT. <o:p></o:p></span></p> <p><b><span> </span></b><b><span>Пример.</span></b><span> Выбрать некоторые колонки из исходной таблицы (указание списка отбираемых колонок):<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT P.NAME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P;</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>В результате получим таблицу с одной колонкой, содержащую все наименования поставщиков. <o:p></o:p></span></p> <p><span>Если в исходной таблице присутствовало несколько поставщиков с разными номерами, но одинаковыми наименованиями, то в результатирующей таблице <i>будут строки с повторениями –</i> дубликаты строк автоматически не отбрасываются.<o:p></o:p></span></p> <p><span> <b>Пример.</b> Выбрать некоторые колонки из исходной таблицы, удалив из результата повторяющиеся строки (ключевое слово <b><i>DISTINCT</i></b>): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT DISTINCT P.NAME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P;</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Использование ключевого слова DISTINCT приводит к тому, что в результатирующей таблице будут удалены все повторяющиеся строки.<o:p></o:p></span></p> <p><span> <b>Пример.</b> Использование скалярных выражений и переименований колонок в запросах (ключевое слово <b><i>AS</i></b>…): <o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>TOVAR.TNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>TOVAR.KOL,</span><span><o:p></o:p></span></p> <p><span><span> </span>TOVAR.PRICE,</span><span><o:p></o:p></span></p> <p><span><span> </span>"=" AS EQU,</span><span><o:p></o:p></span></p> <p><span><span> </span>TOVAR.KOL*TOVAR.PRICE AS SUMMA</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>FROM TOVAR;<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Пример. Упорядочение результатов запроса (ключевое слово <b><i>ORDER BY</i></b>…):<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.PNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.VOLUME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM PD</span><span><o:p></o:p></span></p> <p><span><span> </span>ORDER BY DNUM;</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>В результате получим следующую таблицу, упорядоченную по полю </span><span>DNUM</span><span>.<o:p></o:p></span></p> <p><b><u><span><span> </span></span></u></b><b><span>Пример.</span></b><span> Упорядочение результатов запроса по нескольким полям с возрастанием или убыванием (ключевые слова <b><i>ASC</i></b>, <b><i>DESC</i></b>): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.PNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.VOLUME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM PD</span><span><o:p></o:p></span></p> <p><span><span> </span>ORDER BY </span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>DNUM ASC,<o:p></o:p></span></p> <p><span><span> </span>VOLUME DESC;<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В результате получим таблицу, в которой строки идут в порядке возрастания значения поля DNUM, а строки, с одинаковым значением DNUM идут в порядке убывания значения поля VOLUME. <o:p></o:p></span></p> <p><span>Если явно не указаны ключевые слова ASC или DESC, то по умолчанию принимается упорядочение по возрастанию (ASC). <o:p></o:p></span></p> <p style="text-align: center;"><b><span>13.2.5 Отбор данных из нескольких таблиц<o:p></o:p></span></b></p> <p><b><span>Пример.</span></b><span> Естественное соединение таблиц (способ 1 - явное указание условий соединения): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.VOLUME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P, PD</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE P.PNUM = PD.PNUM;</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Соединяемые таблицы перечислены в разделе FROM оператора, условие соединения приведено в разделе WHERE. Раздел WHERE, помимо условия соединения таблиц, может также содержать и условия отбора строк. <o:p></o:p></span></p> <p><span>Пример. Естественное соединение таблиц (способ 2 - ключевые слова <b><i>JOIN… </i></b></span><b><i><span>USING…</span></i></b><span>):</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.VOLUME</span><span><o:p></o:p></span></p> <p><span>FROM P JOIN PD USING PNUM;</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Ключевое слово USING позволяет <i>явно указать</i>, по каким из <i>общих </i>колонок таблиц будет производиться соединение. <o:p></o:p></span></p> <p><b><span> Пример.</span></b><span> Естественное соединение таблиц (способ 3 – ключевое слово <b><i>NATURAL JOIN</i></b>): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.VOLUME</span><span><o:p></o:p></span></p> <p><span>FROM P NATURAL JOIN PD;</span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В разделе FROM не указано, по каким полям производится соединение. NATURAL JOIN автоматически соединяет <i>по всем одинаковым полям </i>в таблицах.<o:p></o:p></span></p> <p><b><span>Пример.</span></b><span> Естественное соединение трех таблиц:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>D.DNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.VOLUME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM</span><span><o:p></o:p></span></p> <p><span><span> </span>P NATURAL JOIN PD NATURAL JOIN D;</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><b><span>Пример.</span></b><span> Прямое произведение таблиц: <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>P</span><span>.</span><span>PNUM</span><span>,<o:p></o:p></span></p> <p><span><span> </span></span><span>P.PNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>D.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>D.DNAME</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>FROM P, D;<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Т.к. не указано условие соединения таблиц, то <i>каждая </i>строка первой таблицы соединится с <i>каждой </i>строкой второй таблицы. <o:p></o:p></span></p> <p><span> <b>Пример.</b> Соединение таблиц по произвольному условию:<o:p></o:p></span></p> <p><span><span> </span><o:p></o:p></span></p> <p><span>SELECT</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>P.PSTATUS,</span><span><o:p></o:p></span></p> <p><span><span> </span>D.DNUM,</span><span><o:p></o:p></span></p> <p><span><span> </span>D.DNAME,</span><span><o:p></o:p></span></p> <p><span><span> </span>D.DSTATUS</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P, D</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE P.PSTATUS >= D.DSTATUS;</span><span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><b><span>13.3 Операторы создания и удаления индекса <o:p></o:p></span></b></p> <p><span>Синтаксис операторов <b><i>создания индекса и удаления индекса </i></b>с примерами их использования представлены ниже. Создание индекса:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>CREATE</span><span> <span> </span>[</span><span>UNIQUE</span><span>] </span><span>INDEX</span><span> <имя индекса> <o:p></o:p></span></p> <p><span>ON</span><span> <имя таблицы> <o:p></o:p></span></p> <p><span>( <имя столбца> [ </span><u><span>AS</span></u><u><span>С</span></u><span> | </span><span>DESC</span><span> ] <o:p></o:p></span></p> <p><span>[,<имя столбца> [ </span><span>ASC</span><span> | </span><span>DESC</span><span> ]...)<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример. </span></b><span>Пусть для таблицы ЕМР, имеющей поля: </span><span>NAME</span><span> (имя), </span><span>SAL</span><span> (зарплата), </span><span>MGR</span><span> (руководитель) и </span><span>DEPT</span><span> (отдел), нужно создать индекс </span><span>main</span><span>__</span><span>indx</span><span> для сортировки имен в алфавитном порядке и убыванию размеров зарплаты. Оператор</span><span> </span><span>создания</span><span> </span><span>индекса</span><span> </span><span>имеет</span><span> </span><span>вид</span><span>:</span><span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>CREATE INDEX main_indx ON emp (name, sal DESC)<o:p></o:p></span></p> <p><span>Удаление индекса</span><span>:<o:p></o:p></span></p> <p><span>DROP</span><span> </span><span>INDEX</span><span> <имя индекса><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример.</span></b><span> Уничтожение индекса </span><span>main</span><span>_</span><span>indx</span><span> к таблице </span><span>emp</span><span> реализует оператор <span> </span></span><span>DROP</span><span> </span><span>INDEX</span><span> </span><span>main</span><span>_</span><span>indx</span><span>.<o:p></o:p></span></p> <p><span>Оператор позволяет создать индекс для одного или нескольких столбцов заданной таблицы с целью ускорения выполнение запросных и поисковых операций с таблицей. Для одной таблицы можно создать несколько индексов.<o:p></o:p></span></p> <p><span>Задав необязательную опцию </span><span>UNIQUE</span><span>, можно обеспечить уникальность значений во всех указанных в операторе столбцах. По существу, создание индекса с указанием признака </span><span>UNIQUE</span><span> означает определение ключа в созданной ранее таблице.<o:p></o:p></span></p> <p><span>При создании индекса можно задать порядок автоматической сортировки значений в столбцах — в порядке возрастания </span><span>ASC</span><span> (по умолчанию), или в порядке убывания </span><span>DESC</span><span>. Для разных столбцов можно задавать различный порядок сортировки.<o:p></o:p></span></p> <p style="text-align: center;"><b><span>13.4 Операторы создания и удаления представления <o:p></o:p></span></b></p> <p><span>Синтаксис операторов <b><i>создания представления и удаления представления </i></b>с соответствующими примерами их использования представлены ниже. Если имена столбцов в создаваемом представлении не указываются, то будут использоваться имена столбцов из запроса, описываемого соответствующим оператором </span><span>SELECT</span><span>. Заметим, что при удалении представления таблицы, участвующие в запросе, удалению не подлежат.<o:p></o:p></span></p> <p><span>Оператор <b><i>создания представления </i></b>имеет формат вида:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>CREATE</span><span> </span><span>VIEW</span><span> <имя представления><o:p></o:p></span></p> <p><span>[(<имя столбца> [,<имя столбца> ]...)] <o:p></o:p></span></p> <p><span>AS</span><span> <оператор </span><span>SELECT</span><span>><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример. </span></b><span>Создание представления. Пусть имеется таблица </span><span>companies</span><span> описания производителей товаров с полями: </span><span>comp</span><span>__</span><span>id</span><span> (идентификатор компании), </span><span>comp</span><span>_</span><span>narne</span><span> (название организации), </span><span>comp</span><span>_</span><span>address</span><span> (адрес) и </span><span>phone</span><span> (телефон), а также таблица </span><span>goods</span><span> производимых товаров с полями: </span><span>type</span><span> (вид товара), </span><span>comp</span><span>_</span><span>id</span><span> (идентификатор компании), </span><span>name</span><span> (название товара) и </span><span>price</span><span> (цена товара). Таблицы связаны между собой по полю </span><span>comp</span><span>_</span><span>id</span><span>. Требуется создать представление герг с краткой информацией о товарах и их производителях: вид товара, название производителя и цена товара. Оператор определения представления может иметь следующий вид:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>CREATE</span><span> </span><span>VIEW</span><span><o:p></o:p></span></p> <p><span>repr</span><span> <o:p></o:p></span></p> <p><span><span> </span></span><span>AS</span><span><o:p></o:p></span></p> <p><span>SELECT<o:p></o:p></span></p> <p><span>goods.type, companies.comp_name, goods.price <o:p></o:p></span></p> <p><span>FROM<o:p></o:p></span></p> <p><span>goods, companies <o:p></o:p></span></p> <p><span>WHERE<o:p></o:p></span></p> <p><span>goods.comp_id = companies.comp_id<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Оператор <b><i>удаления представления </i></b>имеет формат вида:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>DROP</span><span> </span><span>VIEW</span><span> <имя представления><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример. </span></b><span>Удаление представления герг производится оператором вида:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>DROP</span><span> </span><span>VIEW</span><span> </span><span>repr</span><span><o:p></o:p></span></p> <p> </p> <h3 style="text-align: center;"><span>13.5 Операторы для работы с записями<o:p></o:p></span></h3> <h3 style="text-align: center;"><span>13.5.1 Оператор выборки записей <o:p></o:p></span></h3> <p><span>Оператор <b><i>выборки записей </i></b>имеет формат, представленный ниже. Это наиболее важный оператор из всех операторов </span><span>SQL</span><span>. Функциональные возможности его огромны. Рассмотрим основные из них.<o:p></o:p></span></p> <p><span>Оператор </span><span>SELECT</span><span> позволяет производить выборку и вычисления над данными из одной или нескольких таблиц. Результатом выполнения оператора является ответная таблица, которая может иметь (</span><span>ALL</span><span>), или не иметь (</span><span>DISTINCT</span><span>) повторяющиеся строки. По умолчанию в ответную таблицу включаются все строки, в том числе и повторяющиеся. В отборе данных участвуют записи одной или нескольких таблиц, перечисленных в списке операнда </span><span>FROM</span><span>.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT [<u>ALL</u> | DISTINCT] <</span><span>список</span><span> </span><span>данных</span><span>> <o:p></o:p></span></p> <p><span>FROM</span><span> <список таблиц><o:p></o:p></span></p> <p><span>[</span><span>WHERE</span><span> <условие выборки>]<o:p></o:p></span></p> <p><span>[</span><span>GROUP</span><span> </span><span>BY</span><span> <имя столбца> [,<имя столбца>]... ]<o:p></o:p></span></p> <p><span>[</span><span>HAVING</span><span> <условие поиска>]<o:p></o:p></span></p> <p><span>[</span><span>ORDER</span><span> </span><span>BY</span><span> <спецификация> [,<спецификация>] ...]<o:p></o:p></span></p> <p><span>Рис. 2.31. Синтаксис оператора <b><i>выборки записей </i></b><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Список данных может содержать имена столбцов, участвующих в запросе, а также выражения над столбцами. В простейшем случае в выражениях можно записывать имена столбцов, знаки арифметических операций (+, — ,*,/), константы и круглые скобки. Если в списке данных записано выражение, то наряду с выборкой данных выполняются вычисления, результаты которых попадают в новый (создаваемый) столбец ответной таблицы.<o:p></o:p></span></p> <p><span>При использовании в списках данных имен столбцов нескольких таблиц для указания принадлежности столбца некоторой таблице применяют конструкцию вида: <имя таблицы>.<имя столбца>.<o:p></o:p></span></p> <p><span>Операнд </span><span>WHERE</span><span> задает условия, которым должны удовлетворять записи в результирующей таблице. Выражение <условие выборки> является логическим. Его элементами могут быть имена столбцов, операции сравнения, арифметические операции, логические связки (И, ИЛИ, НЕТ), скобки, специальные функции </span><span>LIKE</span><span>, </span><span>NULL</span><span>, </span><span>IN</span><span> и т. д.<o:p></o:p></span></p> <p><span>Операнд </span><span>GROUP</span><span> </span><span>BY</span><span> позволяет выделять в результирующем множестве записей группы. <b><i>Группой </i></b>являются записи с совпадающими значениями в столбцах, перечисленных за ключевыми словами </span><span>GROUP</span><span> </span><span>BY</span><span>. Выделение групп требуется для использования в логических выражениях операндов </span><span>WHERE</span><span> и </span><span>HAVING</span><span>, а также для выполнения операций (вычислений) над группами.<o:p></o:p></span></p> <p><span>В логических и арифметических выражениях можно использовать следу­ющие групповые операции (функции): </span><span>AVG</span><span> (среднее значение в группе), МАХ (максимальное значение в группе), </span><span>MIN</span><span> (минимальное значение в груп­пе), </span><span>SUM</span><span> (сумма значений в группе), </span><span>COUNT</span><span> (число значений в группе).<o:p></o:p></span></p> <p><span>Операнд </span><span>HAVING</span><span> действует совместно с операндом </span><span>GROUP</span><span> </span><span>BY</span><span> и ис­пользуется для дополнительной селекции записей во время определе­ния групп. Правила записи <условия поиска> аналогичны правилам фор­мирования <условия выборки> операнда </span><span>WHERE</span><span>.<o:p></o:p></span></p> <p><span>Операнд </span><span>ORDER</span><span> </span><span>BY</span><span> задает порядок сортировки результирующего мно­жества. Обычно каждая <спецификация> аналогична соответствующей кон­струкции оператора </span><span>CREATE</span><span> </span><span>INDEX</span><span> и представляет собой пару вида: <имя столбца>[А</span><span>S</span><span>С </span><span>DESC</span><span> ].<o:p></o:p></span></p> <p><b><i><span>Замечание. </span></i></b><span>Оператор </span><span>SELECT</span><span> может иметь и другие более сложные синтаксические конструкции, которые мы подробно рассматривать не будем, а поясним их смысл.<o:p></o:p></span></p> <p><span>Одной из таких конструкций, например, являются так называемые <b><i>под­запросы. </i></b>Они позволяют формулировать <i>вложенные запросы, </i>когда результаты одного оператора </span><span>SELECT</span><span> используются в логическом выражении условия выборки операнда </span><span>WHERE</span><span> другого оператора </span><span>SELECT</span><span>.<o:p></o:p></span></p> <p><span>Вторым примером более сложной формы оператора </span><span>SELECT</span><span> является оператор, в котором отобранные записи в дальнейшем предполагается мо­дифицировать (конструкция </span><span>FOR</span><span> </span><span>UPDATE</span><span> </span><span>OF</span><span>). СУБД после выполнения такого оператора обычно блокирует (защищает) отобранные записи от модификации их другими пользователями.<o:p></o:p></span></p> <p><span>Еще один случай специфического использования оператора </span><span>SELECT</span><span> — выполнение объединений результирующих таблиц при выполнении нескольких операторов </span><span>SELECT</span><span> (операнд </span><span>UNION</span><span>).<o:p></o:p></span></p> <p><span>Примеры использования оператора<b><i> выборки записей</i></b><span> приведены ниже.</span><o:p></o:p></span></p> <p><b><span>Пример 1. </span></b><span>Выбор записей. Для таблицы ЕМР, имеющей поля: </span><span>NAME</span><span> (имя), </span><span>SAL</span><span> (зарплата), </span><span>MGR</span><span> (руководитель) и </span><span>DEPT</span><span> (отдел), требуется вывести имена сотрудников и размер их зарплаты, увеличенный на 100 единиц. <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>SELECT name, sal+100 FROM </span><span>е</span><span>m</span><span>р</span><span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример</span></b><b><span> 2. </span></b><span>Выбор с условием. Вывести названия таких отделов таблицы ЕМР, в которых в данный мо­мент отсутствуют руководители. <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>SELECT dept FROM emp WHERE mgr is NULL<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример </span></b><span>3. Выбор с группированием. Пусть требуется найти минимальную и максимальную зарплаты для каждого из отделов (по таблице ЕМР). <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>SELECT dept, MIN(sal), MAX(sal) FROM emp GROUP BY dept<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <h3 style="text-align: center;"><span>13.5.2 Оператор изменения записей <o:p></o:p></span></h3> <p><span>Синтаксис оператора <b><i>изменения записей </i></b>и пример его использования представлены ниже. Выполнение оператора </span><span>UPDATE</span><span> состоит в изменении значений в опре­деленных операндом </span><span>SET</span><span> столбцах таблицы для тех записей, которые удов­летворяют условию, заданному операндом </span><span>WHERE</span><span>.<o:p></o:p></span></p> <p><span>Новые значения полей в записях могут быть пустыми (</span><span>NULL</span><span>), либо вычисляться в соответствии с арифметическим выражением. Правила записи арифметических и логических выражений аналогичны соответствующим правилам оператора </span><span>SELECT</span><span>.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>UPDATE</span><span> <имя таблицы><o:p></o:p></span></p> <p><span>SET</span><span> <имя столбца><span> </span>= {<выражение>, </span><span>NULL</span><span> }<o:p></o:p></span></p> <p><span>[,</span><span>SET</span><span> <имя столбца> = {<выражение> , </span><span>NULL</span><span>}... ]<o:p></o:p></span></p> <p><span>[ </span><span>WHERE</span><span> <условие>]<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример. </span></b><span>Изменение записей. Пусть необходимо увеличить до 6500 единиц зарплату тем служащим, ко­торые получают не более 6000 (по таблице ЕМР). <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>UPDATE emp<o:p></o:p></span></p> <p><span>SET sal = 6500 <o:p></o:p></span></p> <p><span>WHERE sal <= 6000<o:p></o:p></span></p> <h3 style="text-align: center;"><span>13.5.3 Операторы вставки и удаления записей<o:p></o:p></span></h3> <p><span>Оператор <b><i>вставки новых записей </i></b>имеет форматы двух видов. Синтаксис оператора и пример его использования приведены ниже. <o:p></o:p></span></p> <p><span>В первом формате оператор </span><span>INSERT</span><span> предназначен для ввода новых записей с заданными значениями в столбцах. Порядок перечисления имен столбцов дол­жен соответствовать порядку значений, перечисленных в списке операнда </span><span>VALUES</span><span>. Если <список столбцов> опущен, то в <списке значений> должны быть перечислены все значения в порядке столбцов структуры таблицы.<o:p></o:p></span></p> <p><span>Во втором формате оператор </span><span>INSERT</span><span> предназначен для ввода в заданную таблицу новых строк, отобранных из другой таблицы с помощью предложения </span><span>SELECT</span><span>.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>INSERT</span><span> </span><span>INTO</span><span> </span><span><имя таблицы> [(<список столбцов>)]<span> </span><o:p></o:p></span></p> <p><span>VALUES</span><span> (<список значений>) <o:p></o:p></span></p> <p><span>INSERT</span><span> </span><span>INTO</span><span> <имя таблицы> [(<список столбцов>)] <o:p></o:p></span></p> <p><span><предложение </span><span>SELECT</span><span>><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример</span></b><span>. Ввод записей. Ввести в таблицу ЕМР запись о новом сотруднике. <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>INSERT INTO emp<o:p></o:p></span></p> <p><span>VALUES («Ivanov», 7500, «Lee», «cosmetics»)<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Синтаксис и пример использования оператора <b><i>удаления записей </i></b>приведены ниже. Результатом выполнения оператора </span><span>DELETE</span><span> является удаление из ука­занной таблицы строк, которые удовлетворяют условию, определенному операндом </span><span>WHERE</span><span>. Если этот операнд опущен, т.е. условие отбора удаляемых записей отсутствует, удалению подлежат все за­писи таблицы</span>.<b><i> </i></b></p> <p><b><i><span>Замечание. </span></i></b><span>По словам Дейта, язык </span><span>SQL</span><span> является гибридом реляционной алгебры и реляционного исчисления. В нем имеются элементы алгебры (оператор объединения </span><span>UNION</span><span>) и исчисления (квантор существования </span><span>EXISTS</span><span>). Кроме того, язык </span><span>SQL</span><span> обладает реляционной полнотой.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>DELETE</span><span> </span><span>FROM</span><span> <имя таблицы> <o:p></o:p></span></p> <p><span>[</span><span>WHERE</span><span> <условие>]<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример</span></b><span>. Удаление записей. В связи с ликвидацией отдела игрушек (</span><span>toy</span><span>), требуется удалить из таб­лицы ЕМР всех сотрудников этого отдела. Оператор </span><span>DELETE</span><span> для этой задачи будет выглядеть так:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>DELETE<span> </span>FROM<span> </span>emp<span> </span>WHERE dept = «toy»<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <h3 style="text-align: center;"><span>13.6 Использование подзапросов<o:p></o:p></span></h3> <p><span>Очень удобным средством, позволяющим формулировать запросы более понятным образом, является возможность использования подзапросов, вложенных в основной запрос. <o:p></o:p></span></p> <p><b><span>Пример.</span></b><span> Получить список поставщиков (таблица </span><span>P</span><span>), статус которых меньше максимального статуса в таблице поставщиков (сравнение с подзапросом): <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE P.STATYS <</span><span><o:p></o:p></span></p> <p><span><span> </span>(SELECT MAX(P.STATUS)</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P);</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Т.к. поле P.STATUS сравнивается с результатом подзапроса, то подзапрос должен быть сформулирован так, чтобы возвращать таблицу, состоящую <i>ровно из одной строки и одной колонки</i>. <o:p></o:p></span></p> <p><span>Результат выполнения запроса будет эквивалентен результату следующей последовательности действий: <o:p></o:p></span></p> <p><span>–</span><span> </span><span>Выполнить <i>один раз </i>вложенный подзапрос и получить максимальное значение статуса. <o:p></o:p></span></p> <p><span>–</span><span> </span><span>Просканировать таблицу поставщиков P, каждый раз сравнивая значение статуса поставщика с результатом подзапроса, и отобрать только те строки, в которых статус меньше максимального. <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Пример. Использование предиката <b><i>IN</i></b>. Получить список поставщиков (таблица </span><span>P</span><span>), поставляющих деталь номер 2: <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE P.PNUM IN</span><span><o:p></o:p></span></p> <p><span><span> </span>(SELECT DISTINCT PD.PNUM</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM PD</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>WHERE PD.DNUM = 2);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В данном случае вложенный подзапрос может возвращать таблицу, содержащую несколько строк. <o:p></o:p></span></p> <p><span>Результат выполнения запроса будет эквивалентен результату следующей последовательности действий: <o:p></o:p></span></p> <p><span>–</span><span> </span><span>Выполнить <i>один раз </i>вложенный подзапрос и получить список номеров поставщиков, поставляющих деталь номер 2.<o:p></o:p></span></p> <p><span>–</span><span> </span><span>Просканировать таблицу поставщиков P, каждый раз проверяя, содержится ли номер поставщика в результате подзапроса. <o:p></o:p></span></p> <p><b><span> Пример.</span></b><span> Использование предиката <b><i>EXIST</i></b>. Получить список поставщиков, поставляющих деталь номер 2: <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE EXIST</span><span><o:p></o:p></span></p> <p><span><span> </span>(SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM PD</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.PNUM = P.PNUM AND</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>PD.DNUM = 2);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Результат выполнения запроса будет эквивалентен результату следующей последовательности действий: <o:p></o:p></span></p> <p><span>–</span><span> </span><span>Просканировать таблицу поставщиков P, <i>каждый раз выполняя подзапрос </i>с новым значением номера поставщика, взятым из таблицы P. <o:p></o:p></span></p> <p><span>–</span><span> </span><span>В результат запроса включить только те строки из таблицы поставщиков, для которых вложенный подзапрос вернул непустое множество строк. <o:p></o:p></span></p> <p><span>В отличие от двух предыдущих примеров, вложенный подзапрос содержит параметр (внешнюю ссылку), передаваемый из основного запроса - номер поставщика P.PNUM. Такие подзапросы называются <b><i>коррелируемыми </i></b>(<b><i>correlated</i></b>). Внешняя ссылка может принимать различные значения для каждой строки-кандидата, оцениваемого с помощью подзапроса, поэтому подзапрос должен выполняться заново для каждой строки, отбираемой в основном запросе. Такие подзапросы характерны для предиката EXIST, но могут быть использованы и в других подзапросах. <o:p></o:p></span></p> <p><span>Может показаться, что запросы, содержащие коррелируемые подзапросы будут выполняться медленнее, чем запросы с некоррелируемыми подзапросами. На самом деле это не так, т.к. то, как пользователь, сформулировал запрос, <i>не определяет</i>, как этот запрос будет выполняться. Язык SQL является непроцедурным, а декларативным. Это значит, что пользователь, формулирующий запрос, просто описывает, <i>каким должен быть результат запроса</i>, а как этот результат будет получен - за это отвечает сама СУБД.<o:p></o:p></span></p> <p><b><span> Пример.</span></b><span> Использование предиката <b><i>NOT EXIST</i></b>. Получить список поставщиков, не поставляющих деталь номер 2: <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE NOT EXIST</span><span><o:p></o:p></span></p> <p><span><span> </span>(SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM PD</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.PNUM = P.PNUM AND</span><span><o:p></o:p></span></p> <p><span><span> </span></span><span>PD.DNUM = 2);<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><i><span>Замечание.</span></i></b><span> Также как и в предыдущем примере, здесь используется коррелируемый подзапрос. Отличие в том, что в основном запросе будут отобраны те строки из таблицы поставщиков, для которых вложенный подзапрос не выдаст ни одной строки. <o:p></o:p></span></p> <p><b><span> </span></b><b><span>Пример.</span></b><span> Получить имена поставщиков, поставляющих все детали:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SELECT DISTINCT PNAME</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM P</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE NOT EXIST</span><span><o:p></o:p></span></p> <p><span><span> </span>(SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM D</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE NOT EXIST</span><span><o:p></o:p></span></p> <p><span><span> </span>(SELECT *</span><span><o:p></o:p></span></p> <p><span><span> </span>FROM PD</span><span><o:p></o:p></span></p> <p><span><span> </span>WHERE</span><span><o:p></o:p></span></p> <p><span><span> </span>PD.DNUM = D.DNUM AND</span><span><o:p></o:p></span></p> <p><span><span> </span>PD</span><span>.</span><span>PNUM</span><span> = </span><span>P</span><span>.</span><span>PNUM</span><span>));<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Данный запрос содержит два вложенных подзапроса и реализует реляционную операцию <i>деления отношений</i>. <o:p></o:p></span></p> <p><span>Самый внутренний подзапрос параметризован двумя параметрами (D.DNUM, P.PNUM) и имеет следующий смысл: отобрать все строки, содержащие данные о поставках поставщика с номером PNUM детали с номером DNUM. Отрицание NOT EXIST говорит о том, что данный поставщик не поставляет данную деталь. Внешний к нему подзапрос, сам являющийся вложенным и параметризованным параметром P.PNUM, имеет смысл: отобрать список деталей, которые не поставляются поставщиком PNUM. Отрицание NOT EXIST говорит о том, что для поставщика с номером PNUM не должно быть деталей, которые не поставлялись бы этим поставщиком. Это в точности означает, что во внешнем запросе отбираются только поставщики, поставляющие все детали.<o:p></o:p></span></p> <h3 style="text-align: center;"><span>13.7 Некоторые важные функции SQL<o:p></o:p></span></h3> <p><span> Еще раз напомним, что хотя язык <b>SQL</b> и является стандартным языком для работы с широким кругом БД, он все же несколько отличается при переходе от одной системы к другой. Приводимые ниже примеры в основном рассчитаны на </span><span>MS</span><span> </span><span>SQL</span><span> </span><span>Server</span><span>. Язык SQL системы SQL Server содержит некоторое расширение, которое известно как </span><span>T</span><span>(t</span><span>ransact</span><span>)-</span><span>SQL</span><span>.<o:p></o:p></span></p> <p><span>В табл. 1 рассмотрены некоторые важные функции T-SQL, достаточно часто используемые в запросах.<o:p></o:p></span></p> <p style="text-align: right;"><span>Таблица 1<o:p></o:p></span></p> <p style="text-align: center;"><span>Некоторые важные функции T-SQL<o:p></o:p></span></p> <table border="1" cellspacing="0" cellpadding="0" style="margin:0 auto;"> <tr> <td width="666" valign="top"> <p><b><span>ABS</span></b><span>(…) возвращает модуль величины, указываемой в скобках<o:p></o:p></span></p> </td> </tr> <tr> <td width="666"> <p><b><span>CHAR</span></b><span>(…)<span> </span>преобразует целое число в строку символов<o:p></o:p></span></p> </td> </tr> <tr> <td width="666"> <p><b><span>GetDate</span></b><span>()<span> </span>возвращает текущую системную дату<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>IsdATE</span></b><span>(выражение) возвращает истину, если выражение соответствует корректной дате<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>isNULL</span></b><span>(выражение, константа) заменяет значение NULL заданной константой<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>isNumeri</span></b><b><span>c</span></b><span>(выражение) возвращает истину, если выражение является числом<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>Len</span></b><span>(символьнаястрока) возвращает длину строки<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>Lower</span></b><span>(строка) преобразует символы строки в нижний регистр<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>LTrim</span></b><span>(строка) удаляет ведущие пробелы<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>STR</span></b><span>(число) преоразует число в строку<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>SubString</span></b><span>(строка, начало, длина) выделяет подстроку из строки, начиная с заданного символа начала и включая указанное число символов<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>Upper</span></b><span>(выражение) преобразует символы выражения в верхний регистр<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>Year</span></b><span>(дата) возвращает год из даты в виде целого числа из четырех цифр<o:p></o:p></span></p> </td> </tr> <tr> <td width="666" valign="top"> <p><b><span>Month</span></b><span>(дата)<span> </span>возвращает месяц в виде целого числа<o:p></o:p></span></p> </td> </tr> </table> <p> </p> <p> <span>Следующая группа функций рассмотрена подробнее ниже. При проверке алгебраических соотношений между числовыми величинами используют следующие операции:<o:p></o:p></span></p> <p><span>=<span> </span>равно<o:p></o:p></span></p> <p><span>!= , <> не равно<o:p></o:p></span></p> <p><span>> больше<o:p></o:p></span></p> <p><span>>= больше или равно<o:p></o:p></span></p> <p><span>!><span> </span>не больше<o:p></o:p></span></p> <p><span>< меньше<o:p></o:p></span></p> <p><span><= меньше или равно<o:p></o:p></span></p> <p><span>!< не меньше<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><b><span>IF</span></b><b><span> </span></b><b><span>EXISTS</span></b><span> …<span> </span>проверяет наличие хотя бы одной выбранной записи по запросу.<o:p></o:p></span></p> <p><b><span>IF EXISTS</span></b><span> (Select * From </span><span>Склад</span><span> Where </span><span>Цена</span><span>>8000)<o:p></o:p></span></p> <p><span>Select<span> </span>”Имеются товары с высокой ценой” From Склад<o:p></o:p></span></p> <p><b><span><span> </span>Else</span></b><span><o:p></o:p></span></p> <p><span>Select</span><span> “Нет дорогих товаров” <o:p></o:p></span></p> <p><span>Можно выбрать указанное число записей из набора:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>SELECT TOP</span></b><span> 2 * </span><b><span>FROM</span></b><span> Склад<o:p></o:p></span></p> <p><span>Эта команда выбирает ровно две первых записи из таблицы Склад. <o:p></o:p></span></p> <p><span>Можно произвести отбор первых 10% записей так<o:p></o:p></span></p> <p><b><span>SELECT</span></b><b><span> </span></b><b><span>TOP</span></b><span> 10 </span><span>PERCENT</span><span> * </span><b><span>FROM</span></b><span> Склад<o:p></o:p></span></p> <p><span>Для выборки неповторяющихся записей следует указать:<o:p></o:p></span></p> <p><b><span>SELECT </span></b><span>* <b>FROM</b> </span><span>Склад</span><span> <b><span>DISTINCT</span></b><span><o:p></o:p></span></span></p> <p><span>(dictinct – </span><span>различные</span><span>).<o:p></o:p></span></p> <p><span>Для выборки строк по шаблону применяется функция LIKE. <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Пример.<o:p></o:p></span></b></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>SELECT</span></b><span> </span><span>Название </span><b><span>FROM</span></b><span> </span><span>Склад </span><b><span>WHERE</span></b><span> </span><span>Название </span><b><span>LIKE</span></b><span> “б%”<o:p></o:p></span></p> <p><span>Для проверки попадания значения в диапазон используется конструкция <b>SELECT </b>с <b>IN</b>:<o:p></o:p></span></p> <p><b><span>SELECT </span></b><span><span> </span></span><span>Название</span><span> <b><span>FROM</span></b><span> </span></span><span>Склад</span><span> <b><span>WHERE</span></b><span> </span></span><span>Цена</span><span> <b><span>IN</span></b><span> (<b>SELECT MAX</b>(</span></span><span>Цена</span><span>) <b>FROM</b> </span><span>Склад</span><span>)<o:p></o:p></span></p> <p><span>Этот запрос выдает названия всех товаров, цена на которые попадает в запрос<o:p></o:p></span></p> <p><b><span>SELECT</span></b><b><span> </span></b><b><span>MAX</span></b><span>(Цена) </span><b><span>FROM</span></b><span> </span><span>Склад, т.е. является максимальной ценой.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Можно указать варианты значений явным способом:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>SELECT </span></b><span><span> </span></span><span>Название</span><span> <b><span>FROM</span></b><span> </span></span><span>Склад</span><span> <b><span>WHERE</span></b><span> </span></span><span>Цена</span><span> <b><span>IN</span></b><span> (1000,1800,2000,3000)<o:p></o:p></span></span></p> <p><span> <o:p></o:p></span></p> <p><span>Можно</span><span> </span><span>задать</span><span> </span><span>диапазон</span><span> </span><span>значений</span><span>:<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>SELECT</span></b><span> </span><span>Название</span><span> <b><span>FROM</span></b><span> </span></span><span>Склад</span><span> <b><span>WHERE</span></b><span> </span></span><span>Цена</span><span> <b><span>BETWEEN</span></b><span> 1000 <b>AND</b> 5000.<o:p></o:p></span></span></p> <p><span>Здесь использовано ключевое слово </span><b><span>BETWEEN</span></b><span> (- между).<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><o:p> </o:p></p> </div>
 <A HREF="../theory.htm">Оглавление</A>                
<p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>