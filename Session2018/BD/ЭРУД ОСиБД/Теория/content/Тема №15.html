<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Теория по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" >Программа</A> | 
                                                    <strong>Теория</strong>|
                                                  <A HREF="../../Практика/practice.htm">Практика</A>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>

<table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
                <p>&nbsp;</p>
 <A HREF="../theory.htm">Оглавление</A>
                 <div> <p style="text-align: center;"><b><span>Тема 15</span></b><b><span>. </span></b><b><span>Системы управления базами данных Microsoft SQL Server, MySQL, Oracle Database</span></b></p> <p style="text-align: center;"><a></a><a></a><a></a><b><span>15.1. Доступ к базе данных на стороне сервера</span></b></p> <p><span>Механизм реализуется за счет наличия двух более или менее стандартизованных средств: возможности включения форм в документ, составленный с использованием языка гипермедийной разметки HTML, и возможности использования внешних по отношению к серверу Web программ, взаимодействие которых происходит через специфицированный протокол CGI (Common Gateway Interface) или внедренный позже API (Application Program Interface). (Хотя CGI называется "общим интерфейсом шлюзования", по сути дела, это одновременно некоторое подмножество протокола HTTP, и способ его соблюдения при взаимодействии сервера с внешней программой.)</span></p> <p><span>При реализации на основе CGI общая схема реализации доступа к базе данных на стороне Web-сервера выглядит следующим образом: при просмотре документа клиент встречает ссылку на страницу, содержащую одну или несколько форм, предназначенных для запроса данных из базы данных; клиент запрашивает эту страницу; помимо незаполненных форм страница может содержать общую информацию о базе данных и о назначении предлагаемых форм; если клиента действительно интересует информация из базы данных, которую можно получить на основе предложенных форм, то он заполняет одну из форм и отправляет заполненную форму на сервер; получив заполненную форму, сервер запускает соответствующую внешнюю программу, передавая ей параметры и получая результаты на основе протокола CGI; внешняя программа преобразует запрос, выраженный с помощью заполненной формы, в запрос на языке, понятном серверу баз данных (обычно это язык SQL). Замечание: говоря формально, внешняя программа осуществляет компиляцию языка форм в базовый язык сервера баз данных; это может быть очень простая компиляция с использованием заготовок SQL-операторов, но тем не менее компиляция.</span></p> <p><span>Внешняя программа взаимодействует с сервером баз данных; взаимодействие может быть прямым, если внешняя программа жестко привязана к конкретному SQL-серверу, или с использованием, например, протокола и соответствующего драйвера ODBC, если жесткая привязка отсутствует; после получения результатов запроса внешняя программа формирует соответствующую виртуальную или реальную HTML-страницу, передает ее серверу и завершает свое выполнение; сервер передает сформированную HTML-страницу клиенту, и на этом процедура доступа к базе данных завершается (как обычно, сервер разрывает транспортное соединение с клиентом).</span></p> <p><span>Внешняя программа, запускаемая Web-серверомв соответствии со спецификациями CGI, называется CGI-скриптом. CGI-скриптможет быть написан на языке программирования (Си, Си++, Паскаль и т. д.) или на командном языке (языки семейства shell, perl и т. д.). CGI-скрипт, выполняющий роль посредника между Web-сервером и другими видами серверов (например сервером баз данных), называется шлюзом (видимо, более правильно было бы использовать термин CGI-шлюз).</span></p> <p><span>Наличие CGI-скриптов на стороне Web-сервера позволяет, в частности, перенести часть логики приложения из клиента в сервер. CGI-шлюзы представляют собой средство для организации трехзвенной (в общем случае, многозвенной) архитектуры клиент-сервер.</span></p> <p><span>В спецификациях CGI предусмотрены четыре способа взаимодействия Web-сервераи CGI-скрипта (по крайней мере в среде ОС Unix). Первый способ состоит в использовании создаваемых сервером переменных окружения, через которые передается как общая информация, независящая от функциональных особенностей CGI-скрипта (например имя и версия Web-сервера), так и специфические данные, определяющие поведение CGI-скрипта (скажем набор значений, введенных в форму на стороне клиента). Второй способ заключается в формировании параметров argc и argv, которые передаются функции main CGI-скрипта (как если бы CGI-скриптвызывался командной строкой в интерактивном режиме).</span></p> <p><span>Этот способ применяется для реализации ограниченного класса запросов ISINDEX. Наконец, входные параметры могут передаваться CGI-скрипту через файл стандартного ввода, а CGI-скрипт может передавать Web-серверу результирующие данные через файл стандартного вывода. Как видно, при использовании CGI вся интерпретация пользовательского запроса производится CGI-скриптом. Скрипт может быть предельно жестким, ориентированным на выполнение запроса к фиксированной таблице фиксированной базы данных, или относительно гибким, способным выполнить произвольный запрос к одной или нескольким таблицам базы данных, идентифицируемой в параметрах клиента.</span></p> <p><span>Загрузка и выполнение еще одной программы в уже существующем адресном пространстве по сравнению с предыдущем вариантом гораздо дешевле. Нет никаких новых идей. API - это, фактически, дешевый способ выполнить в адресном пространстве сервера WWW программу, которая соответствует спецификациям на языке HTML. Такая программа должна быть заранее подготовлена и включена в библиотеку, из которой сервер может производить динамическую загрузку (например, такая библиотека может быть разделяемой - shared library). Т. е. смысл не меняется, меняется только реализация.</span></p> <p style="text-align: center;"><a><b><span>15.2. Доступ к базе данных на стороне клиента</span></b></a></p> <p><span> Видимо, наиболее мощные средства обеспечения доступа к базам данных на стороне Web-клиента обеспечивает язык Java. Java - это объектно-ориентированный язык программирования, являющийся, по сути дела, "безопасным" подмножеством языка Си++. В частности, Java не содержит средств адресной арифметики, не поддерживает механизм множественного наследования и т. д. Поэтому утверждается, что корректность Java-программы можно проверить до ее реального выполнения (это абсолютно недоказанное утверждение). Различают: язык Java, как таковой, для которого существуют компиляторы в так называемый "мобильный код" (машинно-независимый код, который может интерпретироваться или из которого могут генерироваться машинные коды на разных платформах); язык JavaScript, который обычно используется для расширения возможностей языка HTML за счет добавления процедурной составляющей; и программный продукт HotJava, являющийся, по сути, интерпретатором мобильных кодов Java. Для обеспечения доступа к базам данных на стороне Web-клиента наиболее существенно наличие языка Java. </span></p> <p><span>Технология разработки HTML-документа позволяет написать произвольное количество дополнительных Java-программ, откомпилировать их в мобильные коды и поставить ссылки на соответствующие коды в теле HTML-документа. Такие дополнительные Java-программы называются апплетами (Java-applets).</span></p> <p><span>Получив доступ к документу, содержащему ссылки на апплеты, клиентская программа просмотра запрашивает у Web-сервера все мобильные коды. Коды могут начать выполняться сразу после размещения в компьютере клиента или быть активизированы с помощью специальных команд. Поскольку апплет представляет собой произвольную Java-программу, то, в частности, он может быть специализирован для работы с внешними базами данных.</span></p> <p><span>Более того, система программирования Java включает развитый набор классов, предназначенных для поддержки графического пользовательского интерфейса. Опираясь на использование этих классов, апплет может получить от пользователя информацию, характеризующую его запрос к базе данных, в том же виде, как если бы использовался стандартный механизм форм языка HTML, а может применять какой-либо другой интерфейс.</span></p> <p><span>Для взаимодействия Java-апплета с внешним сервером баз данных разработан специализированный протокол JDBC, который, фактически, сочетает функции шлюзования между интерпретатором мобильных Java-кодов и ODBC, а также включает ODBC.</span></p> <p><span>В заключение сравним достоинства и недостатки двух рассмотренных подходов.</span></p> <p><span>Использование CGI-скриптов на стороне Web-сервера позволяет иметь на стороне клиента только сравнительно простые программы просмотра. Вся хитроумная логика работы с базами данных (возможно, с обработкой полученных данных)переходит на сторону Web-сервера.</span></p> <p><span>Это легкий способ построения трехзвенной архитектуры приложения. (В последнее время разгрузку клиента от логики приложения называют решением проблемы "толстого" клиента. В данном случае мы можем иметь предельно тонкого клиента при утолщении сервера.) Отрицательным моментом является то, что при необходимости подключения нового CGI-скрипта, вообще говоря, требуется (относительная) модификация кода сервера.</span></p> <p><span>Использование Java-апплетов, вообще говоря, обеспечивает более гибкое решение. Апплет - это часть HTML-документа. Для включения нового апплета нужно всего-навсего перекомпоновать документ. Web-cервер трогать не нужно. С другой стороны, клиент должен быть толще. Что бы там не говорили, клиент должен быть достаточно "толстым", чтобы в приемлемое время справиться с интерпретацией всех апплетов. Но, конечно же, сервер по-прежнему должен быть "толще" клиента.</span></p> <p><span>На самом деле и при применении первого подхода, и при использовании второго остается нерешенной одна организационно-производственная проблема: кто должен проектировать, писать, отлаживать и сопровождать процедурный код? Web-мастера, производящие HTML-документы, обычно считают себя, скорее, дизайнерами нежели программистами. А здесь требуется чисто программистская работа.</span></p> <p style="text-align: center;"><b><span>15.3 Архитектура информационной системы типа клиент-сервер. Модели архитектуры клиент-сервер</span></b></p> <p><span>Применительно к системам баз данных архитектура "клиент-сервер" интересна и актуальна главным образом потому, что обеспечивает простое и относительно дешевое решение проблемы коллективного доступа к базам данных в локальной сети. В некотором роде системы баз данных, основанные на архитектуре "клиент-сервер", являются приближением к распределенным системам баз данных, конечно, существенно упрощенным приближением, но зато не требующим решения основного набора проблем действительно распределенных баз данных. </span></p> <p><span>В основе широкого распространения локальных сетей компьютеров лежит известная идея разделения ресурсов. Высокая пропускная способность локальных сетей обеспечивает эффективный доступ из одного узла локальной сети к ресурсам, находящимся в других узлах. </span></p> <p><span>Развитие этой идеи приводит к функциональному выделению компонентов сети: разумно иметь не только доступ к ресурсами удаленного компьютера, но также получать от этого компьютера некоторый сервис, который специфичен для ресурсов данного рода и программные средства для обеспечения которого нецелесообразно дублировать в нескольких узлах. Так мы приходим к различению рабочих станций и серверов локальной сети. </span></p> <p><span>Рабочая станция предназначена для непосредственной работы пользователя или категории пользователей и обладает ресурсами, соответствующими локальным потребностям данного пользователя. Специфическими особенностями рабочей станции могут быть объем оперативной памяти (далеко не все категории пользователей нуждаются в наличии большой оперативной памяти), наличие и объем дисковой памяти (достаточно популярны бездисковые рабочие станции, использующие внешнюю память дискового сервера), характеристики процессора и монитора (некоторым пользователям нужен мощный процессор, других в большей степени интересует разрешающая способность монитора, для третьих обязательно требуются средства убыстрения графики и т.д.). При необходимости можно использовать ресурсы и/или услуги, предоставляемые сервером. </span></p> <p><span>Сервер локальной сети должен обладать ресурсами, соответствующими его функциональному назначению и потребностям сети. Заметим, что в связи с ориентацией на подход открытых систем, правильнее говорить о логических серверах (имея в виду набор ресурсов и программных средств, обеспечивающих услуги над этими ресурсами), которые располагаются не обязательно на разных компьютерах. Особенностью логического сервера в открытой системе является то, что если по соображениям эффективности сервер целесообразно переместить на отдельный компьютер, то это можно проделать без потребности в какой-либо переделке как его самого, так и использующих его прикладных программ. </span></p> <p><span>Примерами сервером могут служить:</span></p> <p><span>–</span><span> </span><span>сервер телекоммуникаций, обеспечивающий услуги по связи данной локальной сети с внешним миром;</span></p> <p><span>–</span><span> </span><span>вычислительный сервер, дающий возможность производить вычисления, которые невозможно выполнить на рабочих станциях;</span></p> <p><span>–</span><span> </span><span>дисковый сервер, обладающий расширенными ресурсами внешней памяти и предоставляющий их в использование рабочим станциями и, возможно, другим серверам;</span></p> <p><span>–</span><span> </span><span>файловый сервер, поддерживающий общее хранилище файлов для всех рабочих станций;</span></p> <p><span>–</span><span> </span><span>сервер баз данных фактически обычная СУБД, принимающая запросы по локальной сети и возвращающая результаты.</span></p> <p><span>Сервер локальной сети предоставляет ресурсы (услуги) рабочим станциям и/или другим серверам. </span></p> <p><span>Принято называть клиентом локальной сети, запрашивающий услуги у некоторого сервера и сервером - компонент локальной сети, оказывающий услуги некоторым клиентам.</span></p> <p style="text-align: center;"><b><span> 15.3.1 Системная архитектура "клиент-сервер"</span></b></p> <p><span>В </span><span>общем случае, чтобы прикладная программа, выполняющаяся на рабочей станции, могла запросить услугу у некоторого сервера, как минимум требуется некоторый интерфейсный программный слой, поддерживающий такого рода взаимодействие (было бы по меньшей мере неестественно требовать, чтобы прикладная программа напрямую пользовалась примитивами транспортного уровня локальной сети). Из этого, собственно, и вытекают основные принципы системной архитектуры "клиент-сервер". </span></p> <p><span>Система разбивается на две части, которые могут выполняться в разных узлах сети, - клиентскую и серверную части. Прикладная программа или конечный пользователь взаимодействуют с клиентской частью системы, которая в простейшем случае обеспечивает просто надсетевой интерфейс. Клиентская часть системы при потребности обращается по сети к серверной части. Заметим, что в развитых системах сетевое обращение к серверной части может и не понадобиться, если система может предугадывать потребности пользователя, и в клиентской части содержатся данные, способные удовлетворить его следующий запрос. </span></p> <p><span>Интерфейс серверной части определен и фиксирован. Поэтому возможно создание новых клиентских частей существующей системы (пример интероперабельности на системном уровне). </span></p> <p><span>Основной проблемой систем, основанных на архитектуре "клиент-сервер", является то, что в соответствии с концепцией открытых систем от них требуется мобильность в как можно более широком классе аппаратно-программных решений открытых систем. Даже если ограничиться UNIX-ориентированными локальными сетями, в разных сетях применяется разная аппаратура и протоколы связи. Попытки создания систем, поддерживающих все возможные протоколы, приводит к их перегрузке сетевыми деталями в ущерб функциональности. </span></p> <p><span>Еще более сложный аспект этой проблемы связан с возможностью использования разных представлений данных в разных узлах неоднородной локальной сети. В разных компьютерах может существовать различная адресация, представление чисел, кодировка символов и т.д. Это особенно существенно для серверов высокого уровня: телекоммуникационных, вычислительных, баз данных.</span></p> <p><span>Общим решением проблемы мобильности систем, основанных на архитектуре "клиент-сервер" является опора на программные пакеты, реализующие протоколы удаленного вызова процедур (RPC - Remote Procedure Call). При использовании таких средств обращение к сервису в удаленном узле выглядит как обычный вызов процедуры. Средства RPC, в которых, естественно, содержится вся информация о специфике аппаратуры локальной сети и сетевых протоколов, переводит вызов в последовательность сетевых взаимодействий. Тем самым, специфика сетевой среды и протоколов скрыта от прикладного программиста. </span></p> <p><span>При вызове удаленной процедуры программы RPC производят преобразование форматов данных клиента в промежуточные машинно-независимые форматы и затем преобразование в форматы данных сервера. При передаче ответных параметров производятся аналогичные преобразования. </span></p> <p><span>Если система реализована на основе стандартного пакета RPC, она может быть легко перенесена в любую открытую среду.</span></p> <p style="text-align: center;"><b><span>15.3.2 Модели архитектуры клиент-сервер</span></b></p> <p><span>Архитектура клиент-сервер - архитектура распределенной вычислительной системы, в которой приложение делится на клиентский и серверный процессы. </span></p> <p><span>В зависимости от того, как распределены логические компоненты приложения между клиентами и серверами, различаютчетыре модели архитектуры клиент-сервер: </span></p> <p><span>- модель «файл-сервер» (File Server - FS);</span></p> <p><span>- модель «сервер базы данных» (DataBase Server - DBS);</span></p> <p><span>- модель доступа к удаленным данным (Remote Data Access - RDA);</span></p> <p><span>- модель «сервер приложений» (Application Server - AS).</span></p> <p><span>FS-модель является базовой для локальных сетей персональных компьютеров. В соответствии с этой моделью один из компьютеров в сети считается файловым сервером и предоставляет услуги по обработке файлов другим компьютерам.</span></p> <p><span>Файловый сервер работает под управлением сетевой операционной системы (например, Novell NetWare) и играет роль компонента доступа к информационным ресурсам (то есть к файлам). На других компьютерах в сети функционирует приложение, в кодах которого совмещены компонент представления и прикладной компонент. Протокол обмена представляет собой набор низкоуровневых вызовов, обеспечивающих приложению доступ к файловой системе на файл-сервере.</span></p> 
<p><span><img src="Тема%20№15.files/image001.png" v:shapes="_x0000_i1026"> </span></p>
<p style="text-align: center;">
<span>Рис.1. Модель файлового сервера</span></p> <p><span> </span></p> 
<p><span>FS-модель послужила фундаментом для расширения возможностей персональных СУБД в направлении поддержки многопользовательского режима. В таких системах на нескольких персональных компьютерах выполняется как прикладная программа, так и копия СУБД, а базы данных содержатся в разделяемых файлах, которые находятся на файловом сервере. Когда прикладная программа обращается к базе данных, СУБД направляет запрос на файловый сервер. В этом запросе указаны файлы, где находятся запрашиваемые данные. В ответ на запрос файловый сервер направляет по сети требуемый блок данных. СУБД, получив его, выполняет над данными действия, которые были декларированы в прикладной программе.</span></p><p><span>К технологическим недостаткам модели относят высокий сетевой трафик (передача множества файлов, необходимых приложению), узкий спектр операций манипулирования данными ("данные - это файлы"), отсутствие адекватных средств безопасности доступа к данным (защита только на уровне файловой системы) и т.д. Все перечисленные недостатки - следствие внутренне присущих FS-модели ограничений, определяемых ее характером.</span></p><p><span>Более технологичная RDA-модель существенно отличается от FS-модели характером компонента доступа к информационным ресурсам. Это, как правило, SQL-сервер. В RDA-модели коды компонента представления и прикладного компонента совмещены и выполняются на компьютере-клиенте. Последний поддерживает как функции ввода и отображения данных, так и чисто прикладные функции. Доступ к информационным ресурсам обеспечивается либо операторами специального языка (языка SQL, если речь идет о базах данных) или вызовами функций специальной библиотеки (если имеется соответствующий интерфейс прикладного программирования - API).</span></p>
<p><span><img src="Тема%20№15.files/image003.gif" v:shapes="_x0000_i1026"> </span></p>
<p><span> Рис 2. Модель доступа к удаленным данным</span></p><p><span> </span></p><p><span>Клиент направляет запросы к информационным ресурсам (например, к базам данных) по сети удаленному компьютеру. На нем функционирует ядро СУБД, которое обрабатывает запросы, выполняя предписанные в них действия и возвращает клиенту результат, оформленный как блок данных. При этом инициатором манипуляций с данными выступают программы, выполняющиеся на компьютерах-клиентах, в то время как ядру СУБД отводится пассивная роль - обслуживание запросов и обработка данных.</span></p><p><span>RDA-модель избавляет от недостатков, присущих как системам с централизованной архитектурой, так и системам с файловым сервером.</span></p><p><span>Прежде всего, перенос компонента представления и прикладного компонента на компьютеры-клиенты существенно разгружает сервер БД, минимизируя общее число процессов операционной системы. Сервер БД освобождается от несвойственных ему функций; процессор или процессоры сервера целиком загружаются операциями обработки данных, запросов и транзакций. Это становится возможным благодаря отказу от терминалов и оснащению рабочих мест компьютерами, которые обладают собственными локальными вычислительными ресурсами, полностью используемыми программами переднего плана. С другой стороны, резко уменьшается загрузка сети, так как по ней передаются от клиента к серверу не запросы на ввод-вывод (как в системах с файловым сервером), а запросы на языке SQL, а их объем существенно меньше.</span></p><p><span>Основное достоинство RDA-модели заключается в унификации интерфейса "клиент-сервер" в виде языка SQL. Действительно, взаимодействие прикладного компонента с ядром СУБД невозможно без стандартизованного средства общения. Запросы, направляемые программой ядру, должны быть понятны обеим сторонам. Для этого их следует сформулировать на специальном языке. Но в СУБД уже существует язык SQL, о котором речь шла выше. Поэтому было бы целесообразно использовать его не только в качестве средства доступа к данным, но и как стандарта общения клиента и сервера.</span></p><p><span>К сожалению, RDA-модель не лишена ряда недостатков. Во-первых, взаимодействие клиента и сервера посредством SQL-запросов существенно загружает сеть. Во-вторых, удовлетворительное администрирование приложений в RDA-модели практически невозможно из-за совмещения в одной программе различных по своей природе функций (функции представления и прикладные функции).</span></p><p><span>Наряду с RDA-моделью все большую популярность приобретает перспективная DBS-модель. Последняя реализована в некоторых реляционных СУБД (Informix, Ingres, Sybase, Oracle, InterBase). Ее основу составляет механизм хранимых процедур -средство программирования SQL-сервера. Процедуры хранятся в словаре базы данных, разделяются между несколькими клиентами и выполняются на том же компьютере, где функционирует SQL-сервер. Язык, на котором разрабатываются хранимые процедуры (SQL/PTL), представляет собой процедурное расширение языка запросов SQL и уникален для каждой конкретной СУБД.</span></p><p><span>В DBS-модели компонент представления выполняется на компьютере-клиенте, в то время как прикладной компонент оформлен как набор хранимых процедур и функционирует на компьютере-сервере БД. Там же выполняется компонент доступа к данным, то есть ядро СУБД. Достоинства DBS-модели: возможность централизованного администрирования прикладных функций, и снижение трафика (вместо SQL-запросов по сети направляются вызовы хранимых процедур), возможность разделения процедуры между несколькими приложениями, экономия ресурсов компьютера за счет использования единожды созданного плана выполнения процедуры. К недостаткам можно отнести ограниченность средств, используемых для написания хранимых процедур, которые представляют собой разнообразные процедурные расширения SQL, не выдерживающие сравнения по функциональным возможностям с языками третьего поколения, такими как C или Pascal. Сфера их использования ограничена конкретной СУБД, в большинстве СУБД отсутствуют возможности отладки и тестирования разработанных хранимых процедур.</span></p>
<p><span><img src="Тема%20№15.files/image004.gif" v:shapes="_x0000_i1026"> </span></p>
<p><span> Рис.3. Модель сервера баз данных </span></p>
<p><span>На практике часто используется смешанные модели, когда поддержка целостности базы данных и некоторые простейшие прикладные функции выполняются хранимыми процедурами (DBS-модель), а более сложные функции реализуются непосредственно в прикладной программе, которая работает на компьютере-клиенте (RDA-модель). Так или иначе, современные многопользовательские СУБД опираются на RDA- и DBS-модели и при создании ИС, предполагающем использование только СУБД, выбирают одну из этих двух моделей, либо их разумное сочетание. </span></p><p><span>В AS-модели процесс, выполняющийся на компьютере-клиенте, отвечает, как обычно, за интерфейс с пользователем (то есть реализует функции первой группы). Обращаясь за выполнением услуг к прикладному компоненту, этот процесс играет роль клиента приложения (Application Client - AC). Прикладной компонент реализован как группа процессов, выполняющих прикладные функции и называется сервером приложения (Application Server - AS). Все операции над информационными ресурсами выполняются соответствующим компонентом, по отношению к которому AS играет роль клиента. Из прикладных компонентов доступны ресурсы различных типов - базы данных, очереди, почтовые службы и др.</span></p>
<p><span><img src="Тема%20№15.files/image005.gif" v:shapes="_x0000_i1026"> </span></p>
<p><span> Рис.4. Модель сервера приложений</span></p><p><span> </span></p><p><span>RDA- и DBS-модели опираются на двухзвенную схему разделения функций. В RDA-модели прикладные функции приданы программе-клиенту, в DBS-модели ответственность за их выполнение берет на себя ядро СУБД. В первом случае прикладной компонент сливается с компонентом представления, во втором -интегрируется в компонент доступа к информационным ресурсам. В AS-модели реализована трехзвенная схема разделения функций, где прикладной компонент выделен как важнейший изолированный элемент приложения, для его определения используются универсальные механизмы многозадачной операционной системы, и стандартизованы интерфейсы с двумя другими компонентами. AS-модель является фундаментом для мониторов обработки транзакций (Transaction Processing Monitors - TPM), или, проще, мониторов транзакций, которые выделяются как особый вид программного обеспечения. </span></p><p><span>В период создания первых СУБД технология "клиент-сервер" только зарождалась. Поэтому изначально в архитектуре систем не было адекватного механизма организации взаимодействия такого типа, в современных же системах он жизненно необходим. </span></p><p><span>Чтобы понять проблему, рассмотрим эволюцию серверов баз данных. Первое время доминировала модель, когда управление данными (функция сервера) и взаимодействие с пользователем были совмещены в одной программе. Затем функции управления данными были выделены в самостоятельную группу - сервер, однако модель взаимодействия пользователя с сервером соответствовала парадигме "один-к-одному", то есть сервер обслуживал запросы ровно одного пользователя (клиента), и для обслуживания нескольких клиентов нужно было запустить эквивалентное число серверов. Выделение сервера в отдельную программу - революционный шаг, позволяющий, в частности, поместить сервер на одну машину, а программный интерфейс с пользователем - на другую, осуществляя взаимодействие между ними по сети. Однако необходимость запуска большого числа серверов для обслуживания множества пользователей сильно ограничивала возможности такой системы. </span></p><p><span>Проблемы, возникающие в модели "один-к-одному", решаются в архитектуре систем с выделенным сервером, способным обрабатывать запросы от многих клиентов. Сервер единственный обладает монополией на управление данными и взаимодействует одновременно со многими клиентами. Логически каждый клиент связан с сервером отдельной нитью (thread) или потоком, по которому пересылаются запросы. Такая архитектура получила название многопотоковой (multi-threaded). </span></p><p><span>Она позволяет значительно уменьшить нагрузку на операционную систему, возникающую при работе большого числа пользователей. С другой стороны, возможность взаимодействия с одним сервером многих клиентов позволяет в полной степени использовать разделяемые объекты (начиная с открытых файлов и кончая данными из системных каталогов), что сильно уменьшает потребности в памяти и общее число процессов операционной системы. Например, системой с архитектурой "один-к-одному" будет создано 50 копий процессов СУБД для 50 пользователей, тогда как системе с многопотоковой архитектурой для этого понадобиться только один сервер. </span></p><p><span>Однако такое решение создает новую проблему. Так как сервер может выполняться только на одном процессоре, возникает естественное ограничение на применение СУБД для ультипроцессорных платформ. Если компьютер имеет, например, четыре процессора, то СУБД с одним сервером используют только один из них, не загружая оставшиеся три. </span></p><p><span>В некоторых системах эта проблема решается заменой выделенного сервера на диспетчер или виртуальный сервер (virtual server), который теряет право монопольно распоряжаться данными, выполняя только функции диспетчеризации запросов к актуальным серверам. Таким образом, в архитектуру системы добавляется новый слой, который размещается между клиентом и сервером, что увеличивает трату ресурсов на поддержку баланса загрузки (load balancing) и ограничивает возможности управления взаимодействием "клиент-сервер". Во-первых, становится невозможным направить запрос от конкретного клиента конкретному серверу, во-вторых, серверы становятся равноправными – невозможно устанавливать приоритеты для обслуживания запросов.</span></p><p><span>Современное решение проблемы СУБД для мультипроцессорных платформ заключается в возможности запуска нескольких серверов базы данных, в том числе и на различных процессорах. При этом каждый из серверов должен быть многопотоковым. Если два эти условия выполнены, то есть основание говорить о многопотоковой архитектуре с несколькими серверами (multi-threaded, multi-server architecture).</span></p><p><span> </span></p><p><b><span>Реализация распределенной базы данных с удаленным доступом</span></b></p>
<p><span> </span></p>
<p><span>В качестве примера реализации распределенной базы данных рассмотрим информационную систему для автоматизации расчетов с абонентами АО «Связьинформ» РМ. </span></p><p><span>В данной организации возникает задача учета финансовых поступлений за оказанные услуги связи. Сейчас для ее выполнения используется программный комплекс «Парус», который реализует часть необходимых функций. В последнее время возникла задача повременной тарификации и учета проведенных телефонных разговоров, что приводит к резкому увеличению объемов данных, циркулирующих в системе. Кроме того, для выработки политики тарификации услуг связи необходимо анализировать объем и структуру начислений, что требует постоянного хранения данных об оказанных услугах. С увеличением потока информации необходимо увеличить число операторских мест для занесения данных, следовательно система должна хорошо работать в многопользовательской среде. Программа «Парус» построена по идеологии настольных систем и поэтому её перенос в сетевую среду возможен только по архитектуре файл-сервера. Такой подход отличается плохой масштабируемостью и делает практически невозможной работу удаленных пользователей, Существующая система не может обрабатывать накапливаемый объем данных, поэтому возникает необходимость создания новой системы обработки информации, построенной по идеологии клиент-сервер.</span></p><p><span>Основные требования к системе таковы:</span></p><p><span>· система автоматизации расчетов с абонентами должна обрабатывать данные по</span></p><p><span>имеющимся клиентам;</span></p><p><span>· система должна учитывать начисления по оказанным услугам;</span></p><p><span>· система должна учитывать оплату, поступившую с клиента за оказанные услуги;</span></p><p><span>· система должна иметь механизм регистрации изменений и возможность отката к одному из предыдущих состояний;</span></p><p><span>· система должна обеспечивать возможность оперативного доступа к информации;</span></p><p><span>· система должна иметь развитые механизмы обеспечения информационной безопасности (защита от несанкционированного доступа, избыточность хранения информации).</span></p> <p style="text-align: center;"><a><b><span> </span></b></a></p> <p style="text-align: center;"><b><span> </span></b></p> <p style="text-align: center;"><b><span>15.4 Администрирование MS SQL Server</span></b></p> <p style="text-align: center;"><b><span>Средства автоматического конфигурирования SQL Server</span></b></p> <p><span> SQL Server содержит множество автоматических средств, предназначенных для снижения расходов, которые обычно связаны с конфигурированием и настройкой системы управления реляционными базами данных (RDBMS). В этом разделе вы ознакомитесь с некоторыми из этих средств. (Те, кто работал с Microsoft SQL Server 7, уже знают об этих средствах, поскольку они были введены именно в SQL Server 7.) Вы узнаете, как они действуют, как их использовать для облегчения вашей работы администратора баз данных (DBA) и как переопределять при необходимости эти автоматические средства.</span></p> <p style="text-align: center;"><b><span>Динамическое управление памятью</span></b></p> <p><span> Динамическое управление памятью позволяет SQL Server динамически конфигурировать количество памяти, используемое для буферного кэша и кэша процедур, исходя из доступной памяти системы. Поскольку в SQL Server включено динамическое управление памятью, DBA не обязан вручную управлять размером каждого кэша. Но в определенных ситуациях вам может потребоваться ограничение количества памяти, используемой SQL Server, и такая возможность тоже существует.</span></p> <p style="text-align: center;"><b><span>Как действует динамическое управление памятью</span></b></p> <p><span> Средство динамического управления памятью действует путем постоянного мониторинга доступной физической памяти в системе. SQL Server увеличивает или уменьшает пул памяти SQL Server (описан в следующем разделе), исходя из своих потребностей и количества доступной памяти. Это может оказаться очень полезным в системах, где количество используемой памяти относительно стабильно, но если количество памяти, используемое процессами, не связанными с SQL Server, варьируется, то SQL Server будет постоянно изменять свое распределение памяти, и это может создавать проблемы.</span></p> <p><span>Компьютерная система, которая используется в основном как сервер базы данных SQL Server, вполне подходит для динамического управления памятью. В такой системе количество памяти, используемое процессами, отличными от SQL Server, стабильно, поэтому SQL Server будет автоматически выделять себе память, необходимую для своей эффективной работы вплоть до предела доступной физической памяти. Затем SQL Server будет поддерживать это количество, пока не потребуется память другим процессам. Если другому процессу действительно требуется память, SQL Server освобождает необходимое количество памяти, чтобы оно было доступно для другого процесса.</span></p> <p><span>Компьютерная система, на которой выполняются процессы с постоянно изменяющимися требованиями памяти, причем количество процессов часто увеличивается или уменьшается, не слишком подходит для динамического управления памятью. На такой системе использование памяти постоянно изменяется, что требует от SQL Server постоянного закрепления и освобождения памяти, когда она требуется другим процессам, что может оказаться неэффективным из-за дополнительной нагрузки. В системе такого типа может оказаться более эффективным ручное выделение фиксированного количества памяти для SQL Server или задание минимального и максимального количества памяти, которое может получать SQL Server. Вы узнаете, как это сделать, ниже в этой лекции.</span></p> <p><span>Таким образом, выбор между динамическим и ручным управлением памятью определяется степенью изменчивости использования памяти в системе. Применяя мониторинг использования памяти системой SQL Server, вы можете определить, изменяется ли количество используемой памяти каким-либо регулярным образом или остается достаточно стабильным. Для мониторинга использования памяти вы можете использовать Microsoft Windows 2000 Performance Monitor. Счетчик Total Server Memory (KB) внутри объекта SQLServer:Memory Manager показывает количество памяти в килобайтах (Кб), которое использует в данный момент SQL Server. Чтобы определить, как изменяется использование памяти в течение времени, следите за этим счетчиком в окне диаграмм (chart window).</span></p> <p style="text-align: center;"><b><span> Пул памяти</span></b></p> <p><span> SQL Server динамически выделяет и освобождает память в пуле. Пул памяти содержит определенное количество памяти, которое разделяется между следующими компонентами:</span></p> <p><b><span>Буферный кэш.</span></b><span> Содержит страницы базы данных, считанные в память. Буферный кэш обычно забирает основную часть пула памяти.</span></p> <p><b><span>Память для соединений.</span></b><span> Используется каждым соединением с SQL Server. Память для соединений содержит структуры данных, с помощью которых отслеживается контекст каждого пользователя; это информация о позиционировании курсора, значения параметров очереди и информация хранимых процедур.</span></p> <p><b><span>Структуры данных.</span></b><span> Содержит глобальную информацию о блокировках и дескрипторах базы данных, включая информацию о владельцах блокировок, о типах захваченных блокировок, а также о различных файлах и группах файлов.</span></p> <p><b><span>Кэш журнала.</span></b><span> Используется для информации журнала, которая будет записана в журнал транзакций. Он также используется, когда происходит чтение последней информации, записанной в этот кэш. Использование кэша журнала повышает производительность операций записи в журналы. Кэш журнала не следует путать с буферным кэшем.</span></p> <p><b><span>Кэш процедур.</span></b><span> Используется для хранения планов исполнения операторов Transact-SQL (T-SQL) и хранимых процедур, когда происходит их выполнение.</span></p> <p><span>Поскольку в случае использования динамического управления памятью распределение памяти динамически изменяется, пул памяти может все время увеличиваться или уменьшаться. Кроме того, указанные пять компонентов пула памяти тоже могут динамически изменять свои размеры. Это распределение недоступно для конфигурирования; управление осуществляет SQL Server. Например, когда требуется больше памяти, чтобы в кэше процедур можно было хранить больше операторов T-SQL, SQL Server может забирать часть памяти из буферного кэша и использовать ее для кэша процедур.</span></p> <p style="text-align: center;"><b><span> Использование дополнительной памяти</span></b></p> <p><span> Количество памяти, доступной для SQL Server, зависит от используемой операционной системы Windows. Microsoft Windows NT Server 4 поддерживает 4 Гб памяти, 2 Гб из которых выделяется для пользовательских процессов и 2 Гб резервируется для использования системой. Это ограничение в 2 Гб представляет максимальное количество памяти, которое может быть выделено для SQL Server в NT 4.0. Но в системе Windows NT Server 4 Enterprise Edition количество виртуальной памяти, выделяемой для процесса, на 50 процентов больше – 3 Гб. Это увеличение стало возможным, так как память, выделенная для системы, была сокращена до 1 Гб. Такое увеличение виртуальной памяти, выделенной для процессов, позволяет вам увеличивать размер пула памяти до величины, близкой к 3 Гб. Чтобы активизировать эту поддержку в Windows NT 4 Enterprise Edition, вы должны добавить флаг /3GB к строке загрузки в файле Boot.ini, что можно сделать с помощью значка System (Система) в панели управления.</span></p> <p><span>Имеется две версии операционной системы Windows 2000, в которых SQL Server 2000 Enterprise Edition может использовать интерфейс расширенной памяти Windows 2000 Address Windowing Extensions (AWE) API, поддерживающий адресные пространства большего размера. SQL Server поддерживает около 8 Гб в системе Windows 2000 Advanced Server и около 64 Гб в системе Windows 2000 Datacenter Server. AWE поддерживается только в этих двух операционных системах и не поддерживается в Windows 2000 Professional.</span></p> <p style="text-align: center;"><b><span> Параметры конфигурирования памяти SQL Server</span></b></p> <p><span> Следующие параметры конфигурирования SQL Server связаны с конкретными аспектами распределения памяти. Вы можете задать эти параметры с помощью SQL Server Enterprise Manager или с помощью хранимой процедуры sp_configure. Для просмотра всех этих параметров с помощью sp_configure у вас должно быть задано значение 1 для параметра show advanced options (показать дополнительные параметры).</span></p> <p><b><span>awe enabled (активизирована awe).</span></b><span> Разрешает SQL Server использовать расширенную память (AWE-память, о которой говорилось выше). Значение 1 для этого параметра активизирует эту память. Данный параметр доступен только в SQL Server Enterprise Edition, и его можно задать только с помощью процедуры sp_configure.</span></p> <p><b><span>index create memory (память для создания индекса).</span></b><span> Ограничивает количество памяти, используемое для сортировок при создании индекса. Параметр index create memory является самоконфигурируемым. Он не требует изменений в большинстве случаев. Но если вы испытываете трудности при создании индексов, то можете попытаться увеличить значение этого параметра по сравнению с его значением по умолчанию.</span></p> <p><b><span>max server memory (максимальная память для сервера).</span></b><span> Задает максимальное количество памяти, которое может захватить для пула памяти SQL Server. Оставьте значение по умолчанию, если хотите, чтобы SQL Server динамически захватывал и освобождал память. Если вы хотите выделить память статически (чтобы используемое количество памяти не изменялось), задайте одинаковые значения для этого параметра и параметра min server memory.</span></p> <p><b><span>min memory per query (минимальная память на один запрос). </span></b><span>Задает минимальное количество памяти (в килобайтах), которое будет выделяться для выполнения одного запроса.</span></p> <p><b><span>min server memory (минимальная память для сервера).</span></b><span> Задает минимальное количество памяти, которое может захватить для пула памяти SQL Server. Оставьте значение по умолчанию, чтобы использовалось динамическое распределение памяти. Если вы хотите выделить память статически, задайте одинаковые значения для этого параметра и параметра max server memory.</span></p> <p><b><span>set working set size (</span></b><b><span>размер</span></b><b><span> </span></b><b><span>рабочего</span></b><b><span> </span></b><b><span>набора</span></b><b><span>).</span></b><span> </span><span>Указывает, что для памяти, которую занял SQL Server, не допускается свопинг, даже если эта память может более эффективно использоваться другим процессом. Параметр set working set size не должен использоваться, если для SQL Server задано динамическое использование памяти. Его следует использовать, только когда для параметров min server memory и max server memory задано одинаковое значение. В этом случае SQL Server захватит определенное статическое количество памяти, не подлежащей страничному обмену.</span></p> <p><span>Примечание. Для использования возможностей AWE-памяти у вас должна использовать система Windows 2000 Advanced Server или Windows 2000 Datacenter Server в сочетании с SQL Server 2000 Enterprise Edition.</span></p> <p style="text-align: center;"><b><span> Другие параметры динамического конфигурирования</span></b></p> <p><span> В SQL Server имеется несколько параметров динамического конфигурирования или SQL Server Enterprise Manager (но не все параметры можно задать через Enterprise Manager). Чтобы задать какой-либо параметр через sp_configure, откройте Query Analyzer (Анализатор очередей) или osql-соединение в окне командной строки и запустите эту хранимую процедуру со следующими параметрами:</span></p> 
<p><span> </span></p> 
<p><span>sp_configure "имя параметра", значение</span></p> 
<p><span> </span></p> 
<p><span> Имя параметра – это имя параметра конфигурирования, а значение – это значение, которое вы хотите ему присвоить. Если запустить эту команду, не указывая значение , то SQL Server возвратит текущее значение указанного параметра. Чтобы увидеть список всех параметров и их значений, запустите sp_configure без какого-либо параметра. Несколько параметров считаются дополнительными. Для просмотра и конфигурирования этих параметров с помощью sp_configure вы должны сначала задать для параметра show advanced options (показать дополнительные параметры) значение 1, как это показано ниже:</span></p> 
<p><span> </span></p> 
<p><span>sp_configure "show advanced options", 1</span></p> 
<p><span> </span></p> 
<p><span>Параметр show advanced options не оказывает влияния на параметры, которые можно конфигурировать через Enterprise Manager.</span></p> <p><span>Чтобы задать значение какого-либо параметра с помощью Enterprise Manager, сначала откройте в Enterprise Manager окно Properties (Свойства) для сервера, щелкнув правой кнопкой мыши на имени этого сервера и выбрав из контекстного меню пункт Properties </span></p> <p><span> </span><span>Вы можете затем осуществлять доступ к определенным динамическим параметрам во вкладках этого окна. В следующих разделах описываются динамические параметры SQL Server, не связанные с памятью; в каждом разделе указывается, можно ли задавать соответствующий параметр в Enterprise Manager, и если да, то указывается местоположение этого параметра в окне Properties.</span></p> <p><span> <b>Параметр locks (блокировки)</b></span></p> <p><span> SQL Server динамически конфигурирует количество используемых в системе блокировок в соответствии с текущими потребностями. Вы можете задать значение параметра locks для указания максимального количества блокировок, ограничив тем самым количество памяти, которое использует для блокировок SQL Server. По умолчанию задано значение 0, что позволяет SQL Server динамически захватывать и освобождать блокировки в зависимости от изменяющихся требований системы. В SQL Server разрешается использовать для блокировок до 40 процентов всей его памяти. Вам следует оставить для этого параметра принятое по умолчанию значение 0, чтобы SQL Server захватывал блокировки по необходимости. Этот параметр входит в группу дополнительных параметров, и его можно задать только с помощью sp_configure.</span></p> <p><span>Параметр recovery interval (интервал восстановления)</span></p> <p><span>Параметр recovery interval указывает максимальное количество минут, которое может потратить SQL Server для восстановления после аварии. Время, которое требуется SQL Server для восстановления базы данных, зависит от момента, когда была создана последняя контрольная точка. Поэтому значение recovery interval используется в SQL Server для динамического определения моментов автоматического применения контрольных точек.</span></p> <p><span>Например, когда происходит "чистое" закрытие SQL Server, контрольные точки создаются по всем базам данных, поэтому при перезапуске SQL Server восстановление занимает немного времени. Но если происходит вынужденная остановка SQL Server без "чистого" отключения (из-за отказа источника питания или аварии другого типа), то при повторном запуске SQL Server должен восстанавливать каждую базу данных путем отката всех транзакций, которые не были фиксированы, и повторного выполнения транзакций, которые были фиксированы, но их изменения еще не были записаны на диск к моменту аварии. Если последняя контрольная точка была создана незадолго до аварии системы, то на восстановление уйдет немного времени. Если последняя контрольная точка была создана задолго до аварии системы, это потребует более длительного времени восстановления.</span></p> <p><span>SQL Server определяет, насколько часто нужно создавать контрольные точки, согласно встроенному алгоритму и, как уже говорилось, в соответствии со значением recovery interval. Например, если вы зададите для recovery interval значение 5, то SQL Server будет создавать контрольные точки по каждой базе данных с такой частотой, чтобы восстановление после аварии занимало бы примерно 5 минут. По умолчанию значение recovery interval равно 0, указывая на автоматическое конфигурирование интервала в SQL Server. Если используется это значение по умолчанию, то время восстановления меньше 1 минуты и контрольные точки создаются для активных баз данных приблизительно каждую минуту. Во многих случаях преимущества частого создания контрольных точек теряются за счет снижения производительности, вызываемого созданием контрольных точек. Со временем вам придется снизить количество создаваемых контрольных точек, увеличив значение recovery interval. Выбираемое вами значение будет зависеть от деловых требований, связанных с тем, сколько времени могут ждать пользователи в случае восстановления системы после аварии. Обычно следует использовать значение в интервале от 5 до 15 минут, соответствующее времени восстановления от 5 до 15 минут.</span></p> <p><span>Параметр recovery interval входит в группу дополнительных параметров. Вы можете задать его в Enterprise Manager во вкладке Database Settings (Параметры базы данных) окна Properties в поле Recovery Interval (min).</span></p> 
<p><span> </span></p> 
<p><a></a><b><span>Параметр user connections (количество соединений с пользователями)</span></b></p> <p><span> SQL Server динамически конфигурирует допустимое количество соединений пользователей с SQL Server. В SQL Server допускается до 32767 соединений с пользователями Задавая значение user connections, отличное от 0, вы указываете максимально допустимое количество одновременных подсоединений пользователей к SQL Server. (Количество допустимых подсоединений пользователей также зависит от ограничений ваших приложений и оборудования.) Количество подсоединений пользователей будет также динамически конфигурироваться вплоть до указанного максимума.</span></p> <p><span>Например, если подсоединяются только 10 пользователей, будет выделено только 10 объектов-соединений с пользователями (user connection). Если достигнуто максимальное значение, а SQL Server требуются новые соединения с пользователями, то вы получите сообщение об ошибке, где указывается, что достигнуто максимальное значение по количеству соединений с пользователями.</span></p> <p><span>В большинстве случаев принятое по умолчанию значение параметра user connections изменять не требуется. Отметим, что для каждого соединения требуется порядка 40 Кб памяти.</span></p> <p><span>Чтобы определить максимальное количество соединений с пользователями, допустимое в вашей системе, вы можете использовать SQL Server Query Analyzer или следующий оператор T-SQL:</span></p> <p><span>SELECT @@MAX_CONNECTIONS</span></p> <p><span>Параметр user connections входит в группу дополнительных параметров. Вы можете задать его в Enterprise Manager во вкладке Connections (Соединения) окна Properties в поле-счетчике Maximum Concurrent User Connections (Максимальное число одновременных соединений с пользователями) </span></p> <p><b><span>Параметр open objects (количество открытых объектов)</span></b></p> <p><span> Параметр open objects входит в группу дополнительных параметров; его можно задать только с помощью процедуры sp_configure. Этот параметр определяет максимально допустимое количество одновременно открытых объектов базы данных, таких как таблицы, представления, хранимые процедуры, триггеры, правила и значения по умолчанию. Принятое по умолчанию значение 0 указывает, что SQL Server будет динамически регулировать допустимое количество одновременно открытых объектов в данной системе. Вам следует оставить это значение по умолчанию без изменений. Если вы все же измените его, а SQL Server потребуется больше открытых объектов, чем вы сконфигурировали, то появится сообщение об ошибке от SQL Server, где указывается, что вы превысили допустимое количество открытых объектов. Кроме того, для каждого открытого объекта требуется некоторое количество памяти, поэтому вашей системе может потребоваться большее количество физической памяти, чтобы поддерживать необходимое количество открытых объектов.</span></p> <p style="text-align: center;"><b><span>Статистика</span></b></p> <p><b><span> </span></b><span>Статистика<b> </b></span><span>по колонкам необходима для повышения производительности запросов в вашей системе. SQL Server может собирать статистическую информацию, касающуюся распределения значений в колонке таблицы. Оптимизатор запросов Query Optimizer затем использует эту информацию для определения оптимального плана исполнения запроса. Статистику можно собирать по двум типам колонок: по тем, что являются частью индекса, и по тем, что не входят в индекс, но используются в предикате запроса (в предложении WHERE). Оставив принятые по умолчанию значения SQL Server для базы данных, вы разрешаете автоматическое создание обоих типов статистики в SQL Server. Статистика по индексированным колонкам создается при создании соответствующего индекса. Статистика по неиндексированным колонкам создается, когда она требуется для какого-либо запроса (только по одной колонке, а не по нескольким, как вы увидите в подразделе "Команда CREATE STATISTICS" этого раздела). Если статистика устарела (не использовалась в течение определенного периода времени), то SQL Server автоматически удаляет ее.</span></p> <p><span>Чтобы создать статистику и по индексированным, и по неиндексированным колонкам, SQL Server использует только выборку данных таблицы, но не все строки таблицы. Это снижает дополнительную нагрузку, связанную с этой операцией, но в некоторых случаях выборка недостаточно хорошо характеризует данные и статистика оказывается не совсем точной.</span></p> <p><span>В Enterprise Manager вы можете активизировать или отключать автоматическое создание статистики по базе данных. Для этого сначала откройте окно Properties этой базы данных. Во вкладке Options вы увидите флажок Auto Create Statistics (Автоматическое создание статистики). (На рисунке этот флажок установлен для базы данных MyDB.) Этот флажок установлен (активизирован) по умолчанию.</span></p> <p><span>В окне Properties соответствующей базы данных вы также увидите флажок Auto Update Statistics (Автоматическое обновление статистики). Этот флажок, который установлен по умолчанию для каждой базы данных, указывает, что SQL Server при необходимости будет автоматически обновлять статистику по колонкам таблицы. Статистику требуется обновлять в тех случаях, когда изменилось большое количество (или большой процент) строк таблицы (посредством операций обновления, вставки и удаления). При большом числе изменений в данных текущая статистика становится менее точной. SQL Server автоматически определяет, когда требуется обновить статистику. Если вы решили отключить автоматическое создание статистики, сбросив этот флажок, то вы должны выполнять эти задачи вручную, чтобы убедиться в нормальной работе вашей базы данных. </span></p> <p style="text-align: center;"><b><span> Команда CREATE STATISTICS</span></b></p> <p><span> Вы можете создавать статистику по определенным колонкам таблицы вручную с помощью оператора T-SQL CREATE STATISTICS. Создание статистики вручную отличается от автоматического создания в том, что оно позволяет вам объединять несколько колонок, генерируя для комбинации колонок такую информацию, как среднее количество дублированных значений и отличающихся значений. Команда CREATE STATISTICS имеет следующий синтаксис:</span></p> 
<p><span> </span></p> 
<p><span>CREATE STATISTICS имя_статистики ON</span></p> <p><span> имя_таблицы ( колонка [ , колонка... ] )</span></p> <p><span> [ [WITH [ FULLSCAN | SAMPLE размер PERCENT ]</span></p> <p><span> [ , NORECOMPUTE ]</span></p> 
<p><span> </span></p>
 <p><span>Вам следует ввести имя для набора статистики, который вы создаете, имя таблицы, а также имя хотя бы одной колонки. Вы можете указать несколько имен колонок для сбора статистики по комбинации колонок. Отметим, что вы не можете указывать для статистики расчетные колонки или колонки с типом данных ntext, text или image. Для сбора статистики можно указывать полное сканирование (FULLSCAN) или выборку данных (SAMPLE). Для полного сканирования требуется больше времени, чем для выборки, поскольку сканируется каждая строка таблицы, но результаты могут оказаться более точными. Используя выборку, вы должны указать процент данных, включаемых в выборку. Ключевое слово NORECOMPUTE указывает, что автоматическое обновление этой статистики отключено, что позволяет использовать статистику, которая уже не отражает текущее состояние данных.</span></p> <p><span>Вам может потребоваться создание статистики по колонкам, которые совместно используются в предикате запроса. Например, вы можете создать статистику по колонкам FirstName (Имя) и LastName (Фамилия) таблицы Employees (Сотрудники) базы данных Northwind для поиска сотрудника по имени и фамилии. Для этого используется следующая последовательность T-SQL:</span></p> 
<p><span> </span></p>
 <p><span>CREATE STATISTICS name</span></p> <p><span>ON Northwind..Employees (FirstName, LastName)</span></p> <p><span>WITH FULLSCAN, NORECOMPUTE</span></p> 
<p><span> </span></p>
 <p><span>Этот оператор рассчитывает статистику для всех строк колонок FirstName и LastName и отключает автоматический перерасчет статистики.</span></p> <p><span>Если вы хотите запустить статистику для всех колонок всех таблиц базы данных вручную без ввода операторов CREATE STATISTICS для каждой колонки каждой таблицы, то можете использовать хранимую процедуру sp_createstats. Эта хранимая процедура описана в следующем разделе.</span></p> <p><span>Процедура sp_createstats</span></p> <p><span>Вы можете запустить статистику для всех допустимых колонок всех таблиц пользовательских базы данных с помощью хранимой процедуры sp_createstats. Статистика будет создана для всех колонок, по которым еще не создана статистика. Каждый набор статистики будет создан по какой-либо одной колонке. Процедура </span><span>sp</span><span>_</span><span>createstats</span><span> </span><span>имеет следующий синтаксис:</span></p> <p><span> </span></p> <p><span>sp</span><span>_</span><span>createstats</span><span> [ '</span><span>indexonly</span><span>' ] [ , '</span><span>fullscan</span><span>' ] [ , '</span><span>norecompute</span><span>' ]</span></p> <p><span> </span></p> <p><span>Параметр indexonly указывает, что статистика будет создана только по колонкам, включаемым в индекс. Параметр fullscan указывает, что будет выполнено полное сканирование всех строк, а не случайная выборка; иначе говоря, будет использована выборка 100 процентов данных. Параметр norecompute указывает, что по этой новой статистике будет отключено автоматическое обновление статистики. Новой статистике присваивается имя колонки, по которой она создается.</span></p> <p style="text-align: center;"><b><span> Команда UPDATE STATISTICS </span></b></p> <p><span> По умолчанию SQL Server автоматически обновляет статистику. Вы можете отключить эту возможность с помощью команды UPDATE STATISTICS и затем обновлять статистику вручную, чтобы она соответствовала текущему состоянию данных. Эта команда позволяет вам обновлять статистику по индексированным колонкам и неиндексированным колонкам. Возможно, вы создадите сценарий, который будет выполнять команду UPDATE STATISTICS для наиболее часто модифицируемых таблиц, и затем будете периодически запускать этот сценарий как задание SQL Server. Это позволит поддерживать статистику в соответствии с текущим состоянием данных и поддерживать более высокую производительность запросов. Чтобы активизировать или отключить автоматическое обновление для определенной статистики, вы можете использовать хранимую процедуру sp_autostats, которая описывается далее.</span></p> <p><span> <b>Процедура sp_autostats</b></span></p> <p><span> Используя системную хранимую процедуру sp_autostats, вы можете активизировать или отключить автоматическое обновление определенной статистики. Запуск этой процедуры не приводит к обновлению данной статистики; она просто определяет, должно ли происходить автоматическое обновление статистики. Вызов этой хранимой процедуры происходит с одним, двумя или тремя параметрами: имя таблицы и – дополнительно – флаг и имя статистики. Флаг указывает состояние автоматического обновления и может принимать значения ON (включено) или OFF (отключено). Чтобы вывести текущий статус обновления для всех наборов статистики по определенной таблице (статистика по индексированным колонкам и неиндексированным колонкам), запустите эту команду с именем этой таблицы. Следующая команда выводит этот статус для наборов статистики по таблице Customers:</span></p> <p><span>USE Northwind</span></p> <p><span>GO</span></p> <p><span>sp_autostats Customers</span></p> <p><span>GO</span></p> <p><span> </span></p> <p><span>Будет выведено имя каждого набора статистики независимо от значения флага автоматического обновления (ON или OFF) и время последнего обновления. Не обращайте внимания на заголовок первой колонки Index Name (Имя индекса). Он относится ко всем наборам статистики, а не только к индексам. Если вы не отключили вручную обновление для этих наборов статистики, то они будут представлены со статусом ON, поскольку это принятое по умолчанию состояние в SQL Server.</span></p> <p><span>Чтобы отключить автоматическое обновление всех наборов статистики в таблице Customers базы данных Northwind, используйте следующую команду:</span></p> <p><span> </span></p> <p><span>USE Northwind</span></p> <p><span>GO</span></p> <p><span>sp_autostats Customers, 'OFF'</span></p> <p><span>GO</span></p> <p><span> </span></p> <p><span>Вы можете снова активизировать автоматическое обновление статистики, задав для флага значение ON. Чтобы изменить статус определенного набора статистики или статистики для индекса, включите в обращение соответственно имя набора статистики или имя индекса. Например, следующая команда задает автоматическое обновление статистики для индекса PK_Customers:</span></p> <p><span> </span></p> <p><span>USE Northwind</span></p> <p><span>GO</span></p> <p><span>sp_autostats Customers, 'ON', 'PK_Customers'</span></p> <p><span>GO</span></p> <p><span>Статус всех других наборов статистики по таблице Customers не изменится.</span></p> <p><b><span> Рост файлов</span></b></p> <p><span> Работая с SQL Server 2000, вы можете конфигурировать файлы данных для их автоматического увеличения по мере необходимости. Это средство полезно, поскольку оно препятствует случайному выходу файлов за пределы допустимого дискового пространства. Однако использование это средства не освобождает вас от обязанности мониторинга размера ваших баз данных и выполнения время от времени процедур планирования мощности. Вы также должны следить за тем, как быстро происходит рост таблиц, чтобы вы могли определить, нужно ли вам выполнять регулярное удаление ненужных, возможно, устаревших данных в некоторых таблицах, чтобы сдерживать рост ваших таблиц. По мере роста количества данных в таблице запросы могут занимать больше времени, что приводит к снижению уровня производительности.</span></p> <p><span>Параметры автоматического роста файлов можно сконфигурировать в Enterprise Manager. Для этого выполните следующие шаги.</span></p> <p><span>В левой панели Enterprise Manager раскройте сервер и затем щелкните на папке Databases (Базы данных). Щелкните правой кнопкой мыши на базе данных, которую вы хотите модифицировать (в данном примере мы будем модифицировать базу данных MyDB), и выберите из контекстного меню пункт Properties, чтобы открыть окно свойств базы данных Properties.</span></p> <p><span>Щелкните на вкладке Data Files (Файлы данных), чтобы увидеть свойства файлов данных для этой базы данных. Параметры секции File properties (Свойства файлов) предназначены для того, чтобы вы могли контролировать рост файла данных. Чтобы разрешить автоматический контроль роста файла, установите флажок Automatically grow file (Автоматический рост файла). Используя средство автоматического увеличения файла, вы должны задать ограничения, чтобы воспрепятствовать неконтролируемому росту файла. </span></p> <p><a></a><span> Максимальный размер файла указывается с помощью параметров секции Maximum file size (Максимальный размер файла). Щелкните на кнопке выбора Restrict file growth (Ограничить рост файла) и введите максимально допустимый размер в прокручиваемом поле-счетчике. Если щелкнуть на кнопке выбора Unrestricted file growth (Неограниченный рост файла), то в дальнейшем вы можете столкнуться с тем, что вся ваша дисковая подсистема заполнена до конца без какого-либо предупреждения, создавая проблемы как для работы, так и производительности. </span></p> <p><span>Степень роста файла задается с помощью параметров секции File growth (Рост файла). Если щелкнуть на кнопке выбора In megabytes (Мегабайты), то после заполнения этого файла данных SQL Server увеличит его размер на указанную величину. Если щелкнуть на кнопке выбора By percent (Проценты), то SQL Server увеличит размер файла данных на указанную величину в процентах от текущего размера.</span></p> <p><span>Щелкните на вкладке Transaction Log (Журнал транзакций), чтобы задать параметры автоматического роста для журнала транзакций. Параметры этой вкладки используются так же, как и соответствующие параметры вкладки Data Files. Вы должны задать пределы для файлов журнала транзакций, чтобы воспрепятствовать их неконтролируемому росту.</span></p> <p><span> <a></a>Средство контроля автоматического роста файлов удобно использовать во многих случаях. Просто убедитесь в том, что вы не задали случайно неконтролируемый рост файла, что может привести к использованию этим файлом всего дискового пространства вашей системы.</span></p> <p><b><span>Контрольные точки</span></b></p> <p><span> SQL Server выполняет операции с контрольными точками автоматически. Частота создания контрольных точек автоматически рассчитывается в соответствии со значением, которые вы задали для параметра конфигурирования SQL Server recovery interval. Этот параметр указывает длительность вашего ожидания в минутах при восстановлении базы данных после аварии системы. Контрольные точки создаются достаточно часто, чтобы время восстановления системы не превысило указанного вами значения в минутах. Кроме того, контрольные точки автоматически создаются при отключении SQL Server с помощью оператора SHUTDOWN или Service Control Manager (Диспетчер управления службами). Вы можете также создавать контрольные точки вручную с помощью оператора CHECKPOINT.</span></p> <p><span>Если вы хотите, чтобы система работала оптимальным образом и если вы готовы подождать подольше, то можете задать для параметра recovery interval достаточно большое значение, например, 60. Это означает, что при аварии вашей системы автоматическое восстановление будет занимать до 60 минут. При создании контрольных точек выполняется большое количество операций записи на диск, а они могут отбирать часть ресурсов обработки у пользовательских транзакций, увеличивая время отклика на запросы пользователей. Вот почему менее частое создание контрольных точек может помочь в повышении производительности по транзакциям в целом. Конечно, слишком большое значение параметра может приводить к слишком длительному простою после аварии. Обычно для recovery intervalзадают значение от 5 до 15 (минут).</span></p> <p><span>По умолчанию для recovery interval задано значение 0. Это значение указывает, что SQL Server будет определять наилучшие моменты создания контрольных точек, исходя из загруженности системы. Обычно при использовании этого значения по умолчанию контрольные точки создаются приблизительно раз в минуту. Если вы считаете, что они создаются слишком часто, то можете изменить значение recovery interval. Чтобы определить, не слишком ли часто SQL Server создает контрольные точки, используйте флаг трассировки SQL Server -T3502. Это флаг указывает запись информации по контрольным точкам в журнал ошибок SQL Server. Отметим, что контрольные точки создаются по каждой базе данных.</span></p> <p style="text-align: center;"><b><span>Планы обслуживания баз данных</span></b></p> <p><span> План обслуживания – это набор задач, которые SQL Server будет автоматически выполнять по вашим базам данных согласно заданному вами расписанию. Целью плана обслуживания является автоматизация важных административных задач и снижение объема ручной работы DBA. Вы можете создавать отдельный план для каждой базы данных, несколько планов для одной базы данных или один план для нескольких баз данных.</span></p> <p><span>Имеются четыре следующие основные категории административных задач, которые вы можете планировать путем создания плана обслуживания:</span></p> <p><span>Оптимизации.</span></p> <p><span>Проверки целостности.</span></p> <p><span>Резервное копирование баз данных.</span></p> <p><span>Резервное копирование журнала транзакций.</span></p> <p><span>Выполнение этих задач имеет важное значение для поддержки хорошо работающей и восстанавливаемой базы данных. Типы оптимизационных задач, которые вы включите в ваш план, будут зависеть от производительности и степени использования вашей базы данных. Выполнение проверок целостности является хорошим средством, чтобы обеспечить согласованность и сохранность базы данных. А регулярное резервное копирование требуется для того, чтобы обеспечить восстанавливаемость базы данных в случае аварии системы или пользовательских ошибок. В силу особой важности операций резервного копирования вам следует разработать стратегию автоматизированного резервного копирования. Мы подробно рассмотрим каждую из этих категорий задач в данном разделе.</span></p> <p><span>Для создания плана обслуживания используется мастер Database Maintenance Plan Wizard. В данном разделе вы узнаете, как использовать этот мастер, а затем узнаете, как выводить на экран задания плана обслуживания и как редактировать этот план.</span></p> <p><span>Использование мастера Database Maintenance Plan Wizard для создания плана обслуживания</span></p> <p><span>Для использования мастера Database Maintenance Plan Wizard выполните следующие шаги.</span></p> <p><span>Запустите этот мастер из Enterprise Manager с помощью одного из следующих методов. </span></p> <p><span>Выберите из меню Tools пункт Database Maintenance Planner (Планировщик обслуживания баз данных).</span></p> <p><span>Щелкните на имени базы данных в левой панели и затем щелкните на New Maintenance Plan (Новый план обслуживания) под заголовком Maintenance (Обслуживание) в правой панели. Если вы не видите заголовка Maintenance, убедитесь в том, что у вас выбран пункт Taskpad (Панель задач) в меню View (Вид) Enterprise Manager. Возможно, вам придется также выполнить прокрутку, чтобы увидеть заголовок Maintenance.</span></p> <p><span>Щелкните на имени базы данных, выберите пункт Wizards (Мастера) из меню Tools, раскройте в появившемся диалоговом окне Select Wizard (Выбор мастера) папку Management (Управление) и затем выберите Database Maintenance Plan Wizard.</span></p> <p><span>Раскройте сервер в левой панели, раскройте папку Management, щелкните правой кнопкой мыши на Database Maintenance Plans (Планы обслуживания баз данных) и затем выберите из появившегося контекстного меню пункт New Maintenance Plan.</span></p> <p><span>Щелкните правой кнопкой мыши на имени соответствующей базы данных, выберите пункт All Tasks (Все задачи) и затем выберите из этого меню Maintenance Plan.</span></p> <p><span>Открыв мастер, вы увидите начальное окно мастера Database Maintenance Plan Wizard </span></p> <p><span> Щелкните на кнопке Next (Далее), чтобы появилось окно Select Databases (Выбор баз данных). Здесь вы можете выбрать базу или базы данных, для которых хотите создать план обслуживания. </span></p> <p><span> <a></a>Щелкните на кнопке Next, чтобы появилось окно Update Data Optimization Information (Обновление информации по оптимизации данных). Вы можете выбирать следующие типы оптимизации для базы или баз данных, выбранных на предыдущем шаге. </span></p> <p><b><span>Reorganize data and index pages (Реорганизация страниц данных и индексов). </span></b><span>Этот флажок указывает, что все индексы и все таблицы базы данных будут удалены и воссозданы с использованием указанного коэффициента заполнения (или количества свободного места на каждой странице), что может повысить производительность обновлений. В случае таблиц, предназначенных только для чтения, реорганизация страниц не является необходимостью. В случае таблиц, для которых часто выполняются вставки или изменения, свободное место, которое первоначально было доступно на ваших индексных страницах, постепенно заполняется, и начинает происходить фрагментация страниц. Установите этот флажок, чтобы выполнить повторное создание ваших индексов и образовать свободное место для будущего роста во избежание задержек и нагрузок, вызываемых фрагментацией страниц. </span></p> <p><span>Вы можете выбрать между повторным созданием индексов с исходным количеством свободного места или указать новый процент свободного места на одну страницу. Если задать слишком большой процент, то вы рискуете снизить производительность операций чтения. Установив этот флажок, вы не можете установить следующий флажок – Update statistics used by query optimizer.</span></p> <p><span> <b>Update statistics used by query optimizer (Обновление статистики, используемой оптимизатором запросов)</b> При установке этого флажка SQL Server выполнит перерасчет статистики распределения по всем индексам в соответствующей базе данных. SQL Server использует эту информацию для выбора оптимального плана исполнения для запросов. Если вы не изменили принятый по умолчанию параметр для обновления статистики (рассмотренный выше в этой лекции), то SQL Server автоматически генерирует статистику путем выборки небольшого процента данных в таблице, соответствующей каждому индексу. </span></p> <p><span>Флажок этого окна можно использовать для того, чтобы SQL Server выполнял выборку с использованием большего процента данных (указанного вами) или чтобы задать частоту, с которой SQL Server должен обновлять эту статистику, вместо автоматического выбора частоты в SQL Server. Чем больше процент выборки данных, тем точнее будет статистика, но при этом SQL Server потратит больше времени. Эта информация может помочь в повышении производительности при интенсивном изменении данных в индексируемых колонках. Вы можете проверить используемый план исполнения для ваших запросов с помощью анализатора запросов SQL Query Analyzer, чтобы определить, насколько эффективно используются индексы и насколько необходима установка данного флажка. Установив этот флажок, вы не сможете установить предыдущий флажок.</span></p> <p><b><span>Remove unused space prom database files (Удалить неиспользуемое пространство из файлов базы данных)</span></b><span> Этот флажок применяется для удаления неиспользуемого пространства; этот процесс также известен как уплотнение (сжатие) файла (file shrink). Вы можете задать, насколько большим должно стать неиспользуемое пространство, чтобы произошло сжатие файла, а также процент пространства, которое должно остаться свободным после сжатия. Удалив свободное пространство, вы можете использовать DBCC SHRINKFILE для снижения размера данного файла. Если нужно, вы можете сделать его меньше, чем при первоначальном создании. Это позволит использовать для других целей дисковое пространство, которое раньше было занято файлом. Кроме того, сжатие файла за счет удаления неиспользуемого пространства может повысить производительность. В случае таблиц, предназначенных только для чтения, реорганизация страниц не является необходимостью. </span></p> <p><span>Вы можете задать время, за которое должны выполняться эти задачи, щелкнув на кнопке Change (Изменить) и введя новое расписание в появившемся диалоговом окне Edit Recurring Job Schedule (Редактировать расписание повторяющихся заданий). Эти задачи следует выполнять в периоды небольшой загруженности системы, например, в выходные дни или ночью, поскольку это требует определенного времени и может увеличивать время отклика на запросы пользователей.</span></p> <p><span> Щелкните на кнопке Next, чтобы появилось окно Database Integrity Check (Проверка целостности базы данных. </span></p> <p><a></a><span>В этом окне вы можете указать, нужно ли выполнять проверку целостности. При проверке целостности проверяется размещение и структурная целостность таблиц и индексов (если индексы включены в проверку) с помощью команды DBCC CHECKDB. Вы можете указывать, будут ли включаться в проверку индексы, будет ли SQL Server пытаться устранить небольшие проблемы (рекомендуется устанавливать этот флажок) и должны ли все эти проверки целостности выполняться перед резервным копированием. Если вы указали, что выполнение проверок должно происходить перед резервным копированием, то в случае обнаружения какой-либо проблемы это резервное копирование выполняться не будет. Щелкните на кнопке Change, чтобы изменить время, когда будут выполняться эти задачи. Проверка целостности может занимать несколько часов в зависимости от размера ваших баз данных, поэтому следите за тем, чтобы они не планировались на периоды интенсивного использования баз данных. Проверки должны проводиться регулярно, возможно, ежемесячно или еженедельно, или перед резервным копированием баз данных.</span></p> <p><span>Щелкните на кнопке Next, чтобы появилось окно Specify the Database Backup Plan (План резервного копирования баз данных). В этом окне вы указываете, будет ли создаваться план автоматизированного резервного копирования. (Рекомендуется создавать такой план.) Чтобы активизировать автоматическое резервное копирование, установите флажок Back up the database as part of the maintenance plan (Выполнять резервное копирование как часть плана обслуживания). Вы можете указать для SQL Server проверку целостности резервной копии по окончании копирования. SQL Server выполняет это для подтверждения того, что резервная копия создана полностью и все тома резервной копии доступны. Вы можете также указывать, где должна храниться резервная копия – на ленте или диске. Щелкните на кнопке Change, чтобы изменить время, когда будет выполняться резервное копирование. </span></p> <p><span> <a></a>Щелкните на кнопке Next, чтобы появилось окно Specify Backup Disk Directory (Дисковая директория для резервной копии). </span></p> <p><a></a><span>Это окно появляется, только если вы задали в предыдущем окне резервное копирование на диск; оно не появится, если вы задали резервное копирование на ленту. В этом окне вы можете задать местоположение файла резервной копии или использовать принятую по умолчанию директорию для резервной копии. Если у вас несколько баз данных, для которых выполняется резервное копирование (таких как master, model, msdb), то вы можете выбрать размещение резервной копии каждой базы данных в ее собственной поддиректории, чтобы поддерживать определенную организацию файлов резервных копий. Вы можете выбрать автоматическое удаление файлов резервных копий по истечении определенного срока хранения, чтобы освобождалось пространство на дисках, а также можете задавать расширение имен файлов, которое хотите использовать для файлов резервных копий.</span></p> <p><span>Щелкните на кнопке Next, чтобы появилось окно Specify the Transaction Log Backup Plan (План резервного копирования журнала транзакций). </span></p> <p><a></a><span> </span><span>Это окно устроено аналогично окну Specify the Database Backup Plan, но параметры этого окна используются для создания плана резервного копирования журнала транзакций. Резервное копирование журнала транзакций должно происходить между резервными копированиями вашей базы данных. Для восстановления любых изменений, выполненных с момента последнего резервного копирования базы данных, используется резервная копия журнала транзакций. Иначе говоря, резервные копии журнала транзакций позволяют вам восстанавливать данные между резервными копированиями базы данных. </span></p> <p><span>Если у вас выбрано сохранение резервных копий на диске, то следующим будет окно Specify Backup Disk Directory, в котором вы задаете информацию о местоположении файла резервной копии.</span></p> <p><span> </span><span>Щелкните на кнопке Next, чтобы появилось окно Reports to Generate (Генерируемые отчеты). В этом окне вы можете выбрать создание отчета, содержащего результаты выполнения задач плана обслуживания. Этот отчет содержит подробности выполненных шагов и любые возникшие ошибки. В этом окне вы также задаете местоположение для сохранения отчета, а также можете задать удаление отчетов через определенный период времени и отправку отчета по электронной почте указанным адресатам. </span></p> <p><a></a><span>Щелкните на кнопке Next, чтобы появилось окно Maintenance History (Журнал обслуживания) (см. рисунок). Здесь вы можете выбрать запись отчета с журналом (историей) обслуживания в таблицу базы данных на локальном сервере и задать максимальный размер этого отчета. Вы можете также указать запись этого отчета на удаленный сервер и задать максимальный размер этого отчета.</span></p> <p><span>Щелкните на кнопке Next, чтобы появилось окно Completing the Database Maintenance Plan Wizard (Завершение работы мастера создания плана обслуживания баз данных). В этом окне показана сводка вашего плана обслуживания. План получит имя по умолчанию, но вы можете задать другое имя, набрав его в текстовом поле Plan Name (Имя плана). Проверьте эту сводку и пройдите в обратном направлении, если хотите изменить какие-то параметры. Если план вас устраивает, щелкните на кнопке Finish (Готово). </span></p> <p style="text-align: center;"><b><span> <a></a><a></a>Отображение заданий плана обслуживания</span></b></p> <p><span> Для нашего примера плана обслуживания мы создали по одной задаче в каждой из четырех категорий. Чтобы увидеть список этих заданий (запланированных задач), раскройте папку Management в левой панели Enterprise Manager, раскройте агент SQL Server Agent и затем щелкните на строке Jobs (Задания).</span></p> <p style="text-align: center;"><b><span> Редактирование плана обслуживания</span></b></p> <p><span> Чтобы отредактировать план обслуживания, щелкните в левой панели Enterprise Manager на имени базы данных, для которой создан план обслуживания, и затем выберите имя этого плана под заголовком Maintenance в правой панели. Возможно, вам потребуется выполнить прокрутку, чтобы увидеть заголовок Maintenance. Появится диалоговое окно Database Maintenance Plan.</span></p> <p><span>Во вкладке General вы можете указывать, какие базы данных будет затрагивать ваш план обслуживания. В других вкладках вы можете изменять значения параметров, которые сконфигурировали с помощью мастера Database Maintenance Plan Wizard. Закончив редактирование плана, щелкните на кнопке OK. Ваш план теперь начнет выполняться в соответствии с указанным вами расписанием.</span></p> <p style="text-align: center;"><b><span> 15.5. Администрирование MySQL</span></b></p> <p><span> </span><span>С развитием систем баз данных процедуры инсталляции и использования MySQL становятся все проще. Судя по всему, именно простота работы с MySQL стала основной причиной широкой ее популярности среди пользователей. Особенно это относится к тем из них, которые не являются, да и не желают быть программистами. Безусловно, знания компьютерного профессионала могут оказаться весьма полезными, но для успешного использования MySQL быть опытным программистом вовсе не обязательно.</span></p> <p><span>Однако и полностью без управления MySQL работать также не может. Администратор должен хотя бы иногда проверять согласованность и эффективность ее работы и знать, что делать при возникновении проблем. Вся эта информация представлена далее</span></p> <p><span>Уже имеющие опыт работы администраторы могут заметить, что администрирование MySQL подобно администрированию других систем управления базами данных. Опыт администрирования других систем просто неоценим. В то же время, администрирование MySQL имеет свои уникальные особенности.</span></p> <p style="text-align: center;"><span> </span></p> <p style="text-align: center;"><span> </span><b><span>Обзор задач администрирования</span></b></p> <p><span> СУБД MySQL состоит из нескольких основных компонентов. Знание их сути и предназначения поможет лучше понять природу управляемой системы и принципы работы различных ее средств. Настоятельно рекомендуется потратить немного времени, чтобы хорошенько разобраться в представленном далее материале. Это значительно упростит дальнейшую работу. В частности, необходимо вникнуть в следующие аспекты работы MySQL. </span></p> <p><i><span>Сервер </span></i><span>MySQL<i>.</i> Сервер mysqld выполняет все операции с базами данных и таблицами. Для запуска сервера, мониторинга его работы и перезапуска в случае сбоя применяется программа safe_mysqld (демон)</span></p> <p><i><span>Клиентские программы и утилиты</span></i><span> MySQL. Для взаимодействия с сервером и выполнения ряда административных задач используются различные программы MySQL, наиболее важными среди которых являются следующие:</span></p> <p><span>mysql. Интерактивная программа, позволяющая отправлять SQL-запросы на сервер и просматривать результаты их выполнения.</span></p> <p><span>mysqladmin. Административная программа, позволяющая выполнять такие операции, как завершение работы сервера, создание и удаление баз данных. Эту же программу можно применять для проверки состояния сервера, если что-то в его работе не так. </span></p> <p><span>isamchk или myisamchk. Утилиты, предназначенные для анализа и оптимизации таблиц, а также восстановления их в случае повреждения.</span></p> <p><span>mysqldump. Средство резервирования баз данных или их копирования на другой сервер.</span></p> <p><span>SQL <i>- язык сервера.</i> Некоторые задачи администрирования можно выполнить только с помощью утилиты командной строки mysqladmin. Иногда гораздо эффективней справиться с задачей может администратор, который может "общаться" с сервером на его языке. Предположим, что необходимо проверить, почему привилегии пользователя работают вовсе не так, как ожидается. Напрямую "поговорить" с сервером на человеческом языке, к сожалению, нельзя. Зато можно воспользоваться программой-клиентом mysql и послать SQL-запрос для анализа таблиц разрешений.</span></p> <p><span>Незнакомым с операторами SQL пользователям следует разобраться по крайней мере в базовых принципах их работы. Незнание SQL - достаточно серьезное препятствие, и время, затраченное на изучение этого языка, окупится очень быстро. Конечно, чтобы стать настоящим "знатоком SQL", придется напряженно учиться и достаточно долго практиковаться. Познакомиться же с основами этого языка можно за весьма короткий промежуток времени.</span></p> <p><i><span>Каталог данных</span></i><span> MySQL. Каталог данных используется сервером для хранения баз данных и файлов состояния. Важно понимать структуру и содержимое каталога данных, чтобы знать, как сервер представляет свои базы данных и таблицы в файловой системе, где хранятся различные файлы (например, регистрационные) и что в них содержится. Необходимо также уметь управлять распределением дискового пространства, чтобы избежать переполнения раздела с каталогом данных.</span></p> <p style="text-align: center;"><span> </span><b><span>Общее администрирование</span></b></p> <p><span> Общее администрирование включает в себя в основном работу с демоном mysqld, сервером MySQL и обеспечение доступа пользователей. К наиболее важным задачам общего администрирования относятся следующие. </span></p> <p><i><span>Запуск и остановка сервера.</span></i><span> Администратор должен уметь запускать и останавливать сервер вручную из командной строки и настраивать автоматический запуск и завершение работы. Важно также знать, как восстановить работу сервера в случае сбоя или некорректного функционирования.</span></p> <p><i><span>Поддержка учетных записей пользователей</span></i><span>. Администратор должен отчетливо понимать разницу между пользователями MySQL и пользователями UNIX и Windows, а также уметь настраивать учетные записи пользователей MySQL. Такая настройка зачастую заключается в определении, какие пользователи и с какого компьютера смогут подключаться к серверу. Новым пользователям необходимо, кроме всего прочего, сообщить свои параметры подключения, чтобы успешно настроить обмен данными с сервером. Настройка учетных записей — это задача администратора, а не пользователей!</span></p> <p><i><span>Поддержка регистрационных файлов.</span></i><span> Администратор должен знать, регистрационные файлы каких типов необходимо проверять и поддерживать, а также каким образом и когда выполнять эти операции. Последовательный просмотр и замена регистрационных журналов позволит избежать переполнения ими используемых дисков.</span></p> <p><i><span>Резервирование и копирование баз данных.</span></i><span> Резервирование баз данных— исключительно важная операция, позволяющая в случае необходимости восстановить работу системы после сбоя. Желательно, конечно, чтобы имелась возможность восстановить базы данных до того состояния, в котором они находились перед сбоем. В этом случае потеря данных будет минимальной. Заметьте, однако, что резервирование баз данных отличается от резервирования информации всей системы, выполняемой, например, с помощью UNIX-программы dump. В процессе активной работы сервера файлы таблиц базы данных, как правило, подвергаются изменениям. Восстановление файлов, зарезервированных в какой-то определенный момент времени, не позволит в полной мере восстановить базу данных, т.е. потеря определенной части данных неизбежна. Более полезными для восстановления базы данных являются файлы, сгенерированные программой mysqldump. С ее помощью можно выполнять резервирование без предварительного завершения работы сервера.</span></p> <p><span>Иногда возникает необходимость в запуске СУБД на более быстродействующем главном компьютере или в создании копии базы данных. В этом случае все содержимое ее каталога можно скопировать на другой компьютер. Администратор должен уметь выполнять и эту процедуру. Файлы баз данных могут зависеть от конфигурации конкретной системы, поэтому простое копирование файлов не сможет дать достаточно удовлетворительных результатов. </span></p> <p><i><span>Настройка сервера.</span></i><span> Пользователи всегда хотят, чтобы сервер работал максимально быстро. Самый быстрый и неэкономный метод повышения производительности сервера — приобретение и установка большего объема памяти и более быстрых дисков. Разбираться в работе сервера при применении подобных методов вовсе необязательно. Администратору необходимо знать, какие параметры применяются для настройки работы сервера и как их значения повлияют на ситуацию. Одни клиенты пользуются запросами в основном для выборки необходимой информации из баз данных, другие — в основном для добавления и обновления информации. Поэтому решение об изменении значений тех или иных параметров зачастую определяется типом запросов, отправляемых к узлу.</span></p> <p><i><span>Установка нескольких серверов.</span></i><span> В некоторых случаях возникает необходимость в запуске сразу нескольких серверов. Она может определяться желанием протестировать работу новой версии MySQL перед полным переходом на нее или обеспечить более высокий уровень защиты для отдельных групп и пользователей. (Последний вариант, в частности, относится к провайдерам интернет-услуг.) В таких ситуациях администратор должен знать, как установить и настроить несколько одновременно работающих инсталляций.</span></p> <p><i><span>Обновление MySQL.</span></i><span> Новые версии MySQL появляются достаточно часто. Администратор должен знать, как обновить старую версию для устранения найденных ошибок программного кода и добавления новых возможностей. Следует также понимать, что иногда имеет смысл воздержаться от обновления, а также уметь выбирать между официальными (стабильными) и тестовыми версиями этого программного продукта.</span></p> <p style="text-align: center;"><b><span> Безопасность</span></b></p> <p><span> В процессе инсталляции MySQL важно также обеспечить надежную защиту хранимых данных. Администратор MySQL полностью отвечает за предоставление доступа к каталогам данных и серверу и должен разбираться в следующих вопросах.</span></p> <p><i><span>Защита файловой системы.</span></i><span> В ОС UNIX могут поддерживаться несколько учетных записей пользователей, не обладающих полномочиями администратора MySQL. Необходимо проверить, чтобы эти пользователи не имели доступа к каталогам данных. Это позволит защититься от несанкционированного копирования или удаления таблиц баз данных либо чтения регистрационных файлов с критически важной информацией. Администратор должен знать, как настроить учетные записи пользователей UNIX для сервера MySQL, как сделать каталог данных доступным только для владельца и как определить привилегии пользователей сервера.</span></p> <p><i><span>Защита сервера.</span></i><span> Знание принципов работы системы безопасности MySQL поможет правильно настроить пользовательские учетные записи и полномочия доступа. Подключающиеся через сеть к серверу пользователи должны обладать правами доступа только к самой необходимой информации. Полное игнорирование системы безопасности может обернуться предоставлением прав администратора анонимному пользователю.</span></p> <p style="text-align: center;"><b><span> Отладка и поддержка баз данных</span></b></p> <p><span> В душе каждый администратор MySQL надеется избежать повреждения или полного разрушения таблиц баз данных. Однако одних надежд мало. Выполнение определенных процедур позволит минимизировать риск сбоя и оказаться более подготовленным к негативному развитию событий. </span></p> <p><i><span>Восстановление после сбоя.</span></i><span> Сбой может разрушить результаты даже самых успешных действий, поэтому администратор должен обязательно знать, как отладить и восстановить таблицы баз данных. Восстановление после сбоя — это процесс, выполняемый весьма редко. Однако он очень неприятен и, как правило, сопровождается пребыванием администратора в стрессовом состоянии (которое может еще более усугубляться постоянными звонками и стуком в дверь.) Для восстановления применяются средства проверки и восстановления - isamchk и myisamchk. Необходимо обязательно научиться восстанавливать информацию из резервных файлов и использовать записи регистрационных журналов для восстановления всех изменений, внесенных с момента последнего резервирования.</span></p> <p><i><span>Превентивная поддержка</span></i><span>. Для снижения вероятности повреждения или разрушения баз данных следует постоянно применять программы превентивной поддержки. Необходимо также выполнять и резервирование, хотя, конечно, выполнение мер превентивной поддержки снижает возможность их использования.</span></p> <p><i><span>Запуск сервера MySQL непривилегированным пользователем. </span></i><span>Прежде чем приступить к рассмотрению процедуры запуска сервера, давайте обсудим, какие пользователи могут выполнить подобный запуск. Сервер может запускаться вручную или автоматически. В первом случае сервер запускается в качестве пользователя, под именем которого зарегистрирован администратор, запускающий сервер (или другой сотрудник). Другими словами, если администратор зарегистрирован под именем пользователя paul и запускает сервер, то сервер будет работать с правами пользователя paul. Если затем администратор с помощью команды su авторизуется в качестве пользователя root и запустит сервер, сервер будет работать с правами пользователя root.</span></p> <p><span>Однако всегда запускать сервер вручную весьма неудобно. Лучше всего настроить его на автоматический запуск во время загрузки системы. На UNIX-компьютерах процедура запуска выполняется системой с помощью UNIX-пользователя root, соответственно, все процессы, запускаемые во время этой процедуры, работают впоследствии с привилегиями пользователя root.</span></p> <p><span>Администратору следует помнить о двух целях, преследуемых при настройке процедуры запуска сервера MySQL. </span></p> <p><span>Желательно, чтобы сервер не обладал привилегиями пользователя root. В большинстве случаев рекомендуется ограничивать возможности всех процессов, не требующих прав доступа root. He нужны эти права и демону mysqld.</span></p> <p><span>Желательно, чтобы сервер все время работал под именем одного и того же пользователя. Весьма нелогично запускать сервер в разное время под именами разных пользователей, поскольку в этом случае файлы и каталоги с данными будут создаваться разными владельцами. В определенный момент времени это может привести к невозможности получения доступа к базам данных или таблицам. Постоянный запуск сервера от имени одного пользователя позволит избежать этой проблемы. </span></p> <p><span>Для запуска сервера под обычным пользователем, не обладающим широкими правами, выполните следующие действия.</span></p> <p><span>Выберите учетную запись, предназначенную для запуска сервера. Демон mysqld может работать от имени любого пользователя, однако лучше создать для него отдельную учетную запись. Можно также создать специальную группу для работы с MySQL. Предположим, что такой пользователь и группа уже созданы и имеют имена mysqladm и mysqlgrp. Пользователям, определившим другие имена для этих целей, придется подставлять их далее в примерах кода вместо mysqladm и mysqlgrp.</span></p> <p><span>Если же MySQL был установлен под каким-либо пользователем, не обладающим специальными правами администратора, сервер наверняка будет запускаться под собственным именем этого пользователя. В этом случае необходимо заменить mysqladm и mysqlgrp соответствующим регистрационным именем и именем группы.</span></p> <p><span>Если же система MySQL инсталлировалась под управлением ОС Linux Red Hat с помощью RPM-файла, в процессе установки автоматически создается учетная запись с именем mysql. Ее в последующих примерах этой лекции нужно применять вместо mysqladm.</span></p> <p><span>Создайте, если необходимо, учетную запись сервера, используя обычную процедуру создания учетных записей системы. Для этого необходимо сначала авторизоваться в качестве пользователя root.</span></p> <p><span>Завершите работу сервера, если он работает.</span></p> <p><span>Измените права доступом к каталогу данных, а также всех его подкаталогов и файлов, чтобы новым владельцем этих элементов оказался пользователь mysqladm. Например, чтобы сделать пользователя mysqladm владельцем каталога данных /usr/local/var, необходимо ввести следующие команды (авторизовавшись в качестве пользователя root).</span></p> <p><span> </span></p> <p><span># cd /usr/local/var. Переход в каталог данных. </span></p> <p><span># chown -R mysqladm.mysqlgrp. </span></p> <p><span> </span></p> <p><span>Измените полномочия доступа к каталогу данных и всем его подкаталогам и файлам, чтобы работать с ними мог только пользователь mysqladm. Запретите доступ к данным всем остальным пользователям — это самая эффективная мера предосторожности. Если каталог данных размешается в директории /usr/local/var, определить права доступа на него для пользователя mysqladm можно с помощью следующих команд (авторизовавшись в качестве пользователя root).</span></p> <p><span> </span></p> <p><span># cd /usr/local/var. Переход в каталог данных. </span></p> <p><span># chmod -R go-rwx. </span></p> <p><span> </span></p> <p><span> Устанавливая права доступа и режим для каталога данных и его содержимого, не забудьте просмотреть символические связи. Нужно обязательно переместиться в каталоги, на которые эти связи указывают, и изменить права доступа для их содержимого. На этом этапе могут возникнуть проблемы, если содержащий все связанные файлы каталог не принадлежит владельцу каталога данных. Единственный способ решения таких проблем — авторизоваться в качестве пользователя root.</span></p> <p><span>По завершении вышеприведенной процедуры следует убедиться в нормальном запуске сервера, предварительно авторизовавшись в качестве пользователя mysqladm или root. В последнем случае обязательно нужно определить опцию --user=mysqladm, чтобы пользователь мог переключить ID-номер своего компьютера на mysqladm (что также реализуется в процессе запуска системы).</span></p> <p><span>Опция --user была добавлена в mysql в версии MySQL 3.22. В более ранних версиях для этих же целей можно использовать команду su, которая указывает системе, работающей под управлением пользователя root, что запускать сервер необходимо с учетной записью другого пользователя. Настоятельно рекомендуется заглянуть в справочное руководство и ознакомиться с синтаксисом команды su, поскольку он может видоизменяться для отдельных пользователей.</span></p> <p style="text-align: center;"><b><span> Методы запуска сервера</span></b></p> <p><span> После определения учетной записи, которая будет применяться для работы сервера, можно приступать к выбору способа запуска. Сервер можно запускать вручную из командной строки или автоматически в процессе загрузки системы. Существуют три основных метода запуска сервера.</span></p> <p><i><span>Непосредственный вызов</span></i><span> mysqld. Это, возможно, самый распространенный метод. Поэтому подробно рассматриваться далее он не будет. Достаточно лишь заметить, что в случае необходимости можно использовать команду mysqld --help для определения опций с другими методами запуска. </span></p> <p><i><span>Вызов сценария</span></i><span> safemysqld. Этот сценарий в процессе своей работы пытается определить местоположение программы сервера и каталога данных, а затем запускает сервер с соответствующими опциями. Сценарий safemysqld записывает все сообщения об ошибках сервера в специальный файл ошибок, расположенный в каталоге данных. Кроме того, safemysqld следит за нормальной работой сервера и в случае сбоя перезагружает его. Этот сценарий наиболее часто применяется в BSD-версиях UNIX.</span></p> <p><i><span>Вызов сценария</span></i><span> mysql.server. Этот сценарий запускает сервер посредством запуска сценария safemysqld. Сценарий mysql.server предназначен для использования на компьютерах с системой запуска/завершения работы System V. Данная система включает несколько каталогов со сценариями, вызываемыми при входе или выходе с определенного уровня работы. С помощью соответствующих аргументов start и stop можно определить, что делать дальше: запустить сервер или остановить его работу.</span></p> <p><span>Сценарий safemysqld располагается в подкаталоге bin каталога инсталляции MySQL. Его же можно найти в каталоге scripts дистрибутива MySQL. Сценарий mysql.server можно отыскать в подкаталоге share/mysql каталога инсталляции или каталоге support-files исходной дистрибуции MySQL. Для использования эти сценарии необходимо скопировать в соответствующие каталоги запуска. </span></p> <p><span>В ОС BSD-UNIX довольно часто используются несколько специальных файлов, которые располагаются в каталоге /etc и инициируют службы во время запуска. Как правило, имена таких файлов начинаются с приставки "rc". Файл rc.local (или имеющий подобное название), например, предназначен специально для запуска локальных служб. Для запуска сервера в подобных системах необходимо добавить в файл rc.local следующие строки (подставив правильный путь к сценарию safe_mysqld):</span></p> <p><span> </span></p> <p><span>if [ -x /usr/local/bin/safe_mysqld ]; then /usr/local/bin/safe_mysqld & fi</span></p> <p><span> </span></p> <p><span> </span><span>В системах System V для инсталляции сценария mysql.server достаточно разместить его в подкаталоге /etc каталога запуска. Это наверняка уже сделано, если Linux или MySQL инсталлировались с помощью RPM-файла. Если нет, инсталлируйте сценарий в основной каталог сценариев запуска и установите связи с ним в каталогах уровней запуска. Можно также сделать так, чтобы сценарии запускались только пользователем root.</span></p> <p><span>Структура каталогов с файлами запуска может изменяться от системы к системе, поэтому рекомендуется внимательно просмотреть, как эти файлы организованы в используемом компьютере. Например, в системе LinuxPPC для запуска применяются каталоги /etc/rc.d/init.d и etc/rc.d/rc3.d. Соответственно, инсталляция сценария выполняется с помощью следующих команд: </span></p> <p><span> </span></p> <p><span># </span><span>ср</span><span> mysql.server /etc/rc.d/init.d </span></p> <p><span># cd /etc/init.d </span></p> <p><span># chmod 500 mysql.server </span></p> <p><span># cd /etc/rc.d/rc3.d </span></p> <p><span># ln -s ../init.d/mysql.server S99mysql</span></p> <p><span> </span></p> <p><span>В ОС Solaris основной каталог сценариев — /etc/init.d, а каталог уровня запуска — /etc/rc2.d, поэтому набор команд инсталляции выглядит следующим образом:</span></p> <p><span> </span></p> <p><span># </span><span>ср</span><span> mysql.server /etc/init.d </span></p> <p><span># cd /etc/init.d </span></p> <p><span># chmod 500 mysql.server </span></p> <p><span># cd /etc/rc2.d </span></p> <p><span># ln -s ../init.d/mysql.server S99mysql </span></p> <p><span> </span></p> <p><span>Эти команды обеспечивают автоматический запуск сценария S99mysql с аргументом start в процессе загрузки системы.</span></p> <p><span>Если имеется возможность использования команды chkconfig (часто применяемой под управлением Linux), ее также можно применить для инсталляции сценария mysql.server. В этом случае от ручного ввода приведенных выше команд можно отказаться.</span></p> <p style="text-align: center;"><span> </span><b><span>Определение опций запуска</span></b></p> <p><span> Существует два способа определения дополнительных опций запуска, которые применяются при загрузке сервера. Во-первых, можно изменить используемый сценарий запуска (safemysqld или mysql.server) и задать параметры непосредственно в строке вызова сервера. Во-вторых, можно определить параметры собственно в конфигурационном файле. Профессионалы рекомендуют по возможности использовать для этих целей глобальные конфигурационные файлы. В системах UNIX и Windows этими файлами обычно являются /etc/my.cnf.</span></p> <p><span>Однако есть информация, которую невозможно задать в конфигурационных файлах. Для ее определения необходимо изменить сценарий safemysqld. Так, например, если сервер неправильно считал установки временного пояса и возвращает значения времени в формате GMT (времени по Гринвичу), можно для подсказки установить переменную среды TZ. Если сервер запускается с помощью сценария safemysqld или mysql.server, установку временного пояса можно добавить в safemysqld. Отыщите строку запуска сервера и перед ней добавьте следующие команды:</span></p> <p><span> </span></p> <p><span>TZ=US/Central </span></p> <p><span>export TZ</span></p> <p><span> </span></p> <p><span> Эти команды устанавливают часовой пояс центральной части Соединенных Штатов. Пользователям же необходимо аналогичным образом задать свой часовой пояс. Подобный синтаксис для переменной TZ применяется в системе Solaris. В других системах он может быть другим, например, таким:</span></p> <p><span> </span></p> <p><span> </span></p> <p><span> </span></p> <p><span>TZ=CST6CDT </span></p> <p><span>export TZ</span></p> <p><span> </span></p> <p><span> Следует помнить, что после повторной инсталляции MySQL (например, при обновлении версии) все внесенные в сценарий запуска изменения будут потеряны. В таком случае необходимо сперва скопировать сценарий в другую папку, а после инсталляции сравнить оба сценария (старый и вновь инсталлированный) и добавить отсутствующие параметры.</span></p> <p style="text-align: center;"><b><span> Проверка таблиц во время запуска</span></b></p> <p><span> Помимо настройки автоматического запуска сервера в процессе загрузки системы, можно также инсталлировать сценарий, который будет запускать утилиты myisamchk и isamchk. Это позволит проверять таблицы перед запуском сервера. В некоторых случаях перезагрузка сервера выполняется после сбоя, в результате которого таблицы могут оказаться поврежденными. Проверка таблиц перед запуском сервера — отличный способ предотвратить будущие проблемы.</span></p> <p><span>Завершение работы сервера. Для самостоятельного завершения работы сервера применяется команда mysqladmin:</span></p> <p><span> </span></p> <p><span>% mysqladmin shutdown </span></p> <p><span> </span></p> <p><span> Автоматическое завершение работы сервера также не требует выполнения каких-либо специальных действий. В UNIX BSD работа служб обычно завершается посредством отправки процессам сигнала TERM. Службы либо соответствующим образом на него отвечают, либо просто закрываются. Сервер mysqld, например, на получение такого сигнала реагирует закрытием. В системах System V, запуск сервера в которых производится с помощью сценария mysql.server, процедура завершения работы реализуется посредством вызова этого же сценария, но с аргументом stop. При этом, конечно же, предполагается, что сценарий mysql.server инсталлирован.</span></p> <p style="text-align: center;"><b><span> Когда нельзя подключиться к серверу</span></b></p> <p><span> В некоторых случаях возникает необходимость в самостоятельной перезагрузке сервера из-за невозможности подключения к нему. Честно говоря, получается какой-то парадокс, поскольку обычно для завершения работы сервера необходимо сначала подключиться к нему, а затем дать указание на остановку. Как же может возникнуть подобная ситуация? Во-первых, администратор может не знать пароля MySQL-пользователя root. Иногда это случается, когда при изменении пароля случайно введен лишний символ или пароль просто забыт.</span></p> <p><span>Во-вторых, подключение к компьютеру localhost обычно осуществляется через сокет ОС UNIX, которым, как правило, является /tmp/mysql.sock. Удаление этого файла делает невозможным подключение клиентов. Такая ситуация, в свою очередь, может возникнуть после запуска процесса сron, который удаляет временные файлы из каталога /tmp.</span></p> <p><span>Если подключиться нельзя из-за отсутствия файла разъема, проблему можно легко решить посредством простой перезагрузки сервера. В процессе запуска он пересоздаст этот файл. Проблема заключается в том, что использовать этот разъем для установления соединения с сервером нельзя. Для этого необходимо установить соединение TCP/IP. Например, если сервер запускается на компьютере с адресом viper.snake.net, подключиться к нему можно с помощью следующей команды:</span></p> <p><span> </span></p> <p><span>% mysqladmin -p -u root -h pit-viper.snake.net shutdown </span></p> <p><span> </span></p> <p><span> </span><span>Если файл разъема удален в результате работы задания программы остановки, проблема может возникнуть снова. Чтобы избежать этого, настройте программу остановки на использование другого файла разъема. Это можно осуществить с помощью глобального конфигурационного файла. Так, например, если /usr/local/var — каталог данных, для перемещения в него файла разъема достаточно добавить следующие строки в файл /etc/my.cnf:</span></p> <p><span> </span></p> <p><span>[mysqld] </span></p> <p><span>socket=/usr/local/var/mysql.sock </span></p> <p><span> [client] </span></p> <p><span>socket=/usr/local/var/mysql.sock</span></p> <p><span> </span></p> <p><span> </span><span>Как видите, имя файла и путь к нему одинаковы как для сервера, так и для клиентских программ, в результате чего все они используют один файл разъема. Можно определить новый путь только для сервера, благодаря чему клиентские программы будут искать этот файл по старому адресу. Перезапустите сервер после внесения изменений, чтобы создать файл разъема в новой позиции.</span></p> <p><span>Иногда администратор не может подключиться к серверу из-за того, что забыл пароль пользователя root или в процессе изменения случайно присвоил ему не то значение, которое предполагал. В этом случае необходимо восстановить контроль над сервером, чтобы заново установить пароль. Это можно сделать следующим образом: </span></p> <p><span>Завершите работу сервера. Авторизовавшись как пользователь root на компьютере с сервером, администратор может завершить работу сервера с помощью команды kill. Используя команду ps, можно отыскать ID-номер процесса сервера. С этой же целью можно просмотреть PlD-файл, который обычно располагается в каталоге данных. </span></p> <p><span>Лучше сначала попытаться завершить работу сервера с помощью обычной команды kill, чем сразу посылать серверу сигнал term и проверять, правильно ли он отреагировал на нее, завершив работу. В этом случае все таблицы и журналы будут обработаны и закрыты корректно. Если в работе сервера не все нормально и он не отвечает на сигнал завершения работы, можно воспользоваться командой kill -9 для принудительного закрытия. Однако к ее помощи следует прибегать в самую последнюю очередь, поскольку в этом случае существует риск оставить таблицы поврежденными.</span></p> <p><span>Если работа сервера все же была завершена с помощью команды kill -9, настоятельно рекомендуется перед следующим запуском сервера проверить таблицы с помощью команд myisamchk и isamchk.</span></p> <p><span> <b>Перезапустите сервер с помощью параметра</b> --skip-grant-tables. Это укажет серверу не использовать таблицы разрешений для проверки соединений и позволит подключиться с полномочиями пользователя root без пароля. После удачного подключения измените пароль пользователя root без пароля.</span></p> <p><b><span>Используя команду</span></b><span> mysqladmin flush-privileges<b>, укажите серверу снова перезагрузиться, но с применением таблиц разрешений.</b> Если используемая версия mysqladmin не поддерживает опцию flush-privileges, попробуйте воспользоваться командой reload.</span></p> <p><span> </span><span>В обязанности администратора MySQL входит также создание и настройка учетных записей пользователей MySQL. В процессе этой настройки необходимо определить, какие пользователи будут иметь возможность подключения к серверу, откуда они смогут подключиться и что смогут делать после подключения. Два появившихся в MySQL 3.22.11 оператора упрощают эту задачу. Оператор GRANT создает пользователей MySQL и позволяет настроить их привилегии. Оператор REVOKE удаляет привилегии. Эти два оператора являются своего рода внешним интерфейсом для таблиц разрешений базы данных mysql и обеспечивают альтернативу непосредственному редактированию содержимого этих таблиц. Операторы grant и revoke работают с четырьмя следующими таблицами.</span></p> <p><span> </span></p> <table border="1" cellspacing="0" cellpadding="0" style="margin:0 auto;"> <tr> <td width="140" valign="top"> <p style="text-align: center;"><b><span>Таблица</span></b></p> <p style="text-align: center;"><b><span> разрешений</span></b></p> </td> <td width="499" valign="top"> <p style="text-align: center;"><b><span>Содержимое</span></b></p> </td> </tr> <tr> <td width="140" valign="top"> <p style="text-align: center;"><span>user</span></p> </td> <td width="499" valign="top"> <p style="text-align: center;"><span>Подключающиеся к серверу пользователи и все их глобальные привилегии</span></p> </td> </tr> <tr> <td width="140" valign="top"> <p style="text-align: center;"><span>db</span></p> </td> <td width="499" valign="top"> <p style="text-align: center;"><span>Привилегии уровня базы данных</span></p> </td> </tr> <tr> <td width="140" valign="top"> <p style="text-align: center;"><span>tables_priv</span></p> </td> <td width="499" valign="top"> <p style="text-align: center;"><span>Привилегии уровня таблицы</span></p> </td> </tr> <tr> <td width="140" valign="top"> <p style="text-align: center;"><span>columns_priv</span></p> </td> <td width="499" valign="top"> <p style="text-align: center;"><span>Привилегии уровня столбца</span></p> </td> </tr> </table> <p><span> </span></p> <p><span>Существует еще одна, пятая таблица разрешений (host), однако операторы grant и revoke не в состоянии ее обрабатывать.</span></p> <p><span>Если оператор GRANT запускается для определенного пользователя, в таблице user для него создается новая запись. Если оператор определяет для пользователя какие-либо глобальные привилегии (привилегии администратора или привилегии, применяемые сразу ко всем базам данных), они также записываются в таблицу user. Права обработки базы данных, таблицы или столбца записываются соответственно в таблицы db, tables_priv и column_priv.</span></p> <p><span>Применять операторы grant и revoke проще, чем непосредственно редактировать таблицы разрешений. </span></p> <p><span>Роль этих таблиц действительно велика, и администратор должен понимать, каким образом их обрабатывают операторы GRANT и REVOKE. </span></p> <p><span>Далее в этой лекции рассказывается, как создавать учетные записи пользователей MySQL, присваивать или удалять их привилегии, а также полностью удалять пользователей из таблиц разрешений. В конце лекции описана также одна связанная с привилегиями "головоломка", которая может завести в тупик многих начинающих администраторов MySQL.</span></p> <p><span>Некоторые пользователи захотят также познакомиться со сценариями mysqlaccess и mysql_setpermission, которые являются частью дистрибуции MySQL. Они представляют собой Perl-сценарии и обеспечивают альтернативу оператору grant, поскольку применяются для установки пользовательских учетных записей. Для использования сценария mysql_setpermission требуется инсталляция поддержки DBI. </span></p> <p><span>Создание новых пользователей и предоставление привилегий. Оператор GRANT имеет следующий синтаксис:</span></p> <p><span> </span></p> <p><span>GRANT privileges (columns) </span></p> <p><span>ON what </span></p> <p><span>TO user IDENTIFIED BY "password"</span></p> <p><span>WITH GRANT OPTION </span></p> <p><span> </span></p> <p><span>Для успешного его выполнения обязательно нужно правильно определить следующую информацию: </span></p> <p><span>privileges (привилегии). Привилегии присваиваются определенному пользователю. Используемые в операторе grant спецификаторы привилегий описаны в представленной ниже таблице.</span></p> <table border="1" cellspacing="0" cellpadding="0" style="margin:0 auto;"> <tr> <td valign="top"> <p style="text-align: center;"><b><span>Спецификатор привилегий</span></b></p> </td> <td valign="top"> <p style="text-align: center;"><b><span>Разрешенная операция</span></b></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>user</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Подключающиеся к серверу пользователи и все их глобальные привилегии</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>alter</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Изменение таблиц и индексов</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>create</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Создание баз данных и таблиц</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>delete</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Удаление существующих записей из таблиц</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>drop</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Удаление баз данных и таблиц</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>index</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Создание и удаление индексов</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>insert</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Вставка новых записей в таблицы</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>references</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>He используется</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>select</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Извлечение существующих записей из таблиц</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>update</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Изменение существующих записей таблиц</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>file</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Чтение и запись файлов сервера</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>process</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Просмотр информации о внутренних потоках сервера и их удаление</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>reload</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Перезагрузка таблиц разрешений или обновление журналов, кэша компьютера или кэша таблицы</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>shutdown</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Завершение работы сервера</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>all</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Все операции. Аналог — all privileges</span></p> </td> </tr> <tr> <td valign="top"> <p style="text-align: center;"><span>usage</span></p> </td> <td valign="top"> <p style="text-align: center;"><span>Полное отсутствие привилегий</span></p> </td> </tr> </table> <p><span> </span></p> <p><span>Спецификаторы привилегий, входящие в первую группу этой таблицы, применяются к базам данных, таблицам и столбцам. Спецификаторы второй группы определяют административные привилегии. Как правило, они применяются довольно редко, поскольку позволяют пользователю влиять на работу сервера. (Не каждому пользователю, например, необходима привилегия shutdown.) В третью группу входят два отдельных спецификатора: спецификатор ALL предоставляет "все привилегии", a USAGE означает "полное отсутствие привилегий". В последнем случае создается новый пользователь, не обладающий никакими правами;</span></p> <p><span>columns (столбцы). Столбцы, к которым применяются определенные привилегии. Этот параметр необязателен и используется только при установке привилегий для столбцов. Имена нескольких столбцов отделяются друг от друга запятыми;</span></p> <p><span>what (что). Уровень применения привилегий. Привилегии могут быть глобальными (применяемыми ко всем базам данных и их таблицам), уровня баз данных (применяемыми ко всем таблицам определенной базы данных) или уровня таблицы. Используя оператор columns, можно определить также привилегии уровня столбца;</span></p> <p><span>user (пользователь). Пользователь, которому присваиваются привилегии. В некоторых версиях MySQL необходимо указывать как имя пользователя, так и компьютер, с которого он сможет подключаться. Такой способ задания легко позволяет определить двух пользователей с одинаковым именем, но подключающихся с разных компьютеров. Возможности MySQL позволяют их различать и наделять различными правами.</span></p> <p><span>Имя пользователя в некоторых версиях MySQL представляет собой имя, используемое при подключении к серверу. Оно вовсе не обязательно должно быть связано с именем регистрации в ОС UNIX или Windows. Если имя пользователя MySQL не определено явным образом, клиентские программы по умолчанию применяют его в качестве регистрационного имени, однако это необязательно. Не существует также каких-либо особых требований, чтобы суперпользователь MySQL, обладающий максимальными правами, имел имя root. По желанию его можно изменить в таблицах разрешений на nobody, если для выполнения определенных операций требуются его полномочия;</span></p> <p><span>password (пароль). Присвоенный пользователю пароль, который не является обязательным. Если для нового пользователя опустить выражение IDENTIFIED BY, пароль ему присвоен не будет (что не совсем разумно с точки зрения безопасности). Если же этот оператор задается для уже существующего пользователя, введенный пароль заменит используемый до настоящего момента. Старый пароль останется неизменным, если новый не будет определен. Строка пароля, задаваемая с помощью выражения IDENTIFIEDBY, должна представлять собой буквенную строку, которую при записи зашифрует оператор grant. Поэтому не следует применять функцию password(), применяемую с оператором SET password.</span></p> <p><span>Оператор with grant option является необязательным. С его помощью можно предоставить пользователю все привилегии, определенные оператором GRANT для других пользователей. Этот оператор можно использовать для делегирования возможностей определенных категорий другим пользователям.</span></p> <p><span>В именах пользователей, баз данных, таблиц и паролях, записываемых в таблицу разрешений, строчные буквы отличаются от заглавных. Регистр в именах компьютеров и столбцов таблиц не учитывается.</span></p> <p><span>Чтобы определиться, какую же форму оператора GRANT применить, достаточно ответить на следующие вопросы.</span></p> <p><span>Кто и откуда может подключаться к серверу?</span></p> <p><span>Какой уровень привилегий должен иметь пользователь и на доступ к чему эти привилегии предоставляются?</span></p> <p><span>Необходимо ли пользователю предоставлять административные привилегии?</span></p> <p><span>Давайте попробуем ответить на эти вопросы и рассмотрим примеры оператора grant для создания учетных записей пользователей MySQL.</span></p> <p style="text-align: center;"><b><span>Кто и откуда может подключаться к серверу</span></b></p> <p><span> Администратор может разрешить пользователю подключаться как с определенного компьютера, так и с различных компьютеров. В первом случае, если точно известно, что пользователи будут подключаться только со своих компьютеров, можно предоставить им такой доступ с помощью следующих операторов:</span></p> <p><span> </span></p> <p><span>GRANT ALL ON samp_db.* TO boris@localhost IDENTIFIED BY "ruby"</span></p> <p><span>GRANT ALL ON samp_db.* TO fred@ares.mars.net IDENTIFIED BY "quartz"</span></p> <p><span>GRANT ALL ON samp_db.* TO max@% IDENTIFIED BY "diamond"</span></p> <p><span> </span></p> <p><span> </span><span>Символ "%" заменяет все возможные значения адресов и выполняет те же функции, что и при сравнении с помощью оператора LIKE. В предыдущем примере его можно условно заменить фразой "любой компьютер". Установка символа "%" аналогична простому опусканию части, задающей компьютер. Другими словами, эквивалентными в данном примере выступят записи max и mах@%. Это самый простой и, в то же время, самый незащищенный способ создать пользователя.</span></p> <p><span>В случае необходимости можно также разрешить пользователю подключаться с ограниченного числа компьютеров. Так, чтобы пользователь mаrу мог подключаться с компьютеров домена snake.net, достаточно воспользоваться спецификатором %.snake.net: </span></p> <p><span>GRANT ALL ON samp_db.* TO mary@%.snake.net IDENTIFIED BY "topaz" </span></p> <p><span> </span></p> <p><span> </span><span>Для определения компьютера можно применять не только имена, но и IP-адреса. Эти адреса можно задавать явно либо с помощью вспомогательных символов. Кроме того, в версии MySQL 3.23 появилась возможность определять IP-адреса, задавая маску сети, устанавливая число разрядов в сетевом номере:</span></p> <p><span> </span></p> <p><span>GRANT ALL ON samp_db.* TO joe@192.168.128.3 IDENTIFIED BY "water" </span></p> <p><span>GRANT ALL ON samp_db.* TO ardis@192.168.128.% IDENTIFIED BY "snow" </span></p> <p><span>GRANT ALL ON samp_db.* TO rex@192.168 .128.0/17 IDENTIFIED BY "ice"</span></p> <p><span> </span></p> <p><span>Первый оператор определяет только один компьютер, с которого может подключиться пользователь joe. Второй определяет набор IP-адресов для подсети класса С 192.168.128. В третьем операторе часть 192.168.128.0/17 определяет 17-разрядный сетевой номер и соответствует любому компьютеру с адресом 192.168.128 в первых 17 разрядах IP-адреса.</span></p> <p><span>Если MySQL отказывается принимать определенные пользовательские значения, попробуйте заключить их в кавычки (необходимо отдельно заключать в кавычки имя пользователя и компьютера):</span></p> <p><span> </span></p> <p><span>GRANT ALL ON samp_db.psident TO "my_friend"@"boa.snake.net" </span></p> <p style="text-align: center;"><b><span>Какой уровень привилегий должен иметь пользователь и на доступ к чему эти привилегии предоставляются</span></b></p> <p><span> Администратор может предоставлять пользователям привилегии разных уровней. Наиболее мощными являются глобальные привилегии, применяемые ко всем базам данных. Так, например, чтобы предоставить пользователю ethel права суперпользователя, который может делать все, в том числе и предоставлять привилегии другим пользователям, необходимо запустить следующий оператор:</span></p> <p><span> </span></p> <p><span>GRANT ALL ON *.* </span><span>ТО</span><span> ethel@localhost IDENTIFIED BY "coffee" </span></p> <p><span> </span><span>WITH GRANT OPTION </span></p> <p><span> </span></p> <p><span> Спецификатор *. * в предложении ON можно условно заменить фразой "все базы данных и все таблицы". Для повышения безопасности подключаться пользователю ethel разрешено только с одного локального компьютера. Ограничение компьютеров, с которых может подключаться к серверу обладающий широкими правами пользователь, — весьма мудрое решение. В этом случае ограничивается и число компьютеров, с которых могут быть предприняты попытки взлома пароля.</span></p> <p><span>Некоторые привилегии (FILE, process, reload и shutdown) являются административными и могут присваиваться только с помощью спецификатора глобальных привилегий ON *.*. В случае необходимости их можно присваивать без предоставления привилегий на уровне базы данных. Так, например, приведенный ниже оператор создает пользователя flush, который обладает возможностью только выполнять операторы FLUSH. Это может оказаться полезным в административных сценариях, когда необходимо выполнить обновление журналов: </span></p> <p><span> </span></p> <p><span>GRANT RELOAD ON *.* </span><span>ТО</span><span> flush@localhost IDENTIFIED BY "flushpass" </span></p> <p><span> </span></p> <p><span> </span><span>В общем, как уже отмечалось ранее, административные привилегии присваиваются довольно редко, поскольку наделенные ими пользователи могут влиять на работу сервера.</span></p> <p><span>Привилегии уровня базы данных применяются ко всем таблицам определенной базы. Такие привилегии присваиваются с помощью предложения ON db name: </span></p> <p><span> </span></p> <p><span>GRANT ALL ON samp_db.* </span><span>TO bill@racer.snake.net IDENTIFIED BY "rock" </span></p> <p><span>GRANT SELECT ON menagerie.* TO ro_user@% IDENTIFIED BY "dirt"</span></p> <p><span> </span></p> <p><span>Первый из указанных операторов предоставляет пользователю bill все права для работы со всеми таблицами базы данных sampdb. Второй оператор создает пользователя rouser с ограниченными правами (только чтение), который может получать доступ к любой таблице базы данных menagerie, однако только для чтения. Другими словами, этот пользователь имеет возможность запускать только оператор select.</span></p> <p style="text-align: center;"><b><span> Как определить имя локального компьютера в таблице разрешений</span></b></p> <p><span> Довольно часто пользователи не могут подключиться к серверу с основного компьютера (на котором инсталлирован сервер) из-за того, что вместо имени localhost указывают имя сервера. Эта проблема возникает по причине использования разных способов определения имен, записанных в таблицах разрешений и выдаваемых программам. Если процедура сервера выдает неполное имя, например, pit-viper, а в таблицах разрешений записано полное имя pit-viper.snake.net (или наоборот), то подключение становится невозможным. </span></p> <p><span>Чтобы определить, существует ли такая проблема на используемом компьютере, попытайтесь подключиться к локальному серверу с помощью опции -h, устанавливающей имя компьютера. Затем загляните в общий учетный файл сервера. Какое имя компьютера в нем записано, полное или неполное? Неважно, какая форма применяется. Важно использовать для определения имени компьютера в операторе grant именно это имя.</span></p> <p><span>При задании оператора GRANT можно задавать сразу несколько привилегий одновременно. Так, например, если необходимо предоставить пользователю возможность считывать и изменять содержимое существующих таблиц, но запретить создавать новые таблицы или удалять уже существующие, это можно сделать следующим образом:</span></p> <p><span> </span></p> <p><span>GRANT SELECT, INSERT, DELETE, UPDATE ON samp_db.* TO jennie@% </span></p> <p><span> IDENTIFIED BY "boron"</span></p> <p><span> </span></p> <p><span> </span><span>Для еще более детального управления доступом можно предоставлять привилегии отдельным таблицам или даже отдельным их столбцам. Привилегии столбцам оказываются особенно полезными, если определенную часть таблицы необходимо скрыть от пользователя либо предоставить возможность изменения только заданных столбцов. Предположим, что какая-то фирма нанимает на определенный период времени сотрудника, который будет выполнять роль секретаря. Администратор решает предоставить новому сотруднику права доступа только для чтения таблицы member, содержащей информацию о действующих членах общества, и привилегию update столбцу expiration (срок окончания членства) этой таблицы. При таком доступе новый секретарь вполне сможет изменять даты окончания членства организаций-участников, если они продолжают свое членство. Для создания такого пользователя MySQL можно использовать следующие операторы:</span></p> <p><span> </span></p> <p><span>GRANT SELECT ON samp_db.member TO assistant@localhost IDENTIFIED </span></p> <p><span> </span><span>BY "officehelp" </span></p> <p><span>GRANT UPDATE (expiration) ON samp_db.member TO assistant@localhost </span></p> <p><span> </span></p> <p><span> </span><span>Первый оператор предоставляет права на чтение всей таблицы member и определяет пароль. Второй оператор добавляет привилегию update, но только для столбца expiration. Поскольку пароль устанавливается первым оператором, во втором его определять повторно вовсе не обязательно.</span></p> <p><span>Если необходимо присвоить привилегии для работы с несколькими столбцами, их имена следует разделить запятыми. Так, например, чтобы добавить привилегии UPDATE для полей адресов таблицы member для пользователя assistant, используется приведенный ниже оператор. При его выполнении новые привилегии будут добавлены к уже существующим привилегиям пользователя:</span></p> <p><span> </span></p> <p><span>GRANT UPDATE (street,city,state,zip) ON samp_db.member </span></p> <p><span> </span><span>TO assistant@localhost </span></p> <p><span> </span></p> <p><span> Как правило, пользователю не предоставляются большие привилегии, чем это нужно для работы. Иногда, тем не менее, возникает необходимость в предоставлении пользователям возможности создавать таблицы, чтобы заносить в них промежуточные результаты. Желательно, чтобы эти таблицы создавались не в рабочей базе данных, поскольку пользователи могут случайно изменить ее содержимое. Эту задачу можно решить посредством создания отдельной базы данных (назовем ее tmp) и предоставлению пользователям всех возможных привилегий для работы с ней.</span></p> <p><span>Чтобы разрешить всем пользователям домена mars.net использовать базу данных tmp, достаточно ввести следующий оператор grant:</span></p> <p><span> </span></p> <p><span>GRANT ALL ON tmp.* TO "@%.mars.net </span></p> <p><span> </span></p> <p><span> </span><span>После его выполнения пользователи смогут создавать и ссылаться на таблицы базы данных tmp с помощью имен типа tmp.tbl_name.</span></p> <p><i><span>Нужны ли пользователю административные привилегии.</span></i><span> Администратор может предоставить владельцу базы данных возможность управления доступом, предоставив ему все привилегии базы данных и определив опцию WITH GRANT OPTION. Например, чтобы разрешить пользователю alicia подключаться с любого компьютера домена bigcorp.com и предоставить ему административные привилегии для работы со всеми таблицами базы данных sales, необходимо использовать оператор grant следующего вида:</span></p> <p><span> </span></p> <p><span>GRANT ALL ON sales.* TO alicia@%.big-corp.com IDENTIFIED BY "applejuice" </span></p> <p><span> </span><span>WITH GRANT OPTION</span></p> <p><span> </span></p> <p><span> Фактически, предложение with grant OPTION позволяет администратору делегировать права разрешения доступа другому пользователю. Однако следует проявлять осторожность, поскольку два пользователя с привилегиями grant могут предоставлять другим пользователям свои права. Если предоставить одному пользователю только привилегию SELECT, а второму, помимо select, привилегию GRANT, второй пользователь легко может сделать первого "более сильным".</span></p> <p><span> </span></p> <p style="text-align: center;"><b><span>Отмена привилегий и удаление пользователей </span></b></p> <p><span> Для отмены привилегий пользователя применяется оператор revoke. Его синтаксис очень похож на синтаксис оператора GRANT с той лишь разницей, что предложение ТО заменено на предложение FROM, а предложения IDENTIFIED BY и WITH GRANT OPTION отсутствуют вовсе:</span></p> <p><span> </span></p> <p><span>REVOKE privileges (columns) ON what FROM user </span></p> <p><span> </span><span>Часть user этого оператора должна соответствовать части user исходного оператора GRANT для пользователя, привилегии которого отменяются. Часть privileges необязательно должна соответствовать ранее определенным привилегиям. Пользуясь оператором revoke, можно отменить только некоторые из привилегий, предоставленные оператором GRANT.</span></p> <p><span>Оператор revoke применяется для отмены привилегий, но не для удаления пользователей. В таблице user все равно остается запись для пользователя, даже если все привилегии для него сняты. Это означает, что пользователь все еще имеет возможность подключаться к серверу. Для полного удаления пользователя необходимо явным образом удалить его запись из таблицы user. Для</span><span> </span><span>этих</span><span> </span><span>целей</span><span> </span><span>применяется</span><span> </span><span>оператор</span><span> DELETE:</span></p> <p><span> </span></p> <p><span>% mysql -u root mysql </span></p> <p><span>mysql> DELETE FROM user WHERE User = "user_name" and Host = "host_name"; </span></p> <p><span>mysql> FLUSH PRIVILEGES; </span></p> <p><span> </span></p> <p><span> Оператор delete удаляет запись пользователя, а оператор FLUSH указывает серверу перезагрузить таблицы разрешений. (Таблицы перезагружаются автоматически при использовании операторов GRANT и revoke. Однако этого не происходит при непосредственном изменении таблиц разрешений.) Из описанной в следующем разделе ситуации вы узнаете, почему иногда лучше отказаться от удаления записей таблицы user.</span></p> <p><span>Головоломка с привилегиями. Довольно часто начинающие администраторы MySQL попадают в следующую весьма запутанную ситуацию. Пытаясь добавить в таблицу разрешений запись для пользователей, они используют в части имени компьютера общий формат, например:</span></p> <p><span> </span></p> <p><span>GRANT ALL ON samp_db.* TO fred@%snake.net IDENTIFIED BY "cocoa"</span></p> <p><span> </span></p> <p><span>Назначение этого оператора — разрешить пользователю fred подключаться к серверу с любого компьютера домена snake.net и предоставить ему все привилегии для работы с базой данных samp_db. В результате пользователь fred получает возможность подключиться с любого компьютера, кроме сервера. Попытка подключиться с сервера завершается выводом сообщения об отклонении доступа даже при предоставлении правильного пароля.</span></p> <p><span>Такая ситуация возникает, если в таблице разрешений содержатся записи, по умолчанию инсталлированные сценарием инициализации mysql_install_db. Причина ее возникновения в том, что при попытке подключения пользователя fred к серверу большим приоритетом перед записью этого пользователя обладает одна из записей анонимного пользователя. Согласно этой записи, для подключения пароль не нужен, однако пользователь fred пытается его ввести. Важно заметить, что для устранения этой проблемы достаточно удалить запись анонимного пользователя из таблицы user. Оператор revoke для этих целей не подходит, поскольку он отменяет только привилегии. Удаление записи выполняется с помощью следующих команд:</span></p> <p><span> </span></p> <p><span>% mysql -u root mysql</span></p> <p><span>mysql> DELETE FROM user where User=""; </span></p> <p><span>mysql> FLUSH PRIVILEGES; </span></p> <p><span> </span></p> <p><span>Сразу после удаления пользователь fred сможет успешно подключиться с локального компьютера.</span></p> <p style="text-align: center;"><b><span>Проверка и восстановление таблиц</span></b></p> <p><span> Повреждения в таблицах MyISAM происходят вследствие событий, которые невозможно избежать. Различные аппаратные сбои могут оказать самое непредсказуемое влияние на базу данных. Например, если жесткий диск выйдет из строя, данные окажутся полностью потерянными. Неожиданное выключение системы из-за сбоя питания может привести к тому, что изменения в таблицу будут внесены не полностью. Даже если уничтожить серверный процесс по команде kill, у него не будет возможности корректно завершить свою работу. </span></p> <p><span>Если найдена поврежденная таблица, потратьте время на выяснение причин, вызвавших повреждение. Вообще говоря, в MySQL таблицы редко оказываются поврежденными.</span></p> <p><span>Существуют два способа проверки и восстановления таблиц. Первый — с помощью специальных инструкций, второй — с помощью утилиты myisamchk. Соответствующие инструкции называются CHECK TABLE, REPAIR TABLE и OPTIMIZE TABLE. Они достаточно удобны, поскольку выполняются в рамках серверного процесса. В этом смысле они ничем не отличаются, к примеру, от инструкции SELECT. Утилита myisamchk обладает рядом дополнительных возможностей, которые в ряде ситуаций оказываются весьма удобными. </span></p> <p><span>Необходимость проверки таблицы может быть вызвана тем, что утилиты, обращающиеся к таблице, начинают себя странно вести. Например, вводимые запросы не завершаются или выдаются неожиданные сообщения об ошибках. Если при обращении к таблице возвращается номер ошибки, воспользуйтесь утилитой perror, которая отображает поясняющее сообщение, соответствующее данному номеру.</span></p> <p><span>Частота проверок базы данных зависит от степени доверия к серверу. Разработчики MySQL рекомендуют делать это хотя бы раз в неделю, но если есть возможность выполнять процедуру проверки каждую ночь, то шансы на заблаговременное обнаружение ошибки возрастают. С помощью демона cron или программы-планировщика можно составить график проверок таким образом, чтобы они запускались в часы наименьшей активности системы. Сохраняйте результаты проверок в журнальном файле или направляйте их самому себе по электронной почте.</span></p> <p><span>Возможно, имеет смысл изменить сценарий safe_mysql таким образом, чтобы при запуске сервера выполнялись инструкции проверки таблиц. Файл, содержащий такие инструкции, задается с помощью опции --init-file. Если повреждения произошли из-за того, что сервер внезапно прекратил работу, они будут немедленно исправлены.</span></p> <p><span>Обработчики таблиц, для которых поддерживаются транзакции, содержат код, позволяющий им восстанавливать таблицы на основании журнальных файлов при запуске сервера. Если возникает сомнение в целостности таблицы, необходимо остановить и повторно запустить сервер.</span></p> <p><span>Таблицы снабжены флагом, указывающим, изменилось ли содержимое таблицы с момента последней проверки. Инструкция CHECK TABLE пропустит неизмененные таблицы при наличии ключевого слова CHANGED. В утилите myisamchk соответствующий режим включается с помощью опции --check-only-changed. Особым образом помечаются также неправильно закрытые таблицы. Чтобы проверить только их, укажите флаг FAST (инструкция CHECK TABLE) или опцию --fast (утилита myisamchk).</span></p> <p><span>По умолчанию утилита myisamchk ищет повреждения только в индексных файлах. В инструкции CHECK TABLE этот режим включается с помощью флага QUICK. Сама инструкция CHECK TABLE по умолчанию проверяет не только индексы, но и неправильные ссылки на удаленные записи. В утилите myisamchk этот режим включается с помощью опции --medium-check. Расширенный режим проверки задается флагом EXTEND и опцией --extended-check. В этом случае будут проверяться все индексируемые значения.</span></p> <p><span>Табличные проверки занимают много времени в случае крупных таблиц, особенно если у них много ключей. Стандартные режимы проверки в обоих методах обеспечивают вполне приемлемую производительность. Более быстрые проверки удобны, когда их нужно запускать регулярно, например по ночам. Расширенные проверки приходят на помощь, если повреждение таблицы очевидно, но обычные проверки его все равно не находят.</span></p> <p><span>В данном случае была создана небольшая таблица и сымитировано в ней повреждение, отредактировав табличные файлы в редакторе. Как видите, таблицу удалось восстановить.</span></p> <p><a></a><span> mysql>CHECK TABLE courses;</span></p> <p><span>+--------------+-------+-----------+---------------------------------------------+</span></p> <p><span>| Table | Op | Msg_type | Msg_text | </span></p> <p><span>+--------------+-------+-----------+---------------------------------------------+</span></p> <p><span>| courses | check | error | Size of indexfile is: 1924 Should be: 2048 |</span></p> <p><span>| test.courses | check | error | corrupt |</span></p> <p><span>+--------------+-------+-----------+---------------------------------------------+</span></p> <p><span>2 rows in set (0.00 sec)</span></p> <p><span> </span></p> <p><span>mysql>REPAIR TABLE courses;</span></p> <p><span>+--------------+--------+-----------+----------+</span></p> <p><span>| Table | Op | Msg_type | Msg_text |</span></p> <p><span>+--------------+--------+-----------+----------+</span></p> <p><span>| test.courses | repair | status | ok |</span></p> <p><span>+--------------+--------+-----------+----------+</span></p> <p><span>1 row in set (0.08 sec) </span></p> <p><span>Таблицы можно проверять, когда сервер запущен. Программа MySQL не будет пытаться их восстановить. Но если обнаруживается поврежденная таблица, программа запрещает потокам обращаться к ней до тех пор, пока таблица не будет восстановлена. Для восстановления требуется получить монопольный доступ к таблице. В этой ситуации служебными инструкциями пользоваться удобнее, чем утилитой myisamchk, так как MySQL сможет заблокировать другие потоки на время восстановления таблицы. Утилита myisamchk может работать таким образом, только если операционная система поддерживает блокировку файлов. В Linux соответствующих функций нет, поэтому перед восстановлением таблиц нужно останавливать сервер.</span></p> <p><span>Инструкция REPAIR TABLE устраняет повреждения в таблице. То же самое делает утилита myisamchk, при наличии опции --recover. Программа MySQL поддерживает три типа процедур восстановления: быструю, обычную и безопасную. В первом случае устраняются лишь проблемы с индексами. Во втором случае исправляется также большинство ошибок в табличном файле. В безопасном режиме таблица проверяется строка за строкой, а индексный файл создается заново. Это наиболее длительная процедура.</span></p> <p><span>При удалении записей из таблицы программа MySQL сохраняет в ней пустые участки, которые повторно задействуются при последующем выполнении инструкций INSERT. Если таблица содержит пустые участки, то перед вставкой записей ее нужно заблокировать. Правда, когда записи вставляются в конец файла данных, программа разрешает другим потокам параллельно осуществлять чтение таблицы.</span></p> <p><span>Таблицы с записями переменной длины неизбежно оказываются фрагментированными. Это происходит, когда обновляемая запись не помещается в отведенном для нее пространстве. В результате снижается производительность операций выборки, поскольку программа вынуждена искать запись в двух и более точках файла. Инструкция OPTIMIZE TABLE удаляет из таблицы пустые участки и осуществляет пересортировку записей. Аналогичные действия выполняет утилита myisamchk при наличии опции --analyze. Инструкция OPTIMIZE TABLE также сортирует индексы (соответствующая опция утилиты myisamchk называется --sort-index).</span></p> <p style="text-align: center;"><b><span>Резервное копирование и восстановление</span></b></p> <p><span> Резервная копия — это образ базы данных в конкретный момент времени. К этому образу можно вернуться в случае непредвиденной потери данных. Резервные копии можно создавать сколь угодно часто. Нужно лишь помнить о том, что это достаточно трудоемкий процесс, продолжительность которого зависит от размера базы данных и скоростных характеристик оборудования. </span></p> <p><span>Создание резервных копий требует от сервера значительных затрат ресурсов, вплоть до того, что работать с другими базами данных станет невозможно. Нужно спланировать этот процесс таким образом, чтобы он приходился на периоды минимальной загруженности сервера. Если используется репликация, то резервные копии лучше создавать на подчиненном сервере.</span></p> <p><span>Если резервная копия была создана в полночь, а сбой базы данных произошел в полдень, половина дневных изменений окажется утерянной. В таком случае может помочь двоичный журнал. В нем фиксируются все изменения базы данных. С помощью утилиты mysqlbinlog можно преобразовать содержимое этого файла в запросы к восстановленной базе данных, которые позволят воссоздать ее состояние на момент сбоя. Таким образом, планируя схему резервного копирования, не забудьте учесть ротацию и архивирование двоичных журналов, чтобы они были синхронизированы с копиями базы данных.</span></p> <p><span>Помните общие правила обращения с резервными копиями. Если они хранятся в той же файловой системе, что и сама база данных, то данные не защищены от сбоев файловой системы. Отсюда правило: копии должны находиться на отдельном носителе. Храните их на перезаписываемом компакт-диске, магнитной ленте или другом жестком диске. Резервные копии могут храниться дома у начальника или администратора компании. Их можно также пересылать по сети в другую систему. С помощью Internet это делать не сложно.</span></p> <p><span>В процессе планирования необходимо предусмотреть тестирование копий и проверку возможности их восстановления на практике. Не ждите, пока случится катастрофа и вам придется учиться восстанавливать архивы. Создайте тестовую среду и потренируйтесь на ней. Можно попробовать восстановить архив во временную пустую базу данных или же воспользоваться более сложной методикой — например, запустить еще один сервер MySQL на другом порту либо на другом компьютере.</span></p> <p><span>В MySQL существуют три основных способа архивирования данных. Первый — это копирование табличных файлов, второй — создание SQL-образов таблиц, третий — создание форматированных текстовых файлов. Первый способ является самым экономным и быстродействующим. Но для таблиц тех типов, которые поддерживают транзакции, последние два способа являются более гибкими. Например, все таблицы InnoDB хранятся в группе больших файлов, поэтому архивы нельзя будет сгруппировать по базам данных или таблицам.</span></p> <p><span>Какой бы метод ни был выбран, не забудьте защитить таблицы от изменений на время резервного копирования. Если копируются табличные файлы, следует остановить сервер. В остальных случаях достаточно поставить блокировки чтения с помощью инструкции LOCK TABLES и выполнить инструкцию FLUSH TABLES. Последняя необходима для того, чтобы все изменения индексов были записаны в таблицы. Наличие блокировок чтения позволит другим потокам параллельно обращаться к таблицам с запросами на выборку.</span></p> <p><span>Инструкции BACKUP TABLE и RESTORE TABLE копируют табличные файлы в указанный каталог. Естественно, серверный процесс должен иметь право записи в этот каталог. Программа MySQL копирует туда файлы с расширениями .frm и .MUD. Индексный файл (.MYI) можно воссоздать на основании первых двух, что позволит сэкономить место в архиве.</span></p> <p><span> <a></a>mysql>BACKUP TABLE dictionary TO '/tm/backup';</span></p> <p><span>+-----------------+--------+-----------+------------------------+</span></p> <p><span>| Table | Op | Msg_type | Msg_text |</span></p> <p><span>+-----------------+--------+-----------+------------------------+</span></p> <p><span>| test.dictionary | backup | status | ok |</span></p> <p><span>+-----------------+--------+-----------+------------------------+</span></p> <p><span>1 rows in set (0.27 sec)</span></p> <p><span> Функции копирования файлов предоставляются операционной системой, поэтому данный способ создания резервных копий является самым быстрым. Таблица dictionary, содержит более 100000 записей, а файл данных занимает почти 3 Мбайт. Как видите, процедура архивирования такой таблицы заняла менее секунды.</span></p> <p><span>Инструкция BACKUP TABLE самостоятельно заботится о блокировании таблиц и очистке табличных буферов. Это означает, что, в отличие от других методов резервного копирования, дополнительные инструкции не нужны.</span></p> <p><span>Инструкция RESTORE TABLE копирует архивные файлы в каталог базы данных и перестраивает индексы. Таблица не должна существовать на момент восстановления. В случае необходимости можно удалить ее с помощью инструкции DROP TABLE или же вручную удалить табличные файлы.</span></p> <p><span>Обратите внимание на то, что процесс восстановления длился гораздо дольше, чем архивирование. Причина в том, что на перестройку индексов уходит много времени.</span></p> <p><a></a><span> </span><span>mysql> RESTORE TABLE dictionary FROM '/tmp/backup';</span></p> <p><span>+-----------------+---------+-----------+--------------------------+</span></p> <p><span>| Table | Op | Msg_type | Msg_text |</span></p> <p><span>+-----------------+---------+-----------+--------------------------+</span></p> <p><span>| test.dictionary | restore | status | ok |</span></p> <p><span>+-----------------+---------+-----------+--------------------------+</span></p> <p><span>1 rows in set (1 min 22.24 sec)</span></p> <p><span> </span><span>Если резервные копии создаются вручную, то в архив можно также включить индексный файл. В этом случае в процессе восстановления таблицы индексный файл будет просто скопирован в каталог базы данных. Тем не менее его всегда можно воссоздать с помощью инструкции REPAIR TABLE. Предположим, таблица dictionary была полностью утеряна. Процесс ее восстановления начнем с копирования frm-файла обратно в каталог базы данных. Создать пустые файлы данных и индексов можно с помощью инструкции TRUNCATE TABLE. Затем необходимо скопировать старый файл данных поверх нового. После этого вводится инструкция REPAIR TABLE. Программа MySQL обнаруживает расхождение в количестве записей и перестраивает индексы.</span></p> <p><span> </span><a></a><span>mysql> REPAIR TABLE dictionary;</span></p> <p><span>+-----------------+---------+-----------+-----------------------------------------+</span></p> <p><span>| Table | Op | Msg_type | Msg_text |</span></p> <p><span>+-----------------+---------+-----------+-----------------------------------------+</span></p> <p><span>| state | repair | warning | number of rows changed from 0 to 104237 |</span></p> <p><span>| test.state | repair | status | ok |</span></p> <p><span>+-----------------+---------+-----------+-----------------------------------------+</span></p> <p><span>2 rows in set (1 min 25.12 sec)</span></p> <p><span> </span><span>Для безопасного создания резервных копий лучше пользоваться специальной программой, чем делать все вручную. С этой целью в дистрибутив MySQL входит Perl-сценарий mysqlhotcopy. Команда ls позволяет убедиться, что все файлы, в том числе индексные, на месте.</span></p> <p><span> </span><a></a><span># mysqlhotcopy mysql /trap/hc</span></p> <p><span>Locked 6 tables in 0 seconds.</span></p> <p><span>Flushed tables(mysql.columns_priv, mysql.db, mysql.func, mysql.host,</span></p> <p><span> mysql.tables_priv, mysql.user) in 0 seconds.</span></p> <p><span>Copying 18 files…</span></p> <p><span>Copying indices for 0 files…</span></p> <p><span>Unlocked tables.</span></p> <p><span>Mysqlhotcopy copied 6 tables |(18 files) in 1 second (1 seconds overall).</span></p> <p><span># ls /tmp/hc/mysql</span></p> <p><span>columns_priv.MYD db.MYD func.MYD host.MYD tables_priv.MYD user.MYD</span></p> <p><span>columns_priv.MYI db.MYI func.MYI host.MYI tables_priv.MYI user.MYI</span></p> <p><span>columns_priv.frm db.frm func.frm host.frm tables_priv.frm user.frm</span></p> <p><span> </span><span>Сценарий mysqlhotcopy блокирует одновременно все таблицы базы данных, после чего очищает табличные буферы и копирует файлы. Сценарий можно запускать во время работы сервера, даже если в этот момент пользователи делают запросы к базе данных. Естественно, пока происходит копирование таблиц, пользователям будет запрещено вносить в них изменения.</span></p> <p><span>Формат табличных файлов понятен только программе MySQL. Если же создать SQL-образы таблиц, то их можно будет перенести в другие СУБД. Кроме того, в некоторых ситуациях полезно просматривать такие SQL-инструкции. Предположим, к примеру, что потеря данных оставалась незамеченной на протяжении нескольких месяцев. Возможно, пользователи удалили какие-то записи и лишь позднее обнаружили, что это было сделано неправильно. Нужно восстановить только удаленные записи, но не известно, когда точно они были удалены. Если резервные копии хранятся в формате SQL, можно просмотреть архивы и поискать, когда последний раз встречались требуемые записи. Недостатком такого способа резервного копирования является то, что процедура восстановления занимает много времени, поскольку программа MySQL вынуждена выполнять каждую инструкцию из архива.</span></p> <p><span>Для создания sql-образа таблицы предназначена утилита mysqldump. Она записывает текст инструкций в поток stdout, поэтому нужно перенаправить результаты ее работы в файл.</span></p> <p><span> He забудьте заблокировать все таблицы для чтения, прежде чем запускать утилиту mysqldump. В противном случае целостность результатов не гарантируется. Предположим, имеется приложение, которое хранит информацию о клиентах и их электронных адресах. Создание учетной записи нового клиента включает добавление записи в таблицу client и последующую вставку одной или нескольких записей в таблицу email_address. Если параллельно с этим создавать резервную копию базы данных, то может оказаться, что в промежутке между созданием образов таблиц client и email_address приложение попытается обновить обе эти таблицы. Доступ к первой таблице будет запрещен, а ко второй — нет. В результате в архиве появятся адреса, не соответствующие ни одной записи таблицы клиентов.</span></p> <p><span>Чтобы восстановить данные из такого архива, достаточно выполнить SQL-сценарий в интерпретаторе mysql. Можно просто перенаправить сценарий на вход этой утилиты или же воспользоваться ее командой source. Интерпретатор выполнит все инструкции сценария так, как если бы они были введены в командной строке.</span></p> <p><span>Утилита mysqldump имеет режим создания текстового образа таблицы. В этом режиме для каждой архивируемой таблицы создаются два файла. Один из них имеет расширение .sql и содержит соответствующую инструкцию CREATE TABLE. Второй файл имеет расширение .txt и содержит записи таблицы, причем для разделения полей применяются символы табуляции<a></a>.</span></p> <p><span> </span><span> </span><span>[/tmp]# mysqldump --verbose --tab=/tmp test dictionary</span></p> <p><span># Connecting to localhost...</span></p> <p><span># Retrieving table structure for table dictionary...</span></p> <p><span># Sending SELECT query... </span></p> <p><span># Disconnecting from localhost... </span></p> <p><span> </span><span>Для восстановления данных из такого архива необходимо сначала создать таблицу, а затем выполнить инструкцию LOAD DATA INFILE, которая вставит записи в таблицу. Стандартный формат файла, создаваемого утилитой mysqldump, соответствует тому формату, который по умолчанию распознается инструкцией LOAD DATA INFILE.</span></p> <p><span> </span><a></a><span>mysql> source /tmp/dictionary.sql</span></p> <p><span>Query OK, 0 rows affected (0.00 sec)</span></p> <p><span>mysql> LOAD DATA INFILE '/tmp/dictionary.txt' INTO TABLE dictionary;</span></p> <p><span>Query OK, 104237 rows affected (1 min 27.70 sec)</span></p> <p><span>Records: 104237 Deleted: 0 Skipped: 0 Warnings: 0 </span></p> <p><span> </span><span>Создать</span><span> </span><span>файл</span><span>, </span><span>понимаемый</span><span> </span><span>инструкцией</span><span> <span>LOAD DATA INFILE, </span></span><span>позволяет</span><span> </span><span>также</span><span> </span><span>инструкция</span><span> <span>SELECT </span></span><span>с</span><span> </span><span>предложением</span><span> <span>INTO. </span></span><span>Схему таблицы необходимо получить другим путем, например с помощью инструкции SHOW CREATE TABLE.</span></p> <p><a></a><span> </span><span>mysql> SELECT * FROM dictionary INTO OUTFILE 'tmp/dictionary.txt';</span></p> <p><span>Query OK, 104237 rows affected (6.42 sec)</span></p> <p><span> </span><span>Один из способов восстановления таблиц заключается в использовании двоичного журнала. Достаточно преобразовать его содержимое в SQL-инструкции и выполнить их. Предварительно необходимо заблокировать все таблицы для записи или отключить всех клиентов от сервера. Преобразование двоичного журнала осуществляется с помощью утилиты mysqlbinlog. Результаты ее работы нужно направить в файл или интерпретатору mysql. Обратите внимание: инструкция SET меняет метку текущего времени сеанса, чтобы дата создания таблицы осталась неизменной. </span></p> <p><span> </span><a></a><span># mysqlbinlog --offset=1 --short-form red-bin.001</span></p> <p><span>use freetime;</span></p> <p><span>SET TIMESTAMP=991767105;</span></p> <p><span>UPDATE session SET LastAction = now() WHERE ID='fNbbnOLBYYlqesqa';</span></p> <p><span>use freetime;</span></p> <p><span>SET TIMESTAMP=991767134;</span></p> <p><span>UPDATE session SET LastAction = now() WHERE ID='fNbbnOLBYYlqesqa';</span></p> <p><span>use freetime;</span></p> <p><span>SET TIMESTAMP=991767134;</span></p> <p><span>DELETE FROM project_view WHERE Project=2 AND User=2;</span></p> <p><span>use freetime;</span></p> <p><span>SET TIMESTAMP=991767135;</span></p> <p><span>INSERT INTO project_view VALUES (2, 2, now());</span></p> <p style="text-align: center;"><b><span> </span></b></p> <p style="text-align: center;"><b><span> </span></b></p> </div> 
 <A HREF="../theory.htm">Оглавление</A>
                <p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>