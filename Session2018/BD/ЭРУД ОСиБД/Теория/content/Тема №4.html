<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Теория по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" >Программа</A> | 
                                                    <strong>Теория</strong>|
                                                  <A HREF="../../Практика/practice.htm">Практика</A>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>

<table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../theory.htm">Оглавление</A>                
<p>&nbsp;</p>
                 <div> <p><a><b><span>Тема 4 Межпроцессорное взаимодействие, мультипроцессорные системы<o:p></o:p></span></b></a></p> <span></span> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>4.1 Понятие «критическая секция»<o:p></o:p></span></b></p> <p><span>Важным понятием синхронизации потоков является понятие «критической секции» программы. <i>Критическая секция </i>– это часть программы, результат выполнения которой может непредсказуемо меняться, если переменные, относящиеся к этой части программы, изменяются другими потоками в то время, когда выполнение этой части еще не завершено. Критическая секция всегда определяется по отношению к определенным <i>критическим данным, </i>при несогласованном изменении которых могут возникнуть нежелательные эффекты. Во всех потоках, работающих с критическими данными, должна быть определена критическая секция. В разных потоках критическая секция состоит в общем случае из разных последовательностей команд.<o:p></o:p></span></p> <p><span>Чтобы исключить эффект гонок по отношению к критическим данным, необходимо обеспечить, чтобы в каждый момент времени в критической секции, связанной с этими данными, находился только один поток. При этом неважно, находится этот поток в активном или в приостановленном состоянии. Этот прием называют <i>взаимным исключением. </i>Операционная система использует разные способы реализации взаимного исключения. Некоторые способы пригодны для взаимного исключения при вхождении в критическую секцию только потоков одного процесса, в то время как другие могут обеспечить взаимное исключение и для потоков разных процессов.<o:p></o:p></span></p> <p><span>Самый простой и в то же время самый неэффективный способ обеспечения взаимного исключения состоит в том, что операционная система позволяет потоку запрещать любые прерывания на время его нахождения в критической секции. Однако этот способ практически не применяется, так как опасно доверять управление системой пользовательскому потоку – он может надолго занять процессор, а при крахе потока в критической секции крах потерпит вся система, потому что прерывания никогда не будут разрешены.<o:p></o:p></span></p> <p><span>Для синхронизации потоков одного процесса прикладной программист может использовать глобальные <i>блокирующие переменные. </i>С этими переменными, к которым все потоки процесса имеют прямой доступ, программист работает, не обращаясь к системным вызовам ОС.<o:p></o:p></span></p> <p><span>Каждому набору критических данных ставится в соответствие двоичная переменная, которой поток присваивает значение 0, когда он входит в критическую секцию, и значение 1, когда он ее покидает. На рисунке 1 показан фрагмент алгоритма потока, использующего для реализации взаимного исключения доступа к критическим данным </span><span>D</span><span> блокирующую переменную </span><span>F</span><span>(</span><span>D</span><span>).<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> <!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:389.25pt;
 height:357.75pt'>
 <v:imagedata src="Тема%20№4.files/image001.png" o:title=""/>
</v:shape><![endif]-->
 <img src="Тема%20№4.files/image002.jpg" v:shapes="_x0000_i1025"> <o:p></o:p></span></p> 

<p style="text-align: center;"><span><o:p> </o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>1 – Реализация критических секций с использованием блокирующих переменных<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> Перед входом в критическую секцию поток проверяет, не работает ли уже какой-нибудь поток с данными </span><span>D</span><span>. Если переменная </span><span>F</span><span>(</span><span>D</span><span>) установлена в 0, то данные заняты и проверка циклически повторяется. Если же данные свободны (</span><span>F</span><span>(</span><span>D</span><span>) = 1), то значение переменной </span><span>F</span><span>(</span><span>D</span><span>) устанавливается в 0 и поток входит в критическую секцию. После того как поток выполнит все действия с данными </span><span>D</span><span>, значение переменной </span><span>F</span><span>(</span><span>D</span><span>) снова устанавливается равным 1.<o:p></o:p></span></p> <p><span>Блокирующие переменные могут использоваться не только при доступе к разделяемым данным, но и при доступе к разделяемым ресурсам любого вида.<o:p></o:p></span></p> <p><span>Если все потоки написаны с учетом вышеописанных соглашений, то взаимное исключение гарантируется. При этом потоки могут быть прерваны операционной системой в любой момент и в любом месте, в том числе в критической секции.<o:p></o:p></span></p> <p><span>Однако следует заметить, что одно ограничение на прерывания все же имеется. Нельзя прерывать поток между выполнением операций проверки и установки блокирующей переменной. Поясним это. Пусть в результате проверки переменной поток определил, что ресурс свободен, но сразу после этого, не успев установить переменную в 0, был прерван. За время его приостановки другой поток занял ресурс, вошел в свою критическую секцию, но также был прерван, не завершив работы с разделяемым ресурсом. Когда управление было возвращено первому потоку, он, считая ресурс свободным, установил признак занятости и начал выполнять свою критическую секцию. Таким образом, был нарушен принцип взаимного исключения, что потенциально может привести к нежелательным последствиям. Во избежание таких ситуаций в системе команд многих компьютеров предусмотрена единая, неделимая команда анализа и присвоения значения логической переменной (например, команды ВТС, </span><span>BTR</span><span> и </span><span>BTS</span><span> процессора </span><span>Pentium</span><span>). При отсутствии такой команды в процессоре соответствующие действия должны реализовываться специальными системными примитивами, которые бы запрещали прерывания на протяжении всей операции проверки и установки.<o:p></o:p></span></p> <p><span>Реализация взаимного исключения описанным выше способом имеет существенный недостаток: в течение времени, когда один поток находится в критической секции, другой поток, которому требуется тот же ресурс, получив доступ к процессору, будет непрерывно опрашивать блокирующую переменную, бесполезно тратя выделяемое ему процессорное время, которое могло бы быть использовано для выполнения какого-нибудь другого потока. Для устранения этого недостатка во многих ОС предусматриваются специальные системные вызовы для работы с критическими секциями.<o:p></o:p></span></p> <p><span>На рисунке 2 показано, как с помощью этих системных вызовов реализовано взаимное исключение в операционной системе </span><span>Windows NT</span><span>. Перед тем как начать изменение критических данных, поток выполняет системный вызов </span><b><span>EnterCriticalSection</span></b><b><span>()</span></b><span>. В рамках этого вызова сначала выполняется, как и в предыдущем случае, проверка блокирующей переменной, отражающей состояние критического ресурса. Если системный вызов определил, что ресурс занят (</span><span>F</span><span>(</span><span>D</span><span>) = 0), он в отличие от предыдущего случая не выполняет циклический опрос, а переводит поток в состояние ожидания (</span><span>D</span><span>) и делает отметку о том, что данный поток должен быть активизирован, когда соответствующий ресурс освободится. Поток, который в это время использует данный ресурс, после выхода из критической секции должен выполнить системную функцию </span><b><span>LeaveCriticalSection</span></b><b><span>(</span></b><span>), в результате чего блокирующая переменная принимает значение, соответствующее свободному состоянию ресурса (</span><span>F</span><span>(</span><span>D</span><span>) = 1), а операционная система просматривает очередь ожидающих этот ресурс потоков и переводит первый поток из очереди в состояние готовности.<o:p></o:p></span></p> <p><span> <!--[if gte vml 1]><v:shape
 id="_x0000_i1026" type="#_x0000_t75" style='width:386.25pt;height:378.75pt'>
 <v:imagedata src="Тема%20№4.files/image003.png" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№4.files/image004.jpg" v:shapes="_x0000_i1026"> <o:p></o:p></span></p> <p style="text-align: center;"><span><o:p> </o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>2 – Реализация взаимного исключения с использованием системных функций входа в критическую секцию и выхода из нее<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Таким образом исключается непроизводительная потеря процессорного времени на циклическую проверку освобождения занятого ресурса. Однако в тех случаях, когда объем работы в критической секции небольшой и существует высокая вероятность в очень скором доступе к разделяемому ресурсу, более предпочтительным может оказаться использование блокирующих переменных. Действительно, в такой ситуации накладные расходы ОС по реализации функции входа в критическую секцию и выхода из нее могут превысить полученную экономию.<o:p></o:p></span></p> <p><span>В </span><span>Windows </span><span>для реализации критических секций используется структура CRITICAL_SECTION, работа с которой осуществляется исключительно через функции Windows, передавая им адрес соответствующего экземпляра этой структуры. Функции сами знают, как обращаться с ее элементами, и гарантируют, что она всегда будет в согласованном состоянии. Обычно структуры CRITICAL_SECTION создаются как глобальные переменные, доступные всем потокам процесса. Есть только два условия, которые надо соблюдать. Структура инициализируется с помощью следующей функции:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>VOID <b>InitializeCriticalSection</b>(PCRITICAL_SECTION </span><i><span>pcs</span></i><span>);</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Эта функция инициализирует элементы структуры CRITICAL_SECTION, на которую указывает параметр <i>pcs</i>. Поскольку вся работа данной функции заключается в инициализации нескольких переменных-членов, она не дает сбоев и поэтому ничего не возвращает (void). <b>InitializeCriticalSection</b> должна быть вызвана до того, как один из потоков обратится к<b>EnterCriticalSection</b>.<o:p></o:p></span></p> <p><span>Удаляет критическую секцию функция <b>DeleteCriticalSection</b>:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>VOID <b>DeleteCriticalSection</b>(PCRITICAL__SECTION </span><i><span>pcs</span></i><span>);</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Она сбрасывает все переменные-члены внутри этой структуры. Естественно, нельзя удалять критическую секцию в тот момент, когда ею все еще пользуется какой-либо поток.<o:p></o:p></span></p> <p><span>Участок кода, работающий с разделяемым ресурсом, начинается вызовом:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>VOID <b>EnterCriticalSection</b>(PCRITICAL_SECTION </span><i><span>pcs</span></i><span>);</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Первое, что делает <b>EnterCriticalSection</b>, – исследует значения элементов структуры CRITICAL_SECTION. Если ресурс занят, в них содержатся сведения о том, какой поток пользуется ресурсом. EnterCriticalSection выполняет следующие действия.<o:p></o:p></span></p> <p><span>Если ресурс свободен, <b>EnterCriticalSection</b> модифицирует элементы структуры, указывая, что вызывающий поток занимает ресурс, после чего немедленно возвращает управление, и поток продолжает свою работу (получив доступ к ресурсу).<o:p></o:p></span></p> <p><span>Если значения элементов структуры свидетельствуют, что ресурс уже захвачен вызывающим потоком, <b>EnterCriticalSection</b> обновляет их, отмечая тем самым, сколько раз подряд этот поток захватил ресурс, и немедленно возвращает управление. Такая ситуация бывает нечасто — лишь тогда, когда поток два раза подряд вызывает <b>EnterCriticalSection</b> без промежуточного вызова <b>LeaveCriticalSection</b>.<o:p></o:p></span></p> <p><span>Если значения элементов структуры указывают на то, что ресурс занял другим потоком, <b>EnterCriticalSection</b> переводит вызывающий поток в режим ожидания. Это потрясающее свойство критических секций: поток, пребывая в ожидании, не тратит ни кванта процессорного времени Система запоминает, что данный поток хочет получить доступ к ресурсу, и – как только поток, занимавший этот ресурс, вызывает <b>LeaveCriticalSection</b> – вновь начинает выделять нашему потоку процессорное время. При этом она передает ему ресурс, автоматически обновляя элементы структуры CRITICAL_SECTION.<o:p></o:p></span></p> <p><span>В конце участка кода, использующего разделяемый ресурс, должен присутствовать вызов:<o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p style="text-align: center;"><span>VOID <b>LeaveCriticalSection</b>(PCRITICAL_SECTION </span><i><span>pcs</span></i><span>);</span><span><o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Эта функция просматривает элементы структуры CRITICAL_SECTION и уменьшает счетчик числа захватов ресурса вызывающим потоком на 1. Если его значение больше 0, LeaveCriticalSection ничего не делает и просто возвращает управление.<o:p></o:p></span></p> <p><span>Если значение счетчика достигло 0, <b>LeaveC</b></span><b><span>r</span></b><b><span>it</span></b><b><span>i</span></b><b><span>calSection</span></b><span> сначала выясняет, есть ли в системе другие потоки, ждущие данный ресурс в вызове <b>EnterCriticalSection</b> Если есть хотя бы один такой поток, функция настраивает значения элементов структуры, что бы они сигнализировали о занятости ресурса, и отдает его одному из ждущих потоков (поток выбирается «по справедливости»). Если же ресурс никому не нужен, LeaveCriticalSection соответственно сбрасывает элементы структуры.<o:p></o:p></span></p> <p><span>Как и <b>EnterCriticalSection</b>, функция <b>LeaveCriticalSection</b> выполняет все действия на уровне атомарного доступа. Однако <b>LeaveCriticalSection</b> никогда не приостанавливает поток, а управление возвращает немедленно.<o:p></o:p></span></p> <p><b><span>4.2 Необходимость и задачи синхронизации потоков<o:p></o:p></span></b></p> <p><span>Существует достаточно обширный класс средств операционной системы, с помощью которых обеспечивается взаимная синхронизация процессов и потоков. Потребность в синхронизации потоков возникает только в мультипрограммной операционной системе и связана с совместным использованием аппаратных и информационных ресурсов вычислительной системы. Синхронизация необходима для исключения гонок и тупиков при обмене данными между потоками, разделении данных, при доступе к процессору и устройствам ввода-вывода.<o:p></o:p></span></p> <p><span>Во многих операционных системах эти средства называются средствами межпроцессного взаимодействия – </span><span>Inter Process Communications</span><span> (</span><span>IPC</span><span>), что отражает историческую первичность понятия «процесс» по отношению к понятию «поток». Обычно к средствам </span><span>IPC</span><span> относят не только средства межпроцессной синхронизации, но и средства межпроцессного обмена данными.<o:p></o:p></span></p> <p><span>Выполнение потока в мультипрограммной среде всегда имеет асинхронный характер. Очень сложно с полной определенностью сказать, на каком этапе выполнения будет находиться процесс в определенный момент времени. Даже в однопрограммном режиме не всегда можно точно оценить время выполнения задачи. Это время во многих случаях существенно зависит от значения исходных данных, которые влияют на количество циклов, направления разветвления программы, время выполнения операций ввода-вывода и т. п. Так как исходные данные в разные моменты запуска задачи могут быть разными, то и время выполнения отдельных этапов и задачи в целом является весьма неопределенной величиной.<o:p></o:p></span></p> <p><span>Еще более неопределенным является время выполнения программы в мультипрограммной системе. Моменты прерывания потоков, время нахождения их в очередях к разделяемым ресурсам, порядок выбора потоков для выполнения – все эти события являются результатом стечения многих обстоятельств и могут быть интерпретированы как случайные. В лучшем случае можно оценить вероятностные характеристики вычислительного процесса, например вероятность его завершения за данный период времени.<o:p></o:p></span></p> <p><span>Таким образом, потоки в общем случае (когда программист не предпринял специальных мер по их синхронизации) протекают независимо, асинхронно друг другу. Это справедливо как по отношению к потокам одного процесса, выполняющим общий программный код, так и по отношению к потокам разных процессов, каждый из которых выполняет собственную программу.<o:p></o:p></span></p> <p><span>Любое взаимодействие процессов или потоков связано с их <i>синхронизацией, </i>которая заключается в согласовании их скоростей путем приостановки потока до наступления некоторого события и последующей его активизации при наступлении этого события. Синхронизация лежит в основе любого взаимодействия потоков, связано ли это взаимодействие с разделением ресурсов или с обменом данными. Например, поток-получатель должен обращаться за данными только после того, как они помещены в буфер потоком-отправителем. Если же поток-получатель обратился к данным до момента их поступления в буфер, то он должен быть приостановлен.<o:p></o:p></span></p> <p><span>При совместном использовании аппаратных ресурсов синхронизация также совершенно необходима. Когда, например, активному потоку требуется доступ к последовательному порту, а с этим портом в монопольном режиме работает другой поток, находящийся в данный момент в состоянии ожидания, то ОС приостанавливает активный поток и не активизирует его до тех пор, пока нужный ему порт не освободится. Часто нужна также синхронизация с событиями, внешними по отношению к вычислительной системе, например реакции на нажатие комбинации клавиш </span><span>Ctrl</span><span>+</span><span>C</span><span>.<o:p></o:p></span></p> <p><span>Ежесекундно в системе происходят сотни событий, связанных с распределением и освобождением ресурсов, и ОС должна иметь надежные и производительные средства, которые бы позволяли ей синхронизировать потоки с происходящими в системе событиями.<o:p></o:p></span></p> <p><span>Для синхронизации потоков прикладных программ программист может использовать как собственные средства и приемы синхронизации, так и средства операционной системы. Например, два потока одного прикладного процесса могут координировать свою работу с помощью доступной для них обоих глобальной логической переменной, которая устанавливается в единицу при осуществлении некоторого события, например выработки одним потоком данных, нужных для продолжения работы другого. Однако во многих случаях более эффективными или даже единственно возможными являются средства синхронизации, предоставляемые операционной системой в форме системных вызовов. Так, потоки, принадлежащие разным процессам, не имеют возможности вмешиваться каким-либо образом в работу друг друга. Без посредничества операционной системы они не могут приостановить друг друга или оповестить о произошедшем событии. Средства синхронизации используются операционной системой не только для синхронизации прикладных процессов, но и для ее внутренних нужд.<o:p></o:p></span></p> <p><span>Обычно разработчики операционных систем предоставляют в распоряжение прикладных и системных программистов широкий спектр средств синхронизации. Эти средства могут образовывать иерархию, когда на основе более простых средств строятся более сложные, а также быть функционально специализированными, например средства для синхронизации потоков одного процесса, средства для синхронизации потоков разных процессов при обмене данными и т. д. Часто функциональные возможности разных системных вызовов синхронизации перекрываются, так что для решения одной задачи программист может воспользоваться несколькими вызовами в зависимости от своих личных предпочтений.<o:p></o:p></span></p> <p><span>Пренебрежение вопросами синхронизации в многопоточной системе может привести к неправильному решению задачи или даже к краху системы. Рассмотрим, например, задачу ведения базы данных клиентов некоторого предприятия (рисунок 3).<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape
 id="_x0000_i1027" type="#_x0000_t75" style='width:411.75pt;height:370.5pt'>
 <v:imagedata src="Тема%20№4.files/image005.png" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№4.files/image006.jpg" v:shapes="_x0000_i1027"> <o:p></o:p></span></p> <p style="text-align: center;"><span><o:p> </o:p></span></p> <p style="text-align: center;"><span>Рисунок 3 – Возникновение гонок при доступе к разделяемым данным<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Каждому клиенту отводится отдельная запись в базе данных, в которой среди прочих полей имеются поля Заказ и Оплата. Программа, ведущая базу данных, оформлена как единый процесс, имеющий несколько потоков, в том числе поток А, который заносит в базу данных информацию о заказах, поступивших от клиентов, и ноток В, который фиксирует в базе данных сведения об оплате клиентами выставленных счетов. Оба эти потока совместно работают над общим файлом базы данных, используя однотипные алгоритмы, включающие три шага.<o:p></o:p></span></p> <p><span>1. Считать из файла базы данных в буфер запись о клиенте с заданным идентификатором.<o:p></o:p></span></p> <p><span>2. Внести новое значение в поле Заказ (для потока А) или Оплата (для потока В).<o:p></o:p></span></p> <p><span>3. <span> </span>Вернуть модифицированную запись в файл базы данных.<o:p></o:p></span></p> <p><span>Обозначим соответствующие шаги для потока А как </span><span>Al</span><span>, </span><span>A</span><span>2 и A3, а для потока В как </span><span>B</span><span>1, </span><span>B</span><span>2 и ВЗ. Предположим, что в некоторый момент поток А обновляет поле Заказ записи о клиенте N. Для этого он считывает эту запись в свой буфер (шаг А1), модифицирует значение поля Заказ (шаг А2), но внести запись в базу данных (шаг A3) не успевает, так как его выполнение прерывается, например, вследствие завершения кванта времени.<o:p></o:p></span></p> <p><span>Предположим также, что потоку В также потребовалось внести сведения об оплате относительно того же клиента N. Когда подходит очередь потока В, он успевает считать запись в свой буфер (шаг В1) и выполнить обновление поля Оплата (шаг В2), а затем прерывается. Заметим, что в буфере у потока В находится запись о клиенте </span><span>N</span><span>, в которой поле Заказ имеет прежнее, не измененное значение.<o:p></o:p></span></p> <p><span>Когда в очередной раз управление будет передано потоку А, то он, продолжая свою работу, запишет запись о клиенте N с модифицированным полем Заказ в базу данных (шаг A3). После прерывания потока А и активизации потока В последний запишет в базу данных поверх только что обновленной записи о клиенте N свой вариант записи, в которой обновлено значение поля Оплата. Таким образом, в базе данных будут зафиксированы сведения о том, что клиент N произвел оплату, но информация о его заказе окажется потерянной (рисунок 4, а).<o:p></o:p></span></p> <p><span>Сложность проблемы синхронизации кроется в нерегулярности возникающих ситуаций. Так, в предыдущем примере можно представить и другое развитие событий: могла быть потеряна информация не о заказе, а об оплате (рисунок 4, б) или, напротив, все исправления были успешно внесены (рисунок 4, в).<i> </i>Все определяется взаимными скоростями потоков и моментами их прерывания. Поэтому отладка взаимодействующих потоков является сложной задачей. Ситуации, подобные той, когда два или более потоков обрабатывают разделяемые данные и конечный результат зависит от соотношения скоростей потоков, называются <i>гонками.</i><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_20" o:spid="_x0000_i1028"
 type="#_x0000_t75" style='width:334.5pt;height:285.75pt;visibility:visible'>
 <v:imagedata src="Тема%20№4.files/image007.gif" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№4.files/image007.gif" v:shapes="Рисунок_x0020_20"> </span><span><o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>4 – Влияние относительных скоростей потоков на результат решения задачи<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>4.3 Средства синхронизации потоков одного процесса<o:p></o:p></span></b></p> <p><span>Механизмы синхронизации с помощью критических секций и на основе глобальных переменных процесса, обладают существенным недостатком – они не подходят для синхронизации потоков разных процессов. В таких случаях операционная система должна предоставлять потокам системные объекты синхронизации, которые были бы видны для всех потоков, даже если они принадлежат разным процессам и работают в разных адресных пространствах.<o:p></o:p></span></p> <p><span>Примерами таких синхронизирующих объектов ОС являются системные семафоры, мьютексы, события, таймеры и другие – их набор зависит от конкретной ОС, которая создает эти объекты по запросам процессов. Чтобы процессы могли разделять синхронизирующие объекты, в разных ОС используются разные методы. Некоторые ОС возвращают указатель на объект. Этот указатель может быть доступен всем родственным процессам, наследующим характеристики общего родительского процесса. В других ОС процессы в запросах на создание объектов синхронизации указывают имена, которые должны быть им присвоены. Далее эти имена используются разными процессами для манипуляций объектами синхронизации. В таком случае работа с синхронизирующими объектами подобна работе с файлами. Их можно создавать, открывать, закрывать, уничтожать. Кроме того, для синхронизации могут быть использованы такие «обычные» объекты ОС, как файлы, процессы и потоки. Все эти объекты могут находиться в двух состояниях: сигнальном и несигнальном – свободном. Для каждого объекта смысл, вкладываемый в понятие «сигнальное состояние», зависит от типа объекта. Так, например, поток переходит в сигнальное состояние тогда, когда он завершается. Процесс переходит в сигнальное состояние тогда, когда завершаются все его потоки. Файл переходит в сигнальное состояние в том случае, когда завершается операция ввода-вывода для этого файла. Для остальных объектов сигнальное состояние устанавливается в результате выполнения специальных системных вызовов. Приостановка и активизация потоков осуществляются в зависимости от состояния синхронизирующих объектов ОС.<o:p></o:p></span></p> <p><span>В </span><span>Windows </span><span>есть специальные функции ожидания синхронизирующих объектов ядра (</span><span>wait</span><span>-функции) позволяют потоку в любой момент приостановиться и ждать освобождения какого-либо объекта ядра. Из всего семейства этих функций чаще всего используется </span><b><span>WaitForSingleObject</span></b><span>:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>DWORD <b>WaitForSingleObject</b></span><span>(</span><span> HANDLE <i>hObject</i></span><span>,</span><span> DWORD <i>dwMilliseconds</i></span><span>);<o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Когда поток вызывает эту функцию, первый параметр, <i>hObject</i>, идентифицирует объект ядра, поддерживающий состояния «свободен-занят». Второй параметр, <i>dwMilliseconds</i>, указывает, сколько времени (в миллисекундах) поток готов ждать освобождения объекта.<o:p></o:p></span></p> <p><span>Следующий вызов сообщает системе, что поток будет ждать до тех пор, пока не завершится процесс, идентифицируемый описателем <i>hProcess</i>.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><b><span>WaitForSingleObject</span></b><span>(</span><span>hProcess</span><span>, </span><span>INFINITE</span><span>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В данном случае константа </span><span>INFINITE</span><span>, передаваемая во втором параметре, подсказывает системе, что вызывающий поток готов ждать этого события хоть целую вечность. Именно эта константа обычно и передается функции <b>WaitForSingleObject</b>, но можно указать любое значение в миллисекундах.<o:p></o:p></span></p> <p><span>Функция <b>WaitForMultipleObjects</b> аналогична <b>WaitForSingleObject</b> </span><span>c</span><span> тем исключением, что позволяет ждать освобождения сразу нескольких объектов или какого-то одного из списка объектов:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>DWORD </span><b><span>WaitForMultipleObjects</span></b><span>( DWO</span><span>R</span><span>D <i>dwCount</i>,<o:p></o:p></span></p> <p style="text-align: center;"><span>CONST HANDLE* <i>phObjects</i>, BOOL <i>fWaitAll</i>, DWORD <i>dwMilliseconds</i>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Параметр <i>dwCount</i> определяет количество интересующих объектов ядра Его значение должно быть в пределах от 1 до </span><span>MAXIMUM</span><span>_</span><span>WAIT</span><span>_</span><span>OBJECTS</span><span> (в заголовочных файлах </span><span>Windows</span><span>оно определено как 64). Параметр <i>phObject</i> — это указатель на мас сив описателей объектов ядра.<o:p></o:p></span></p> <p><b><span>WaitForMultipleObjects</span></b><span> приостанавливает поток и заставляет его ждать освобождения либо всех заданных объектов ядра, либо одного из них. Параметр <i>fWaitAll</i> как раз и определяет, чего именно требуется от функции. Если он равен </span><span>TRUE</span><span>, функция не даст потоку возобновить свою работу, пока не освободятся все объекты.<o:p></o:p></span></p> <p><span>Параметр <i>dwMilliseconds</i> идентичен одноименному параметру функции <b>WaitForSingleObject</b>.<o:p></o:p></span></p> <p><span>Возвращаемое значение функции <b>WaitForMultipleObjects</b> сообщает, почему возобновилось выполнение вызвавшего ее потока.<o:p></o:p></span></p> <p><b><span>4.4 Синхронизирующие объекты ОС для синхронизации потоков разных процессов<o:p></o:p></span></b></p> <p><span>В случае синхронизации потоков разных процессов операционная система должна предоставлять потокам системные объекты синхронизации, которые были бы видны для всех потоков, даже если они принадлежат разным процессам и работают в разных адресных пространствах.<o:p></o:p></span></p> <p><span>Примерами таких синхронизирующих объектов ОС являются:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>системные семафоры<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>мьютексы<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>события<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>таймеры и другие.<o:p></o:p></span></p> <p><span>Чтобы процессы могли разделять синхронизирующие объекты, в разных ОС используются разные методы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>возврат указателя на объект, доступного всем родственным процессам, наследующим характеристики общего родительского процесса.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>Указание в запросах на создание объектов синхронизации имен, которые должны быть им присвоены. Далее эти имена используются разными процессами для манипуляций объектами синхронизации. В таком, случае работа с синхронизирующими объектами подобна работе с файлами (создавать, открывать, закрывать, уничтожать).<o:p></o:p></span></p> <p><span>Все синхронизирующие объекты могут находиться в двух состояниях:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>сигнальном</span><span>;</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>·<span> </span></span></span><![endif]><span>несигнальном (свободном).<o:p></o:p></span></p> <p><span>Для каждого объекта смысл, вкладываемый в понятие «сигнальное состояние», зависит от типа объекта. Так, например, поток переходит в сигнальное состояние тогда, когда он завершается. Процесс переходит в сигнальное состояние тогда, когда завершаются все его потоки. Файл переходит в сигнальное состояние в том случае, когда завершается операция ввода-вывода для этого файла. Для остальных объектов сигнальное состояние устанавливается в результате выполнения специальных системных вызовов. Приостановка и активизация потоков осуществляются в зависимости от состояния синхронизирующих объектов ОС.<o:p></o:p></span></p> <p><span>Потоки с помощью специального системного вызова сообщают операционной системе о том, что они хотят синхронизировать свое выполнение с состоянием некоторого объекта.<o:p></o:p></span></p> <p><span>Поток может ожидать установки сигнального состояния не одного объекта, а нескольких. При этом поток может попросить ОС активизировать его при установке либо одного из указанных объектов, либо всех объектов. Поток может в качестве аргумента системного вызова Wait() указать также максимальное время, которое он будет ожидать перехода объекта в сигнальное состояние, после чего ОС должна его активизировать в любом случае. Может случиться, что установки некоторого объекта в сигнальное состояние ожидают сразу несколько потоков. В зависимости от объекта синхронизации в состояние готовности могут переводиться либо все ожидающие это событие потоки, либо один из них.<o:p></o:p></span></p> <p><span>Синхронизация тесно связана с планированием потоков:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>любое обращение потока с системным вызовом Wait(X) влечет за собой действия в подсистеме планирования<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>поток снимается с выполнения и помещается в очередь ожидающих потоков;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>из очереди готовых потоков выбирается и активизируется новый поток.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>при переходе объекта в сигнальное состояние (в результате выполнения некоторого потока – либо системного, либо прикладного) ожидающий этот объект поток (или потоки) переводится в очередь готовых к выполнению потоков. В обоих случаях осуществляется перепланирование потоков, при этом если в ОС предусмотрены изменяемые приоритеты и/или кванты времени, то они пересчитываются по правилам, принятым в этой операционной системе.<o:p></o:p></span></p> <p><b><span>Мьютекс</span></b><span>, как и семафор, обычно используется для управления доступом к данным. В отличие от объектов-потоков, объектов-процессов и объектов-файлов, которые при переходе в сигнальное состояние переводят в состояние готовности все потоки, ожидающие этого события, объект-мьютекс «освобождает» из очереди ожидающих только один поток.<o:p></o:p></span></p> <p><span>Работа мьютекса хорошо поясняется в терминах «владения». Пусть поток, который, пытаясь получить доступ к критическим данным, выполнил системный вызов Wait(X), где X – указатель на мьютекс. Предположим, что мьютекс находится в сигнальном состоянии, в этом случае поток тут же становится его владельцем, устанавливая его в несигнальное состояние, и входит в критическую секцию. После того как поток выполнил работу с критическими данными, он «отдает» мьютекс, устанавливая его в сигнальное состояние. В этот момент мьютекс свободен и не принадлежит ни одному потоку. Если какой-либо поток ожидает его освобождения, то он становится следующим владельцем этого мьютекса, одновременно мьютекс переходит в несигнальное состояние.<o:p></o:p></span></p> <p><b><span>Объект-событие</span></b><span> (в данном случае слово «событие» используется в узком смысле, как обозначение конкретного вида объектов синхронизации) обычно используется не для доступа к данным, а для того, чтобы оповестить другие потоки о том, что некоторые действия завершены. Пусть, например, в некотором приложении работа организована таким образом, что один поток читает данные из файла в буфер памяти, а другие потоки обрабатывают эти данные, затем первый поток считывает новую порцию данных, а другие потоки снова ее обрабатывают и так далее. В начале работы первый поток устанавливает объект-событие в несигнальное состояние. Все остальные потоки выполнили вызов Wait(X), где X – указатель события, и находятся в приостановленном состоянии, ожидая наступления этого события. Как только буфер заполняется, первый поток сообщает об этом операционной системе, выполняя вызов Set(X). Операционная система просматривает очередь ожидающих потоков и активизирует все потоки, которые ждут этого события.<o:p></o:p></span></p> <p><b><span>4.5 Понятия «семафоры», «мьютексы»<o:p></o:p></span></b></p> <p><span>Объекты ядра «семафор» используются для учета ресурсов. Как и все объекты ядра, они содержат счетчик числа пользователей, но, кроме того, поддерживают два 32-битных значения со знаком: одно определяет максимальное число ресурсов (контролируемое семафором), другое используется как счетчик текущего числа ресурсов.<o:p></o:p></span></p> <p><span>Для семафоров определены следующие правила:<o:p></o:p></span></p> <p> <span>когда счетчик текущего числа ресурсов становится больше 0, семафор переходит в свободное состояние;<o:p></o:p></span></p> <p> <span>если этот счетчик равен 0, семафор занят;<o:p></o:p></span></p> <p> <span>система не допускает присвоения отрицательных значений счетчику текущего числа ресурсов;<o:p></o:p></span></p> <p> <span>счетчик текущего числа ресурсов не может быть больше максимального числа ресурсов.<o:p></o:p></span></p> <p><span>Объекты ядра «мьютексы» гарантируют потокам взаимоисключающий доступ к единственному ресурсу. Отсюда и произошло название этих объектов (mutual exclusion – mutex). Они содержат счетчик числа пользователей, счетчик рекурсии и переменную, в которой запоминается идентификатор потока. Мьютексы ведут себя точно так же, как и критические секции. Однако, если последние являются объектами пользовательского режима, то мьютексы – объектами ядра. Кроме того, единственный объект-мьютекс позволяет синхронизировать доступ к ресурсу нескольких потоков из разных процессов; при этом можно задать максимальное время ожидания доступа к ресурсу.<o:p></o:p></span></p> <p><span>Идентификатор потока определяет, какой поток захватил мьютекс, а счетчик рекурсий – сколько раз. У мьютексов много применений, и это наиболее часто используемые объекты ядра. Как правило, с их помощью защищают блок памяти, к которому обращается множество потоков. Если бы потоки одновременно использовали какой-то блок памяти, данные в нем были бы повреждены. Мьютексы гарантируют, что любой поток получает монопольный доступ к блоку памяти, и тем самым обеспечивают целостность данных.<o:p></o:p></span></p> <p><span>Для мьютексов определены следующие правила:<o:p></o:p></span></p> <p> <span>если его идентификатор потока равен 0 (у самого потока не может быть та кой идентификатор), мьютекс не захвачен ни одним из потоков и находится в свободном состоянии;<o:p></o:p></span></p> <p> <span>если его идентификатор потока не равен 0, мьютекс захвачен одним из потоков и находится в занятом состоянии;<o:p></o:p></span></p> <p> <span>в отличие от других объектов ядра мьютексы могут нарушать обычные правила, действующие в операционной системе<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>4.6 Мультипроцессорные системы<o:p></o:p></span></b></p> <p><b><span>Мультипроцессорная обработка (мультипроцессирование)</span></b><span> – это способ организации вычислительного процесса в системах с несколькими процессорами, при котором несколько задач (процессов, потоков) могут одновременно выполняться на разных процессорах системы.<o:p></o:p></span></p> <p><span>Концепция мультипроцессирования ненова, она известна с 70-х годов, но до середины 80-х доступных многопроцессорных систем не существовало. Однако к настоящему времени стало обычным включение нескольких процессоров в архитектуру даже персонального компьютера. Более того, многопроцессорность теперь является одним из необходимых требований, которые предъявляются к компьютерам, используемым в качестве центрального сервера более-менее крупной сети.<o:p></o:p></span></p> <p><span>В мультипрограммных системах параллельная работа разных устройств позволяет одновременно вести обработку нескольких программ, но при этом в процессоре в каждый момент времени выполняется только одна программа. То есть в этом случае несколько задач выполняются попеременно на одном процес­соре, создавая лишь видимость параллельного выполнения. А в мультипроцес­сорных системах несколько задач выполняются действительно одновременно, так как имеется несколько обрабатывающих устройств – процессоров. Конечно, мультипроцессирование вовсе не исключает мультипрограммирования: на каждом из процессоров может попеременно выполняться некоторый закрепленный за дан­ным процессором набор задач.<o:p></o:p></span></p> <p><span>Мультипроцессорная организация системы приводит к усложнению всех алго­ритмов управления ресурсами, например требуется планировать процессы не для одного, а для нескольких процессоров, что гораздо сложнее. Сложности за­ключаются и в возрастании числа конфликтов по обращению к устройствам ввода-вывода, данным, общей памяти и совместно используемым программам. Необходимо предусмотреть эффективные средства блокировки при доступе к разделяемым информационным структурам ядра. Все эти проблемы должна решать операционная система путем синхронизации процессов, ведения очередей и планирования ресурсов. Более того, сама операционная система должна быть спроектирована так, чтобы уменьшить существующие взаимозависимости между собственными компонентами.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>4.7 Многомашинные комплексы<o:p></o:p></span></b></p> <p><span>Кластерные системы более дешевый вариант MPP-систем, поскольку они также используют принцип передачи сообщений, но строятся из готовых компонентов. Базовым элементом кластера является локальная сеть. Оказалось, что на многих классах задач и при достаточном числе узлов такие системы дают производительность, сравнимую с суперкомпьютерной.<o:p></o:p></span></p> <p><b><span>Кластер</span></b><span> – параллельный компьютер, все процессоры которого действуют как единое целое для решения одной задачи. Первым кластером на рабочих станциях был Beowulf. Проект Beowulf начался в 1994 г. сборкой в научно-космическом центре NASA 16-процессорного кластера на Ethernet-кабеле. С тех пор кластеры на рабочих станциях обычно называют Beowulf-кластерами. Любой Beowulf-кластер состоит из машин (узлов) и объединяющей их сети (коммутатора). Кроме ОС, необходимо установить и настроить сетевые драйверы, компиляторы, ПО поддержки параллельного программирования и распределения вычислительной нагрузки. В качестве узлов обычно используются однопроцессорные ВМ с быстродействием 1 ГГц и выше или SMP-серверы с небольшим числом процессоров (обычно 2–4).<o:p></o:p></span></p> <p><span>Для получения хорошей производительности межпроцессорных обменов используют полнодуплексную сеть Fast Ethernetс пропускной способностью 100 Mбит/с. При этом для уменьшения числа коллизий устанавливают несколько «параллельных» сегментов Ethernet или соединяют узлы кластера через коммутатор (switch). В качестве операционных систем обычно используют Linux или Windows NT и ее варианты, а в качестве языка программирования – С++.<o:p></o:p></span></p> <p><span>Наиболее распространенным интерфейсом параллельного программирования в мод модели передачи сообщений является MPI (Message Passing Interface). Рекомендуемой бесплатной реализацией MPI является пакет MPICH, разработанный в Аргоннской национальной лаборатории США.<o:p></o:p></span></p> <p><span>Во многих организациях имеются локальные сети компьютеров с соответствующим программным обеспечением. Если такую сеть снабдить пакетом MPICH, то без дополнительных затрат получается Beowulf-кластер, сравнимый по мощности с супер-ЭВМ. Это является причиной широкого распространения таких кластеров.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>4.8 Распределенная обработка данных<o:p></o:p></span></b></p> <p><span>Таким образом, существующие МПС распадаются на две основные группы.<o:p></o:p></span></p> <p><span>К первой группе относятся МПС с общей (разделяемой) основной памятью, объединяющие до нескольких десятков (обычно менее 32) процессоров. Сравнительно небольшое количество процессоров в таких машинах позволяет иметь одну централизованную общую память и объединить процессоры и память с помощью одной шины. При наличии у процессоров кэш-памяти достаточного объема высокопроизводительная шина и общая память могут удовлетворить обращения к памяти, поступающие от нескольких процессоров. Поскольку имеется единственная память с одним и тем же временем доступа, эти МПС иногда называют UMA (Uniform Memory Access). Такой способ организации со сравнительно небольшой разделяемой памятью в настоящее время является наиболее популярным. Структура подобной системы представлена на рисунке 4<o:p></o:p></span></p> <p><span>Вторую группу МПС составляют крупномасштабные системы с распределенной памятью. Для того чтобы поддерживать большое количество процессоров приходится распределять основную память между ними, в противном случае полосы пропускания памяти просто может не хватить для удовлетворения запросов, поступающих от очень большого числа процессоров. Естественно при таком подходе также требуется реализовать связь процессоров между собой. На рисунке 5 показана структура такой системы.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_21" o:spid="_x0000_i1029"
 type="#_x0000_t75" style='width:381.75pt;height:129.75pt;visibility:visible'>
 <v:imagedata src="Тема%20№4.files/image008.jpg" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№4.files/image009.jpg" v:shapes="Рисунок_x0020_21"> </span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок 5</span><span> </span><span>–</span><span> </span><span>Типовая архитектура МПС с общей памятью<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>С ростом числа процессоров просто невозможно обойти необходимость реализации модели распределенной памяти с высокоскоростной сетью для связи процессоров.<o:p></o:p></span></p> <p><span>С быстрым ростом производительности процессоров и связанным с этим ужесточением требования увеличения полосы пропускания памяти, масштаб систем (т.е. число процессоров в системе), для которых требуется организация распределенной памяти, уменьшается, также как и уменьшается число процессоров, которые удается поддерживать на одной разделяемой шине и общей памяти. Распределение памяти между отдельными узлами системы имеет два главных преимущества.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_10" o:spid="_x0000_i1030"
 type="#_x0000_t75" style='width:380.25pt;height:204pt;visibility:visible'>
 <v:imagedata src="Тема%20№4.files/image010.jpg" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№4.files/image011.jpg" v:shapes="Рисунок_x0020_10"> </span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>6</span><span> </span><span>–</span><span> </span><span>Типовая архитектура МПС с распределенной памятью<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Во-первых, это эффективный с точки зрения стоимости способ увеличения полосы пропускания памяти, поскольку большинство обращений могут выполняться параллельно к локальной памяти в каждом узле. Во-вторых, это уменьшает задержку обращения (время доступа) к локальной памяти. Эти два преимущества еще больше сокращают количество процессоров, для которых архитектура с распределенной памятью имеет смысл.<o:p></o:p></span></p> <p><span>Существующие ВС класса MIMD образуют три технических подкласса:<o:p></o:p></span></p> <p><span>– симметричные мультипроцессоры;<o:p></o:p></span></p> <p><span>– системы с массовым параллелизмом;<o:p></o:p></span></p> <p><span>– кластеры.<o:p></o:p></span></p> <p><span>Симметричные мультипроцессоры (SMP – Symmetric Multi Processors) используют принцип разделяемой памяти. В этом случае система состоит из нескольких однородных процессоров и массива общей памяти (обычно из нескольких независимых блоков). Все процессоры имеют доступ к любой ячейке памяти с одинаковой скоростью. Процессоры подключены к памяти с помощью общей шины или коммутатора. Аппаратно поддерживается когерентность кэшей. Вся система работает под управлением единой ОС.<o:p></o:p></span></p> <p><span>Системы с массовым параллелизмом (MPP – Massively Parallel Processing) содержат множество процессоров c индивидуальной памятью, которые связаны через некоторую коммуникационную среду. Как правило, системы MPP благодаря специализированной высокоскоростной системе обмена обеспечивают наивысшее быстродействие.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Список литературы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Рихтер, Дж. Windows для профессионалов. Создание эффективных Win42-приложений с учетом специфики 64-разрядной версии Windows / Дж. Рихтер // Пер.с англ., 4-е изд. – СПб.: Питер; М.: Издательско-торговый дом «Русская Редакция», 2004.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Олифер, В.Г. Сетевые операционные системы / В.Г. Олифер, Н.А. Олифер. – СПб.: Питер, 2002.<o:p></o:p></span></p> 
 </div> 

 <A HREF="../theory.htm">Оглавление</A>                
<p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>