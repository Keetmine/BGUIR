<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Теория по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" >Программа</A> |
                                                    <strong>Теория</strong>|
                                                  <A HREF="../../Практика/practice.htm">Практика</A>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>
<table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../theory.htm">Оглавление</A>
                <p>&nbsp;</p>
                 <div> <p><a><b><span>Тема 5. </span></b></a><span><b><span>Управление памятью. Виртуальная память<o:p></o:p></span></b></span></p> <span></span> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>5.1 Функции операционной системы по управлению памятью<o:p></o:p></span></b></p> <p><b><span><span> </span></span></b><span>Под памятью подразумевается оперативная память компьютера. В отличие от памяти жесткого диска, которую называют внешней памятью, оперативной памяти для сохранения информации требуется постоянное электропитание.<o:p></o:p></span></p> <p><span>Память является важнейшим ресурсом, требующим тщательного управления со стороны мультипрограммной операционной системы. Особая роль памяти объясняется тем, что процессор может выполнять инструкции программы только в том случае, если они находятся в памяти. Память распределяется как между модулями прикладных программ, так и между модулями самой операционной системы.<o:p></o:p></span></p> <p><span>В ранних ОС управление памятью сводилось просто к загрузке программы и ее данных из некоторого внешнего накопителя (перфоленты, магнитной ленты или магнитного диска) в память. С появлением мультипрограммирования перед ОС были поставлены новые задачи, связанные с распределением имеющейся памяти между несколькими одновременно выполняющимися программами.<o:p></o:p></span></p> <p><span>Функциями ОС по управлению памятью в мультипрограммной системе являются:<o:p></o:p></span></p> <p> <span>отслеживание свободной и занятой памяти;<o:p></o:p></span></p> <p> <span>выделение памяти процессам и освобождение памяти по завершении процессов;<o:p></o:p></span></p> <p> <span>вытеснение кодов и данных процессов из оперативной памяти на диск (полное или частичное), когда размеры основной памяти не достаточны для размещения в ней всех процессов, и возвращение их в оперативную память, когда в ней освобождается место;<o:p></o:p></span></p> <p> <span>настройка адресов программы на конкретную область физической памяти.<o:p></o:p></span></p> <p><span>Помимо первоначального выделения памяти процессам при их создании ОС должна также заниматься динамическим распределением памяти, то есть выполнять запросы приложений на выделение им дополнительной памяти во время выполнения. После того как приложение перестает нуждаться в дополнительной памяти, оно может возвратить ее системе. Выделение памяти случайной длины в случайные моменты времени из общего пула памяти приводит к фрагментации и, вследствие этого, к неэффективному ее использованию. Дефрагментация памяти тоже является функцией операционной системы.<o:p></o:p></span></p> <p><span>Во время работы операционной системы ей часто приходится создавать новые служебные информационные структуры, такие как описатели процессов и потоков, различные таблицы распределения ресурсов, буферы, используемые процессами для обмена данными, синхронизирующие объекты и т. п. Все эти системные объекты требуют памяти. В некоторых ОС заранее (во время установки) резервируется некоторый фиксированный объем памяти для системных нужд. В других же ОС используется более гибкий подход, при котором память для системных целей выделяется динамически. В таком случае разные подсистемы ОС при создании своих таблиц, объектов, структур и т. п. обращаются к подсистеме управления памятью с запросами.<o:p></o:p></span></p> <p><span>Защита памяти – это еще одна важная задача операционной системы, которая состоит в том, чтобы не позволить выполняемому процессу записывать или читать данные из памяти, назначенной другому процессу. Эта функция, как правило, реализуется программными модулями ОС в тесном взаимодействии с аппаратными средствами.<o:p></o:p></span></p> <p><b><span>5.2 </span></b><b><span>Типы адресов<o:p></o:p></span></b></p> <p><span>Для идентификации переменных и команд на разных этапах жизненного цикла программы используются символьные имена (метки), виртуальные адреса и физические адреса (рисунок 1).<o:p></o:p></span></p> <p><span>Символьные имена присваивает пользователь при написании программы на алгоритмическом языке или ассемблере.<o:p></o:p></span></p> <p><span>Виртуальные адреса, называемые иногда математическими, или логическими адресами, вырабатывает транслятор, переводящий программу на машинный язык. Поскольку во время трансляции в общем случае не известно, в какое место оперативной памяти будет загружена программа, то транслятор присваивает переменным и командам виртуальные (условные) адреса, обычно считая по умолчанию, что начальным адресом программы будет нулевой адрес.<o:p></o:p></span></p> <p><span>Физические адреса соответствуют номерам ячеек оперативной памяти, где в действительности расположены или будут расположены переменные и команды.<o:p></o:p></span></p> <p><span>Совокупность виртуальных адресов процесса называется виртуальным адресным пространством. Диапазон возможных адресов виртуального пространства у всех процессов является одним и тем же. Например, при использовании 32-разрядных виртуальных адресов этот диапазон задается границами 0000000016 и FFFFFFFF16. Тем не менее, каждый процесс имеет собственное виртуальное адресное пространство – транслятор присваивает виртуальные адреса переменным и кодам каждой программе независимо (рисунок 2).<o:p></o:p></span></p> <p style="text-align: center;"><a></a><span><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="Рисунок_x0020_22" o:spid="_x0000_i1025" type="#_x0000_t75"
 style='width:300pt;height:235.5pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image001.png" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№5.files/image002.gif" v:shapes="Рисунок_x0020_22"></span><span><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>1 – Типы адресов<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape
 id="_x0000_i1026" type="#_x0000_t75" style='width:398.25pt;height:366.75pt'>
 <v:imagedata src="Тема%20№5.files/image003.png" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№5.files/image004.jpg" v:shapes="_x0000_i1026"><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок<a></a><a></a><a></a><span> </span>2 – Виртуальное адресное пространство нескольких программ<o:p></o:p></span></p> <p style="text-align: center;"><span><o:p> </o:p></span></p> <p><span>Совпадение виртуальных адресов переменных и команд различных процессов не приводит к конфликтам, так как в том случае, когда эти переменные одновременно присутствуют в памяти, операционная система отображает их на разные физические адреса.<o:p></o:p></span></p> <p><span>В разных операционных системах используются разные способы структуризации виртуального адресного пространства. В одних ОС виртуальное адресное пространство процесса подобно физической памяти представлено в виде непрерывной линейной последовательности виртуальных адресов. Такую структуру адресного пространства называют также плоской (flat). При этом виртуальным адресом является единственное число, представляющее собой смещение относительно начала (обычно это значение 000...000) виртуального адресного пространства (рисунок 3, а). Адрес такого типа называют линейным виртуальным адресом.<o:p></o:p></span></p> <p><span>В других ОС виртуальное адресное пространство делится на части, называемые сегментами (или секциями, или областями, или другими терминами). В этом случае помимо линейного адреса может быть использован виртуальный адрес, представляющий собой пару чисел (<b>n</b>,<b>m</b>), где <b>n</b> определяет сегмент, а <b>m</b> – смещение внутри сегмента (рисунок 3, б).<o:p></o:p></span></p> <p><span>Существуют и более сложные способы структуризации виртуального адресного пространства, когда виртуальный адрес образуется тремя или даже более числами.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_24" o:spid="_x0000_i1027"
 type="#_x0000_t75" style='width:434.25pt;height:210pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image005.gif" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№5.files/image005.gif" v:shapes="Рисунок_x0020_24"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a><a></a>3 – Типы виртуальных адресных пространств<o:p></o:p></span></p> <p style="text-align: center;"><span>(плоское (а), сегментированное (б))<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Задачей операционной системы является отображение индивидуальных виртуальных адресных пространств всех одновременно выполняющихся процессов на общую физическую память. При этом ОС отображает либо все виртуальное адресное пространство, либо только определенную его часть. Процедура преобразования виртуальных адресов в физические должна быть максимально прозрачна для пользователя и программиста.<o:p></o:p></span></p> <p><span>Существуют два принципиально отличающихся подхода к преобразованию виртуальных адресов в физические.<o:p></o:p></span></p> <p><span>В первом случае замена виртуальных адресов на физические выполняется один раз для каждого процесса во время начальной загрузки программы в память. Специальная системная программа – перемещающий загрузчик – на основании имеющихся у нее исходных данных о начальном адресе физической памяти, в которую предстоит загружать программу, а также информации, предоставленной транслятором об адресно-зависимых элементах программы, выполняет загрузку программы, совмещая ее с заменой виртуальных адресов физическими.<o:p></o:p></span></p> <p><span>Второй способ заключается в том, что программа загружается в память в неизмененном виде в виртуальных адресах, то есть операнды инструкций и адреса переходов имеют те значения, которые выработал транслятор. В наиболее простом случае, когда виртуальная и физическая память процесса представляют собой единые непрерывные области адресов, операционная система выполняет преобразование виртуальных адресов в физические по следующей схеме. При загрузке операционная система фиксирует смещение действительного расположения программного кода относительно виртуального адресного пространства. Во время выполнения программы при каждом обращении к оперативной памяти выполняется преобразование виртуального адреса в физический. Схема такого преобразования показана на (рисунок 4). Пусть, например, операционная система использует линейно-структурированное виртуальное адресное пространство и пусть некоторая программа, работающая под управлением этой ОС, загружена в физическую память начиная с физического адреса S. ОС запоминает значение начального смещения S и во время выполнения программы помещает его в специальный регистр процессора. При обращении к памяти виртуальные адреса данной программы преобразуются в физические путем прибавления к ним смещения S. Например, при выполнении инструкции MOV пересылки данных, находящихся по адресу VA, виртуальный адрес VA заменяется физическим адресом VA+S.<o:p></o:p></span></p>

<p><span> <o:p></o:p></span></p>
<p style="text-align: center;">
	<span>
		<!--[if gte vml 1]>
<v:shape id="Рисунок_x0020_11" o:spid="_x0000_i1028" type="#_x0000_t75" style='width:457.5pt;height:181.5pt;visibility:visible'>

<v:imagedata src="Тема%20№5.files/image006.png" o:title=""/></v:shape>
		<![endif]-->



<img src="Тема%20№5.files/pict4.jpg" v:shapes="Рисунок_x0020_11">
	</span>



<span><o:p></o:p></span></p>

<p><span> <o:p></o:p></span></p>

<p style="text-align: center;"><span>Рисунок 4 – Схема динамического преобразования адресов<o:p></o:p></span></p>

<p><span> <o:p></o:p></span></p> <p><span>Последний способ является более гибким: в то время как перемещающий загрузчик жестко привязывает программу к первоначально выделенному ей участку памяти, динамическое преобразование виртуальных адресов позволяет перемещать программный код процесса в течение всего периода его выполнения. Но использование перемещающего загрузчика более экономично, так как в этом случае преобразование каждого виртуального адреса происходит только один раз во время загрузки, а при динамическом преобразовании – при каждом обращении по данному адресу.<o:p></o:p></span></p> <p><span>В некоторых случаях (обычно в специализированных системах), когда заранее точно известно, в какой области оперативной памяти будет выполняться программа, транслятор выдает исполняемый код сразу в физических адресах.<o:p></o:p></span></p> <p><span>Необходимо различать максимально возможное виртуальное адресное пространство процесса и назначенное (выделенное) процессу виртуальное адресное пространство. В первом случае речь идет о максимальном размере виртуального адресного пространства, определяемом архитектурой компьютера, на котором работает ОС, и, в частности, разрядностью его схем адресации (32-битная, 64-битная и т.п.). Например, при работе на компьютерах с 32-разрядными процессорами Intel Pentium операционная система может предоставить каждому процессу виртуальное адресное пространство до 4 Гбайт (232). Однако это значение представляет собой только потенциально возможный размер виртуального адресного пространства, который редко на практике бывает, необходим процессу. Процесс использует только часть доступного ему виртуального адресного пространства.<o:p></o:p></span></p> <p><span>Назначенное виртуальное адресное пространство представляет собой набор виртуальных адресов, действительно нужных процессу для работы. Эти адреса первоначально назначает программе транслятор на основании текста программы, когда создает кодовый (текстовый) сегмент, а также сегмент или сегменты данных, с которыми программа работает. Затем при создании процесса ОС фиксирует назначенное виртуальное адресное пространство в своих системных таблицах. В ходе своего выполнения процесс может увеличить размер первоначального назначенного ему виртуального адресного пространства, запросив у ОС создания дополнительных сегментов или увеличения размера существующих. В любом случае операционная система обычно следит за корректностью использования процессом виртуальных адресов – процессу не разрешается оперировать с виртуальным адресом, выходящим за пределы назначенных ему сегментов.<o:p></o:p></span></p> <p><span>Максимальный размер виртуального адресного пространства ограничивается только разрядностью адреса, присущей данной архитектуре компьютера, и, как правило, не совпадает с объемом физической памяти, имеющимся в компьютере.<o:p></o:p></span></p> <p><span>Сегодня для машин универсального назначения типична ситуация, когда объем виртуального адресного пространства, превышает доступный объем оперативной памяти. В таком случае операционная система для хранения данных виртуального адресного пространства процесса, не помещающихся в оперативную память, использует внешнюю память, которая в современных компьютерах представлена жесткими дисками (рисунок 5, а). Именно на этом принципе основана виртуальная память – наиболее совершенный механизм, используемый в операционных системах для управления памятью.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_25" o:spid="_x0000_i1029"
 type="#_x0000_t75" style='width:326.25pt;height:257.25pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image008.jpg" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№5.files/image009.jpg" v:shapes="Рисунок_x0020_25"></span><span><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок<a></a><a></a><span> </span>5 – Соотношение объемов виртуального адресного пространства и физической памяти (виртуальное адресное пространство превосходит объем физической памяти (а), виртуальное адресное пространство меньше объема физической памяти (б))<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Однако соотношение объемов виртуальной и физической памяти может быть и обратным. Так, в мини-компьютерах 80-х годов разрядности поля адреса нередко не хватало для того, чтобы охватить всю имеющуюся оперативную память. Несколько процессов могло быть загружено в память одновременно и целиком (рисунок 5, б).<o:p></o:p></span></p> <p><span>Необходимо подчеркнуть, что виртуальное адресное пространство и виртуальная память – это различные механизмы, и они не обязательно реализуются в операционной системе одновременно. Можно представить себе ОС, в которой поддерживаются виртуальные адресные пространства для процессов, но отсутствует механизм виртуальной памяти. Это возможно только в том случае, если размер виртуального адресного пространства каждого процесса меньше объема физической памяти.<o:p></o:p></span></p> <p><span>Содержимое назначенного процессу виртуального адресного пространства, то есть коды команд, исходные и промежуточные данные, а также результаты вычислений, представляет собой образ процесса.<o:p></o:p></span></p> <p><span>Во время работы процесса постоянно выполняются переходы от прикладных кодов к кодам ОС, которые либо явно вызываются из прикладных процессов как системные функции, либо вызываются как реакция па внешние события или на исключительные ситуации, возникающие при некорректном поведении прикладных кодов. Для того чтобы упростить передачу управления от прикладного кода к коду ОС, а также для легкого доступа модулей ОС к прикладным данным (например, для вывода их на внешнее устройство), в большинстве ОС ее сегменты разделяют виртуальное адресное пространство с прикладными сегментами активного процесса. То есть сегменты ОС, и сегменты активного процесса образуют единое виртуальное адресное пространство.<o:p></o:p></span></p> <p><span>Обычно виртуальное адресное пространство процесса делится на две непрерывные части: системную и пользовательскую. В некоторых ОС (например, Windows NT, OS/2) эти части имеют одинаковый размер – но 2 Гбайт, хотя в принципе деление может быть и другим, например 1 Гбайт – для ОС, и 2 Гбайт – для прикладных программ. Часть виртуального адресного пространства каждого процесса, отводимая под сегменты ОС, является идентичной для всех процессов. Поэтому при смене активного процесса заменяется только вторая часть виртуального адресного пространства, содержащая его индивидуальные сегменты, как правило, – коды и данные прикладной программы (рисунок 6). Архитектура современных процессоров отражает эту особенность структуры виртуального адресного пространства, например, в процессорах Intel Pentium существует два типа системных таблиц: одна – для описания сегментов, общих для всех процессов, а другая – для описания индивидуальных сегментов данного процесса. При смене процесса первая таблица остается неизменной, а вторая заменяется новой.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_26" o:spid="_x0000_i1030"
 type="#_x0000_t75" style='width:420pt;height:151.5pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image010.jpg" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№5.files/image011.jpg" v:shapes="Рисунок_x0020_26"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок<a></a><a></a><span> </span>6 – Общая и индивидуальные части виртуальных адресных пространств<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Описанное выше назначение двух частей виртуального адресного пространства – для сегментов ОС и для сегментов прикладной программы – является типичным, но не абсолютным. Имеются и исключения из общего правила. В некоторых ОС существуют системные процессы, порожденные для решения внутренних задач ОС. В этих процессах отсутствуют сегменты прикладной программы, но они могут расположить некоторые свои сегменты (сегменты ОС) в общей части виртуального адресного пространства, а некоторые – в индивидуальной части, обычно предназначенной для прикладных сегментов. И, наоборот, в общей, системной части виртуального адресного пространства размещаются сегменты прикладного кода, предназначенные для совместного использования несколькими прикладными процессами.<o:p></o:p></span></p> <p><span>Механизм страничной памяти в большинстве универсальных операционных систем применяется ко всем сегментам пользовательской части виртуального адресного пространства процесса. Исключения могут составлять специализированные ОС, например ОС реального времени, в которых некоторые сегменты жестко фиксируются в оперативной памяти и соответственно никогда не выгружаются на диск – это обеспечивает быструю реакцию определенных приложений на внешние события.<o:p></o:p></span></p> <p><span>Системная часть виртуальной памяти в ОС любого типа включает область, подвергаемую страничному вытеснению, и область, на которую страничное вытеснение не распространяется. В не вытесняемой области размещаются модули ОС, требующие быстрой реакции и/или постоянного присутствия в памяти, например диспетчер потоков или код, который управляет заменой страниц памяти. Остальные модули ОС подвергаются страничному вытеснению, как и пользовательские сегменты.<o:p></o:p></span></p> <p><span>Обычно аппаратура накладывает свои ограничения на порядок использования виртуального адресного пространства. Некоторые процессоры (например, MIPS) предусматривают для определенной области системной части адресного пространства особые правила отображения на физическую память. При этом виртуальный адрес прямо отображается на физический адрес (последний либо полностью соответствует виртуальному адресу, либо равен его части). Такая особая область памяти не подвергается страничному вытеснению, и поскольку достаточно трудоемкая процедура преобразования адресов исключается, то доступ к располагаемым здесь кодам и данным осуществляется очень быстро.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>5.3 </span></b><b><span>Методы распределения памяти<o:p></o:p></span></b></p> <p><span>Следует ли назначать каждому процессу одну непрерывную область физической памяти или можно выделять память «кусками»? Должны ли сегменты программы, загруженные в память, находиться на одном месте в течение всего периода выполнения процесса или можно ее время от времени сдвигать? Что делать, если сегменты программы не помещаются в имеющуюся память? Разные ОС по-разному отвечают на эти и другие базовые вопросы управления памятью. Далее будут рассмотрены наиболее общие подходы к распределению памяти, которые были характерны для разных периодов развития операционных систем. Некоторые из них сохранили актуальность и широко используются в современных ОС, другие же представляют в основном только познавательный интерес, хотя их и сегодня можно встретить в специализированных системах.<o:p></o:p></span></p> <p><span>На (рисунок 7) все алгоритмы распределения памяти разделены на два класса: алгоритмы, в которых используется перемещение сегментов процессов между оперативной памятью и диском, и алгоритмы, в которых внешняя память не привлекается.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_27" o:spid="_x0000_i1031"
 type="#_x0000_t75" style='width:461.25pt;height:217.5pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image012.png" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№5.files/image013.gif" v:shapes="Рисунок_x0020_27"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок<a></a><a></a><span> </span>7 – Классификация методов распределения памяти<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>5.4</span></b><b><span> Понятие «виртуальная память»<o:p></o:p></span></b></p> <p><span>Уже достаточно давно пользователи столкнулись с проблемой размещения в памяти программы, размер которой превышает имеющуюся в наличии свободную память. Одним из первых решений было разбиение программы на части, называемые оверлеями. Когда первый оверлей заканчивал свое выполнение, он вызывал другой оверлей. Все оверлеи хранились на диске и перемещались между памятью и диском средствами операционной системы на основании явных директив программиста, содержащихся в программе. Этот способ, несмотря на внешнее сходство, имеет принципиальное отличие от виртуальной памяти, заключающееся в том, что разбиение программы на части и планирование их загрузки в оперативную память должны были выполняться заранее программистом во время написания программы.<o:p></o:p></span></p> <p><span>Виртуализация памяти может быть осуществлена на основе двух различных подходов:<o:p></o:p></span></p> <p> <span>свопинг (swapping) – образы процессов выгружаются на диск и возвращаются в оперативную память целиком;<o:p></o:p></span></p> <p> <span>виртуальная память (virtual memory) – между оперативной памятью и диском перемещаются части (сегменты, страницы и т. п.) образов процессов.<o:p></o:p></span></p> <p><span>Большое количество задач, необходимое для высокой загрузки процессора, требует большого объема оперативной памяти. В условиях, когда для обеспечения приемлемого уровня мультипрограммирования имеющейся оперативной памяти недостаточно, был предложен метод организации вычислительного процесса, при котором образы некоторых процессов целиком или частично временно выгружаются на диск.<o:p></o:p></span></p> <p><span>В мультипрограммном режиме помимо активного процесса, то есть процесса, коды которого в настоящий момент интерпретируются процессором, имеются приостановленные процессы, находящиеся в ожидании завершения ввода-вывода или освобождения ресурсов, а также процессы в состоянии готовности, стоящие в очереди к процессору. Образы таких неактивных процессов могут быть временно, до следующего цикла активности, выгружены на диск. Несмотря на то, что коды и данные процесса отсутствуют в оперативной памяти, ОС «знает» о его существовании и в полной мере учитывает это при распределении процессорного времени и других системных ресурсов. К моменту, когда подходит очередь выполнения выгруженного процесса, его образ возвращается с диска в оперативную память. Если при этом обнаруживается, что свободного места в оперативной памяти не хватает, то на диск выгружается другой процесс.<o:p></o:p></span></p> <p><span>Такая подмена (виртуализация) оперативной памяти дисковой памятью позволяет повысить уровень мультипрограммирования – объем оперативной памяти компьютера теперь не столь жестко ограничивает количество одновременно выполняемых процессов, поскольку суммарный объем памяти, занимаемой образами этих процессов, может существенно превосходить имеющийся объем оперативной памяти. Виртуальным называется ресурс, который пользователю или пользовательской программе представляется обладающим свойствами, которыми он в действительности не обладает. В данном случае в распоряжение прикладного программиста предоставляется виртуальная оперативная память, размер которой намного превосходит всю имеющуюся в системе реальную оперативную память. Пользователь пишет программу, а транслятор, используя виртуальные адреса, переводит ее в машинные коды так, как будто в распоряжении программы имеется однородная оперативная память большого объема. В действительности же все коды и данные, используемые программой, хранятся на дисках и только при необходимости загружаются в реальную оперативную память. Понятно, однако, что работа такой «оперативной памяти» происходит значительно медленнее.<o:p></o:p></span></p> <p><span>Виртуализация оперативной памяти осуществляется совокупностью программных модулей ОС и аппаратных схем процессора и включает решение следующих задач:<o:p></o:p></span></p> <p> <span>размещение данных в запоминающих устройствах разного типа, например часть кодов программы – в оперативной памяти, а часть – на диске;<o:p></o:p></span></p> <p> <span>выбор образов процессов или их частей для перемещения из оперативной памяти на диск и обратно;<o:p></o:p></span></p> <p> <span>перемещение по мере необходимости данных между памятью и диском;<o:p></o:p></span></p> <p> <span>преобразование виртуальных адресов в физические.<o:p></o:p></span></p> <p><span>Очень важно то, что все действия по организации совместного использования диска и оперативной памяти – выделение места для перемещаемых фрагментов, настройка адресов, выбор кандидатов на загрузку и выгрузку – осуществляются операционной системой и аппаратурой процессора автоматически, без участия программиста, и никак не сказываются на логике работы приложений.<o:p></o:p></span></p> <p><span>Свопинг представляет собой частный случай виртуальной памяти и, следовательно, более простой в реализации способ совместного использования оперативной памяти и диска. Однако подкачке свойственна избыточность: когда ОС решает активизировать процесс, для его выполнения, как правило, не требуется загружать в оперативную память все его сегменты полностью – достаточно загрузить небольшую часть кодового сегмента с подлежащей выполнению инструкцией и частью сегментов данных, с которыми работает эта инструкция, а также отвести место под сегмент стека. Аналогично при освобождении памяти для загрузки нового процесса очень часто вовсе не требуется выгружать другой процесс на диск целиком, достаточно вытеснить на диск только часть его образа. Перемещение избыточной информации замедляет работу системы, а также приводит к неэффективному использованию памяти. Кроме того, системы, поддерживающие свопинг, имеют еще один очень существенный недостаток: они не способны загрузить для выполнения процесс, виртуальное адресное пространство которого превышает имеющуюся в наличии свободную память.<o:p></o:p></span></p> <p><span>Именно из-за указанных недостатков свопинг как основной механизм управления памятью почти не используется в современных ОС. На смену ему пришел более совершенный механизм виртуальной памяти, который, как уже было сказано, заключается в том, что при нехватке места в оперативной памяти на диск выгружаются только части образов процессов.<o:p></o:p></span></p> <p><span>Ключевой проблемой виртуальной памяти, возникающей в результате многократного изменения местоположения в оперативной памяти образов процессов или их частей, является преобразование виртуальных адресов в физические. Решение этой проблемы, в свою очередь, зависит от того, какой способ структуризации виртуального адресного пространства принят в данной системе управления памятью. В настоящее время все множество реализаций виртуальной памяти может быть представлено тремя классами.<o:p></o:p></span></p> <p><span>Страничная виртуальная память организует перемещение данных между памятью и диском страницами – частями виртуального адресного пространства, фиксированного и сравнительно небольшого размера.<o:p></o:p></span></p> <p><span>Сегментная виртуальная память предусматривает перемещение данных сегментами – частями виртуального адресного пространства произвольного размера, полученными с учетом смыслового значения данных.<o:p></o:p></span></p> <p><span>Сегментно-страничная виртуальная память использует двухуровневое деление: виртуальное адресное пространство делится на сегменты, а затем сегменты делятся на страницы. Единицей перемещения данных здесь является страница. Этот способ управления памятью объединяет в себе элементы обоих предыдущих подходов.<o:p></o:p></span></p> <p><span>Для временного хранения сегментов и страниц на диске отводится либо специальная область, либо специальный файл, которые во многих ОС по традиции продолжают называть областью, или файлом свопинга, хотя перемещение информации между оперативной памятью и диском осуществляется уже не в форме полного замещения одного процесса другим, а частями. Другое популярное название этой области – страничный файл (<i>page file</i>, или <i>paging file</i>). Текущий размер страничного файла является важным параметром, оказывающим влияние на возможности операционной системы: чем больше страничный файл, тем больше приложений может одновременно выполнять ОС (при фиксированном размере оперативной памяти). Однако необходимо понимать, что увеличение числа одновременно работающих приложений за счет увеличения размера страничного файла замедляет их работу, так как значительная часть времени при этом тратится на перекачку кодов и данных из оперативной памяти на диск и обратно. Размер страничного файла в современных ОС является настраиваемым параметром, который выбирается администратором системы для достижения компромисса между уровнем мультипрограммирования и быстродействием системы.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>5.5 Получение системной информации о виртуальной памяти<o:p></o:p></span></b></p> <p><span>Многие параметры операционной системы (размер страницы, гранулярность выделения памяти и др.) зависят от используемого в компьютере процессора. Поэтому нельзя жестко «зашивать» их значения в исходный код программ. Эту информацию необходимо считывать в момент инициализации процесса с помощью функции <b>GetSystemInfo</b>, объявление которой выглядит следующим образом:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> </span><span>VOID <b>GetSystemInfo</b> (LPSYSTEM_INFO </span><i><span>psinf</span></i><span>);<o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>В <b>GetSystemInfo</b><i> </i>передаётся адрес структуры <b>SYSTEM_INFO</b>, а функция инициализирует (заполняет определенными значениями) элементы этой структуры:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>typedef struct _SYSTEM_INFO {<o:p></o:p></span></p> <p><span>union {<o:p></o:p></span></p> <p><span>DWORD dwOemld</span><span>; <i>//не используйте этот элемент, он устарел</i><o:p></o:p></span></p> <p><span>struct {<o:p></o:p></span></p> <p><span>WORD wProcessorArchitecture;<o:p></o:p></span></p> <p><span>WORD wReserved;<o:p></o:p></span></p> <p><span> };<o:p></o:p></span></p> <p><span> };<o:p></o:p></span></p> <p><span>DWORD dwPageSize;<o:p></o:p></span></p> <p><span>LPVOID lpMinimumApplicationAddress;<o:p></o:p></span></p> <p><span>LPVOID lpMAXimumApplicationAddress;<o:p></o:p></span></p> <p><span>DWORD_PTR dwActiveProcessorMask;<o:p></o:p></span></p> <p><span>DWORD dwNumberOf Processors;<o:p></o:p></span></p> <p><span>DWORD dwProcessorType;<o:p></o:p></span></p> <p><span>DWORD dwAllocationGranularity;<o:p></o:p></span></p> <p><span>WORD wProcessor Level;<o:p></o:p></span></p> <p><span>WORD wProcessorRevision;<o:p></o:p></span></p> <p><span>} SYSTEM_INFO, *LPSYSTEM_INFO;<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>При загрузке система определяет значения элементов этой структуры, для конкретной системы эти значения постоянны. Функция <b>GetSystemInfo</b>предусмотрена специально для того, чтобы приложения могли получать эту информацию. Из всех элементов структуры лишь четыре имеют отношение к памяти. Они описаны в таблице 2.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><span>Таблица <a></a>2 – Элементы структуры SYSTEM_INFO<o:p></o:p></span></p> <div style="text-align: center;"> <table border="1" cellspacing="0" cellpadding="0" width="643" style="margin:0 auto;"> <tr> <td width="251"> <p style="text-align: center;"><b><span>Элемент</span></b><span><o:p></o:p></span></p> </td> <td width="365"> <p style="text-align: center;"><b><span>Описание</span></b><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="251" valign="top"> <p><i><span>dwPageSize</span></i><span><o:p></o:p></span></p> </td> <td width="365" valign="top"> <p><span>Размер страницы памяти. На процессорах <i>х8б </i>это значение равно 4096, а на процессорах Alpha – 8192 байтам<o:p></o:p></span></p> </td> </tr> <tr> <td width="251" valign="top"> <p><i><span>l</span></i><i><span>pMinimu</span></i><i><span>m</span></i><i><span>ApplicationAddress</span></i><span><o:p></o:p></span></p> </td> <td width="365" valign="top"> <p><span>Минимальный адрес памяти доступного адресного пространства для каждого процесса.<o:p></o:p></span></p> <p><span>В Windows 98 это значение равно 4 194 304, или 0x00400000, поскольку нижние 4</span><span> </span><span>Мб адресного пространства каждого процесса недоступны.<o:p></o:p></span></p> <p><span>В Windows 2000 это значение равно 65 536, или 0x00010000, так как в этой системе резервируются лишь первые 64 Кб адресного пространства каждого процесса<o:p></o:p></span></p> </td> </tr> <tr> <td width="251" valign="top"> <p><i><span>l</span></i><i><span>pMAXimumApplicationAddress</span></i><span><o:p></o:p></span></p> </td> <td width="365" valign="top"> <p><span>Максимальный адрес памяти доступного адресного пространства, отведенного в «личное пользование» каждому процессу.<o:p></o:p></span></p> <p><span>В Windows 98 этот адрес равен 2 147 483 647, или Ox7FFFFFFF, так как верхние 2 Гб занимают общие файлы, проецируемые в память, и разделяемый код операционной системы. В Windows 2000 этот адрес соответствует началу раздела для кода и данных режима ядра за вычетом 64 Кб<o:p></o:p></span></p> </td> </tr> <tr> <td width="251" valign="top"> <p><i><span>dwAllocationGranularity</span></i><span><o:p></o:p></span></p> </td> <td width="365" valign="top"> <p><span>Гранулярность резервирования регионов адресного пространства. На момент написания пособия это значение составляет 64 Кб для всех платформ Windows<o:p></o:p></span></p> </td> </tr> </table> </div> <p><span> <o:p></o:p></span></p> <p><span>При запуске приложения система открывает его исполняемый файл и определяет объем кода и данных. Затем резервирует регион адресного пространства и помечает, что физическая память, связанная с этим регионом, это сам ЕХЕ-файл. Вместо выделения какого-то пространства из страничного файла система использует истинное содержимое или <i>образ </i>(image) ЕХЕ-файла как зарезервированный регион адресного пространства программы. Благодаря этому приложение загружается очень быстро, а размер страничного файла заметно уменьшается.<o:p></o:p></span></p> <p><span>Образ исполняемого файла (ЕХЕ- или DLL-файл), размещенный на жестком диске и применяемый как физическая память для того или иного региона адресного пространства, называется<i>проецируемым в память файлом </i>(memory-mapped file). При загрузке ЕХЕ- или DLL-файла система автоматически резервирует регион адресного пространства и проецирует на него образ файла.<o:p></o:p></span></p> <p><span>Остальные элементы структуры <b>SYSTEM_INFO</b> показаны в таблице 3.<o:p></o:p></span></p> <p><b><span> <o:p></o:p></span></b></p> <p style="text-align: center;"><span>Таблица <a></a>3 − Специальные элементы структуры SYSTEM_INFO<o:p></o:p></span></p> <div style="text-align: center;"> <table border="1" cellspacing="0" cellpadding="0" width="643" style="margin:0 auto;"> <tr> <td width="234"> <p style="text-align: center;"><b><span>Элемент</span></b><span><o:p></o:p></span></p> </td> <td width="416"> <p style="text-align: center;"><b><span>Описание</span></b><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>dwOemld</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Устарел; больше не используется<o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>w</span></i><i><span>Reserved</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Зарезервирован на будущее; пока не используется<o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>dwNumberO</span></i><i><span>f</span></i><i><span>Processors</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Число процессоров в компьютере<o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>dwActiveProcessorMask</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Битовая маска, которая сообщает, какие процессоры активны<o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>dwProcessorType</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Используется только в Windows 98; сообщает тип процессора, например Intel 386, 486 или Pentium<o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><a></a><a></a><span><i><span>dw</span></i></span><span><i><span>ProcessorArchitecture</span></i></span><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Используется только в Windows 2000; сообщает тип архитектуры процессора, например Intel, Alpha,<o:p></o:p></span></p> <p><span>64-разрядный Intel или 64-разрядный Alpha<o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>wProcessorLevel</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Используется только в Windows 2000 и </span><span>XP</span><span>; сообщает дополнительные подробности об архитектуре процессора, например Intel </span><span>Pentium Pro</span><span> или </span><span>Pentium II</span><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="234"> <p><i><span>wProcessorRevision</span></i><span><o:p></o:p></span></p> </td> <td width="416" valign="top"> <p><span>Используется только в Windows 2000 и </span><span>XP</span><span>; сообщает дополнительные подробности об уровне данной архитектуры процессора<o:p></o:p></span></p> </td> </tr> </table> </div> <p><span><o:p> </o:p></span></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>5.6 Резервирование и освобождение памяти<o:p></o:p></span></b></p> <p><span>Как уже отмечалось, адресное пространство, выделяемое процессу в момент создания, изначально практически все <i>свободно </i>(незарезервировано). Поэтому, чтобы воспользоваться какой-нибудь его частью,<i> </i>нужно выделить в нем определенные регионы через функцию <b>VirtualAlloc</b><i>.</i><o:p></o:p></span></p> <p><span>При резервировании система обязательно выравнивает начало региона с учетом так называемой <i>гранулярности выделения памяти.</i><o:p></o:p></span></p> <p><span>Размер страницы можно узнать, воспользовавшись вышеописанной функцией <b>GetSystemInfo,</b> а точнее, полем <i>dwPageSize</i> структуры <b>SYSTEM_INFO</b><i>.</i><o:p></o:p></span></p> <p><span>Итак, прежде чем осуществить какую-либо операцию с памятью для текущего приложения (например сохранить временные данные по определенному адресу из доступного приложению адресного пространства), необходимо выполнить следующую последовательность действий:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>зарезервировать регион(-ы) адресного пространства;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>передать зарезервированному(-ым) региону(-нам) физическую память из страничного файла.<o:p></o:p></span></p> <p><span>Для этого предназначена функция <b>VirtualAlloc</b><i>:</i><o:p></o:p></span></p> <p><i><span> </span></i><span><o:p></o:p></span></p> <p style="text-align: center;"><span>PVOID <b>VirtualAlloc</b>(PVOID <i>pvAddress</i>, SIZE_T <i>dwSize</i>,<o:p></o:p></span></p> <p style="text-align: center;"><span>DWORD <i>fdwAllocationType</i></span><span>, </span><span>DWORD <i>fdwProtect</i></span><span>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В параметре <i>pvAddre</i></span><i><span>ss </span></i><span>содержится адрес памяти, указывающий, где именно система должна зарезервировать адресное пространство. Обычно в качестве этого параметра передают значение NULL, тем самым сообщая функции <b>VirtualAlloc</b>,<i> </i>что ведущая учет свободных областей система должна зарезервировать регион там, где, по ее мнению, будет лучше. Поэтому нет никаких гарантий, что система станет резервировать регионы, начиная с нижних адресов или, наоборот, с верхних.<o:p></o:p></span></p> <p><span>Так как регионы всегда резервируются с учетом гранулярности выделения памяти, то все адреса резервируемых регионов кратны 64 Кб.<o:p></o:p></span></p> <p><span>Параметр <i>dwSize </i>указывает размер резервируемого региона в байтах. Поскольку система резервирует регионы только порциями, которые кратны размеру страницы, то попытка зарезервировать 62 Кб даст регион размером 64 Кб (если размер страницы составляет 4, 8 или 16 Кб).<o:p></o:p></span></p> <p><span>Параметр<i> fdwAllocationType </i>сообщает системе, что именно необходимо сделать: зарезервировать регион или передать физическую память. Такое разграничение необходимо, поскольку<b>VirtualAlloc</b><i> </i>позволяет не только резервировать регионы, но и передавать им физическую память. Чтобы зарезервировать регион адресного пространства, в этом параметре нужно передать идентификатор MEM_RESERVE.<o:p></o:p></span></p> <p><span>Чтобы зарезервировать регион по самым старшим адресам, при вызове функции <b>VirtualAlloc</b><i> </i>в параметре <i>pvAddress </i>необходимо передать NULL, а в качестве параметра </span><i><span>fdwAllocationType</span></i><i><span>– </span></i><span>флаг </span><span>MEM</span><span>_</span><span>RESERVE</span><span>, скомбинированный с флагом </span><span>MEM</span><span>_</span><span>TOP</span><span>_</span><span>DOWN</span><span>.<o:p></o:p></span></p> <p><span>Параметр </span><i><span>fdwProtect </span></i><span>указывает атрибут защиты, присваиваемый региону. Атрибут защиты можно охарактеризовать как управляющий набор флагов, позволяющий производить с памятью те или иные действия (в зависимости от его значения). Атрибут защиты, связанный с регионом, не влияет на память, отображаемую на этот регион. Но если ему не передана физическая память, то, какой бы атрибут защиты у него ни был, любая попытка обращения по одному из адресов в этом диапазоне приведет к нарушению доступа для данного потока.<o:p></o:p></span></p> <p><span>Чтобы зарезервированный регион адресного пространства можно было использовать, необходимо выделить физическую память и спроецировать ее на этот регион (операция <i>передачи физической памяти</i>). Для передачи физической памяти зарезервированному региону необходимо также обращаться к функции <b>VirtualAlloc</b><i>.</i> Передавая физическую память регионам, нет нужды отводить ее целому региону. Можно зарезервировать регион размером 64 Кб и передать физическую память только его второй и четвертой страницам. Когда приложение передает физическую память какому-нибудь региону адресного пространства (вызывая <b>VirtualAlloc</b>),<i> </i>она на самом деле выделяется из файла, размещенного на жестком диске. Размер страничного файла в системе – главный фактор, определяющий количество физической памяти, доступное приложениям.<o:p></o:p></span></p> <p><span>Для передачи физической памяти необходимо вызвать <b>VirtualAlloc</b><i> </i>еще раз, указав в параметре </span><i><span>fdwAllocationType </span></i><span>не MEM_RESERVE, а МЕМ_СОММIТ. Обычно указывается тот же атрибут защиты, что и при резервировании региона, хотя можно задавать и другой. Функции <b>VirtualAlloc</b> также сообщается,<i> </i>по какому адресу и сколько физической памяти следует передать. Для этого в параметр </span><i><span>pvAddress </span></i><span>записывается желательный адрес, а в параметр </span><i><span>dwSize </span></i><i><span>–</span></i><span> размер физической памяти в байтах. Передавать физическую память сразу всему региону необязательно.<o:p></o:p></span></p> <p><span>Например, необходимо зарезервировать регион для текущего приложения размером 2 страницы и затем передать 1-й странице физическую память размером в 1 страницу. Код будет выглядеть следующим образом.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>SystemInfo info</span><span>; <i>// объявляем переменную для хранения</i><o:p></o:p></span></p> <p><i><span> структуры </span></i><i><span>TSystemInfo</span></i><span><o:p></o:p></span></p> <p><span>GetSystemInfo</span><span>(&</span><span>inf</span><span>);<i>//в качестве параметра функции</i><o:p></o:p></span></p> <p><i><span> передаётся адрес структуры</span></i><span><o:p></o:p></span></p> <p><span>int PAGE</span><span>_</span><span>SIZE</span><span> = </span><span>int</span><span>(</span><span>inf</span><span>.</span><span>dwPageSize</span><span>); <i>//размер страницы</i><o:p></o:p></span></p> <p><i><span> </span></i><span><o:p></o:p></span></p> <p><i><span> </span></i><span><o:p></o:p></span></p> <p><i><span> // резервируем регион для текущего приложения<o:p></o:p></span></i></p> <p><i><span> // размером 2 страницы:<o:p></o:p></span></i></p> <p><span>PVOID adr1 = VirtualAlloc(NULL,2* PAGE_SIZE,<o:p></o:p></span></p> <p><span>MEM_RESERVE|MEM_TOP_DOWN,PAGE_READWRITE);<o:p></o:p></span></p> <p><span>if(adr1==NULL){Exit(0);}<o:p></o:p></span></p> <p><span>VirtualAlloc(adr1, PAGE_SIZE,MEM_COMMIT,PAGE_READWRITE);<o:p></o:p></span></p> <p><i><span> </span></i><i><span>// передаем 1-й странице физическую память размером<o:p></o:p></span></i></p> <p><i><span> в 1 страницу<o:p></o:p></span></i></p> <p><span>//-----------------------------------------------------<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Если функция <b>VirtualAlloc</b> в состоянии удовлетворить запрос (зарезервировать регион), она возвращает базовый адрес зарезервированного региона (запоминается в переменной adr1). Если параметр <i>pvAddress</i> содержал конкретный адрес, функция возвращает этот адрес, округленный при необходимости до меньшей величины, кратной 64 Кб. Если по этому адресу можно разместить регион требуемого размера, система зарезервирует его и вернет соответствующий адрес. Если же по этому адресу свободного пространства недостаточно или просто нет, система не удовлетворит запрос, и функция <b>VirtualAlloc</b> вернет NULL. Поэтому адрес, передаваемый в <i>pvAddress</i>, должен укладываться в границы раздела пользовательского режима процесса.<o:p></o:p></span></p> <p><span>После того, как физическая память зарезервирована и передана региону, можно обращаться к этой памяти для сохранения данных. Для этого можно воспользоваться функциями<b>FillMemory</b>,<i> </i><b>CopyMemory</b>,<i> </i><b>ZeroMemory</b>.<o:p></o:p></span></p> <p><span>С помощью функции <b>FillMemory</b> можно заполнять участки памяти определёнными значениями:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>void <b>FillMemory</b>(PVOID <i>Destination</i>, SIZE_T <i>Length</i>, BYTE <i>Fill</i>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Назначения параметров этой функции показаны в таблице 4.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Таблица <a></a>4 – Назначения параметров функции </span><i><span>FillMemory</span></i><span><o:p></o:p></span></p> <table border="1" cellspacing="0" cellpadding="0" width="709" style="margin:0 auto;"> <tr> <td width="168"> <p style="text-align: center;"><b><span>Параметр</span></b><span><o:p></o:p></span></p> </td> <td width="540"> <p style="text-align: center;"><b><span>Описание</span></b><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="168" valign="top"> <p><i><span>Destination</span></i><span><o:p></o:p></span></p> </td> <td width="540" valign="top"> <p><span>Указатель начального адреса блока памяти, который необходимо заполнить значениями </span><i><span>Fill</span></i><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="168" valign="top"> <p><i><span>Length</span></i><span><o:p></o:p></span></p> </td> <td width="540" valign="top"> <p><span>Размер блока в памяти (в байтах), который необходимо заполнить<o:p></o:p></span></p> </td> </tr> <tr> <td width="168" valign="top"> <p><i><span>Fill</span></i><span><o:p></o:p></span></p> </td> <td width="540" valign="top"> <p><span>Значение, которым необходимо заполнить блок памяти<o:p></o:p></span></p> </td> </tr> </table> <p><span> <o:p></o:p></span></p> <p><span>Например, в качестве последней строки можно написать:<o:p></o:p></span></p> <p style="text-align: center;"><span> <o:p></o:p></span></p> <p style="text-align: center;"><b><span>FillMemory</span></b><span>(</span><span>adr</span><span>1, </span><span>PAGE</span><span>_</span><span>SIZE</span><span>, 1);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В результате блок памяти размером PAGE_SIZE, начиная с адреса </span><i><span>adr</span></i><i><span>1,</span></i><b><span> </span></b><span>будет заполнен значениями <i>1</i>.<o:p></o:p></span></p> <p><span>С помощью функции <b>CopyMemory</b> можно копировать значения из одного участка памяти в другой:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>void <b>CopyMemory</b>(PVOID Destination, const VOID* Source, SIZE_T Length);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Назначения параметров этой функции показаны в таблице 5.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Таблица <a></a>5 – Назначения параметров функции <b>CopyMemory</b><o:p></o:p></span></p> <div style="text-align: center;"> <table border="1" cellspacing="0" cellpadding="0" width="716" style="margin:0 auto;"> <tr> <td width="175"> <p style="text-align: center;"><b><span>Параметр</span></b><span><o:p></o:p></span></p> </td> <td width="541"> <p style="text-align: center;"><b><span>Описание</span></b><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="175" valign="top"> <p><i><span>Destination</span></i><span><o:p></o:p></span></p> </td> <td width="541" valign="top"> <p><span>Указатель начального адреса блока памяти, в который будем осуществлять копирование<o:p></o:p></span></p> </td> </tr> <tr> <td width="175" valign="top"> <p><i><span>Source</span></i><span><o:p></o:p></span></p> </td> <td width="541" valign="top"> <p><span>Указатель начального адреса блока памяти, из которого будем осуществлять копирование<o:p></o:p></span></p> </td> </tr> <tr> <td width="175" valign="top"> <p><i><span>Length</span></i><span><o:p></o:p></span></p> </td> <td width="541" valign="top"> <p><span>Размер копируемого блока памяти в байтах<o:p></o:p></span></p> </td> </tr> </table> </div> <p><span> <o:p></o:p></span></p> <p><span>С помощью функции <b>ZeroMemory</b> можно заполнять участки памяти нулевыми значениями (обнулять):<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>void<i> </i><b>ZeroMemory</b><i> </i>(PVOID<i> Destination</i>, SIZE_T<i> Length</i>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Назначения параметров этой функции показаны в таблице 6.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Таблица <a></a>6 – Назначения параметров функции <b>ZeroMemory</b><o:p></o:p></span></p> <div style="text-align: center;"> <table border="1" cellspacing="0" cellpadding="0" width="716" style="margin:0 auto;"> <tr> <td width="164"> <p style="text-align: center;"><b><span>Параметр</span></b><span><o:p></o:p></span></p> </td> <td width="552"> <p style="text-align: center;"><b><span>Описание</span></b><span><o:p></o:p></span></p> </td> </tr> <tr> <td width="164" valign="top"> <p><i><span>Destination</span></i><span><o:p></o:p></span></p> </td> <td width="552" valign="top"> <p><span>Указатель начального адреса блока памяти, который будем обнулять<o:p></o:p></span></p> </td> </tr> <tr> <td width="164" valign="top"> <p><i><span>Length</span></i><span><o:p></o:p></span></p> </td> <td width="552" valign="top"> <p><span>Размер этого блока памяти в байтах<o:p></o:p></span></p> </td> </tr> </table> </div> <p><span> <o:p></o:p></span></p> <p><span>Например, в качестве последней строки <i>Листинга 3 </i>можно написать:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><b><span>ZeroMemory</span></b><span>(</span><span>adr</span><span>1, </span><span>PAGE</span><span>_</span><span>SIZE</span><span>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В результате блок памяти размером PAGE_SIZE, начиная с адреса </span><i><span>adr</span></i><i><span>1, </span></i><span>будет заполнен значениями <i>0.</i><o:p></o:p></span></p> <p><span>Когда зарезервированный регион адресного пространства становится не нужен, его следует вернуть в общие ресурсы системы. Эта операция называется <i>освобождение </i>(releasing) региона. Для возврата физической памяти, отображенной на регион, или освобождения всего региона адресного пространства используется функция <b>VirtualFree</b><i>:</i><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>BOOL<i> </i><b>VirtualFree</b><i> </i>(LPVOID <i>lpAddress, </i>SIZE_T<i> dwSize,</i><o:p></o:p></span></p> <p style="text-align: center;"><span>DWORD<i> dwFreeType</i></span><span>);<o:p></o:p></span></p> <p><i><span> </span></i><span><o:p></o:p></span></p> <p><span>Рассмотрим простейший случай вызова этой функции – для освобождения зарезервированного региона. Когда процессу больше не нужна физическая память, переданная региону, зарезервированный регион и всю связанную с ним физическую память можно освободить единственным вызовом <b>VirtualFree</b><i>.</i> В этом случае в параметр </span><i><span>pvAddress </span></i><span>надо поместить базовый адрес региона, т.е. значение, возвращенное функцией <b>VirtualAlloc</b><i> </i>после резервирования данного региона. Системе известен размер региона, расположенного по указанному адресу, поэтому в параметре </span><i><span>dwSize </span></i><span>можно передать 0. Фактически это необходимо сделать, иначе вызов </span><i><span>VirtualFree </span></i><span>не даст результата. В параметре </span><i><span>dwFreeType </span></i><span>передаётся идентификатор MEM_RELEASE, что приводит к возврату системе всей физической памяти, отображенной на регион, и к освобождению самого региона. Освобождая регион, необходимо освободить и зарезервированное под него адресное пространство. Нельзя выделить регион размером, допустим, 128 Кб, а потом освободить только 64 Кб – надо освобождать все 128 Кб.<o:p></o:p></span></p> <p><span>Если нужно, не освобождая регион, вернуть в систему часть физической памяти, переданной региону, для этого тоже следует вызвать <b>VirtualFree</b><i>. </i>При этом ее параметр </span><i><span>pvAddress</span></i><span>должен содержать адрес, указывающий на первую возвращаемую страницу. Кроме того, в параметре </span><i><span>dwSize </span></i><span>задаётся количество освобождаемых байтов, а в параметре </span><i><span>dwFreeType </span></i><i><span>–</span></i><span>идентификатор MEM_DECOMMIT.<o:p></o:p></span></p> <p><span>Как и передача, возврат памяти осуществляется с учетом размерности страниц. Иначе говоря, задание адреса, указывающего на середину страницы, приведет к возврату всей страницы. Разумеется, то же самое произойдет, если суммарное значение параметров </span><i><span>pvAddress </span></i><span>и </span><i><span>dwSize </span></i><span>выпадет на середину страницы. Системе возвращаются все страницы, попадающие в диапазон от</span><i><span>pvAddress </span></i><span>до<b> </b></span><i><span>pvAddress</span></i><i><span> + </span></i><i><span>dwSize</span></i><i><span>.</span></i><span><o:p></o:p></span></p> <p><span>Если же параметр </span><i><span>dwSize </span></i><span>равен 0, a </span><i><span>pvAddress </span></i><span>указывает на базовый адрес выделенного региона, <b>VirtualFree</b><i> </i>вернет системе весь диапазон выделенных страниц. После возврата физической памяти освобожденные страницы доступны любому другому процессу, а попытка обращения к адресам, уже не связанным с физической памятью, приведет к нарушению доступа.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>5.7 Сброс содержимого физической памяти<o:p></o:p></span></b></p> <p><span>В </span><span>Windows c</span><span> помощью специальных функций можно заблокировать определённые регионы памяти и запретить их сброс из физической памяти в дисковую. Для этого используются функции <b>VirtualLock</b> и <b>VirtualUnLock</b>.<o:p></o:p></span></p> <p><span>Также имеется возможность сброса содержимого физической памяти. Когда модифицируется содержимое страниц физической памяти, система пытается как можно дольше хранить эти изменения в оперативной памяти. Однако, выполняя приложения, система постоянно получает запросы на загрузку в оперативную память страниц из ЕХЕ-файлов, </span><span>DLL</span><span> и/или страничного файла. Любой такой запрос заставляет систему просматривать оперативную память и выгружать модифицированные страницы в страничный файл.<o:p></o:p></span></p> <p><span>Windows</span><span> 2000/</span><span>XP </span><span>позволяет программам увеличить свою производительность за счет сброса физической памяти. Если система в процессе поиска свободной страницы в оперативной памяти выбирает измененную страницу, то должна сначала записать ее в страничный файл. Эта операция отнимает довольно много времени и отрицательно сказывается на производительности. Поэтому в большинстве приложений желательно, чтобы система как можно дольше хранила модифицированные страницы в страничном файле.<o:p></o:p></span></p> <p><span>Однако некоторые программы занимают блоки памяти на очень малое время, а потом им уже не требуется их содержимое. Для большего быстродействия программа может попросить систему не записывать определенные страницы в страничный файл. И тогда, если одна из этих счраниц понадобится для других целей, системе не придется сохранять ее в страничном файле, чт</span><span>o</span><span>, естественно, повысит скорость работы программы. Такой отказ от страницы (или страниц) памяти называется сбросом физической памяти (</span><span>resetting of physical storage</span><span>) и инициируется вызовом функции </span><b><span>VirtualAlloc</span></b><span> с передачей ей в третьем параметре флага </span><b><span>MEM</span></b><b><span>_</span></b><b><span>RESET</span></b><span>.<o:p></o:p></span></p> <p><span>При сбросе физической памяти надо учитывать, что когда вызывается <b>VirtualAlloc</b>, базовый адрес обычно округляется до ближайшего меньшего значения, кратного размеру страниц, а количество байтов — до ближайшего большего значения, кратного той же величине. Такой механизм округления базового адреса и количества байтов был бы очень опасен при сбросе физической памяти; поэтому </span><span>VirtualAlloc</span><span> при передаче ей флага </span><span>MEMRESET</span><span> округляет эти значения прямо наоборот. Второе, о чем следует помнить при сбросе памяти, — флаг </span><span>MEM</span><span>_</span><span>RESET</span><span> нельзя комбинировать (логической операцией </span><span>OR</span><span>) ни с какими другими флагами. И, наконец, последнее. Вызов <b>VirtualAlloc</b> с флагом </span><span>MEM</span><span>_</span><span>RESET</span><span> требует передачи корректного атрибута защиты страницы, даже несмотря на то что он не будет использоваться данной функцией.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>5.8 Понятие и назначение динамически подключаемых библиотек<o:p></o:p></span></b></p> <p><b><span>DLL</span></b><span> (Dynamic Linked Library – динамически компонуемая библиотека) – это программный модуль, содержащий код, ресурсы или какие-то иные данные.<o:p></o:p></span></p> <p><span>Для понимания разницы между </span><span>dll</span><span>-модулями и </span><span>exe</span><span>-приложениями требуется уточнить понятия задачи (task), экземпляра (копии) приложения (instance) и модуля (module). При запуске нескольких экземпляров одного приложения, Windows загружает в оперативную память только одну копию кода и ресурсов – модуль приложения, создавая несколько отдельных сегментов данных, стека и очереди сообщений (рисунок 8), каждый набор которых представляет из себя задачу, в понимании Windows. Копия приложения представляет из себя контекст, в котором выполняется модуль приложения.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_33" o:spid="_x0000_i1032"
 type="#_x0000_t75" style='width:275.25pt;height:180.75pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image014.jpg" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№5.files/image015.jpg" v:shapes="Рисунок_x0020_33"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>8 – Копии приложения и модуль приложения<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>DLL-библиотека также является модулем. Она находится в памяти в единственном экземпляре и содержит сегмент кода и ресурсы, а также сегмент данных (рисунок 9).<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_34" o:spid="_x0000_i1033"
 type="#_x0000_t75" style='width:141.75pt;height:120pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image016.jpg" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№5.files/image017.jpg" v:shapes="Рисунок_x0020_34"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>9 – Структура DLL в памяти<o:p></o:p></span></p> <p style="text-align: center;"><span><o:p> </o:p></span></p> <p><span>DLL-библиотека, в отличие от приложения не имеет ни стека, ни очереди сообщений. Функции, помещенные в DLL, выполняются в контексте вызвавшего приложения, пользуясь его стеком. Но эти же функции используют сегмент данных, принадлежащий библиотеке, а не копии приложения.<o:p></o:p></span></p> <p><span>В силу такой организации DLL, экономия памяти достигается за счет того, что все запущенные приложения используют один модуль DLL, не включая те или иные стандартные функции в состав своих модулей (рисунок 10).<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_35" o:spid="_x0000_i1034"
 type="#_x0000_t75" style='width:315pt;height:151.5pt;visibility:visible'>
 <v:imagedata src="Тема%20№5.files/image018.jpg" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№5.files/image019.jpg" v:shapes="Рисунок_x0020_35"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>10 – Вызов функций при использовании динамической компоновки<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>С точки зрения программиста – DLL представляет собой библиотеку функций (ресурсов), которыми может пользоваться любой процесс, загрузивший эту библиотеку. Но так как сама загрузка отнимает время и увеличивает расход потребляемой приложением памяти; сильное дробление одного приложения на множество DLL не является рациональным. Однако при использовании каких-то функций несколькими приложениями, поместив их в одну DLL, мы избавимся от дублирования кода и сократим общий объем приложений - и на диске, и в оперативной памяти.<o:p></o:p></span></p> <p><span>Динамически подключаемые библиотеки – краеугольный камень операционной системы Windows, начиная с самой первой ее версии. В DLL содержатся все функции Windows API. Три самые важные DLL: Kernel32.dll (управление памятью, процессами и потоками), User32.dll (поддержка пользовательского интерфейса, в том числе функции, связанные с созданием окон и передачей сообщений) и GDI32.dll (графика и вывод текста).<o:p></o:p></span></p> <p><span>В Windows есть и другие DLL, функции которых предназначены для более специализированных задач. Например, в AdvAPI32.dll содержатся функции для защиты объектов, работы с реестром и регистрации событий, в ComDlg32.dll ~ стандартные диалоговые окна (вроде File Open и File Save), a ComCrl32 dll поддерживает стандартные элементы управления.<o:p></o:p></span></p> <p><span>Основными причинами использования DLL можно назвать следующее.<o:p></o:p></span></p> <p><b><span>Расширение функциональности приложения. </span></b><span>DLL можно загружать в адресное пространство процесса динамически, что позволяет приложению, определив, какие действия от него требуются, подгружать нужный код, Поэтому одна компания, создав какое-то приложение, может предусмотреть расширение его функциональности за счет DLL от других компаний.<o:p></o:p></span></p> <p><b><span>Возможность использования разных языков программирования.</span></b><span> Всегда есть выбор, на каком языке писать ту или иную часть приложения. Так, пользовательский интерфейс приложения можно создавать на Microsoft Visual Basic, а прикладную логику реализовать на С++. Программа на Visual Basic может загружать DLL, написанные на С++, Коболе, Фортране и др.<o:p></o:p></span></p> <p><b><span>Более простое управление проектом. </span></b><span>Если в процессе разработки программного продукта отдельные его модули создаются разными группами, то при использовании DLL таким проектом управлять гораздо проще Однако конечная версия приложения должна включать как можно меньше файлов.<o:p></o:p></span></p> <p><b><span>Экономия памяти. </span></b><span>Если одну и ту же DLL использует несколько приложений, в оперативной памяти может храниться только один ее экземпляр, доступный этим приложениям. Пример — DLL-версия библиотеки С/С++. Ею пользуются многие приложения. Если всех их скомпоновать со статически подключаемой версией этой библиотеки, то код таких функций, как </span><i><span>sp</span></i><i><span>rintf, strcpy, malloc </span></i><span>и др., будет многократно дублироваться в памяти Но ссли они компонуются с DLL-версией библиотеки С/С++, в памяти будет присутствовать лишь одна копия кода этих функций, что позволит гораздо эффективнее использовать оперативную память.<o:p></o:p></span></p> <p><b><span>Разделение ресурсов. </span></b><span>DLL могут содержать такие ресурсы, как шаблоны диалоговых окон, строки, значки и битовые карты (растровые изображения). Эти ресурсы доступны любым программам<o:p></o:p></span></p> <p><b><span>Упрощение локализации. </span></b><span>D</span><span>L</span><span>L нередко применяются для локализации приложений. Например, приложение, содержащее только код без всяких компонентов пользовательского интерфейса, может загружать DLL с компонентами локализованного интерфейса<o:p></o:p></span></p> <p><b><span>Решение проблем, связанных с особенностями различных платформ.</span></b><span> В разных версиях Windows содержатся разные наборы функций. Зачастую разработчикам нужны новые функции, существующие в той версии системы, которой они пользуются. Если версия Windows не поддерживает эти функции, то не удастся запустить такое приложение: загрузчик попросту откажется его запускать. Но, если эти функции будут находиться в отдельной DLL, можно загрузить программу даже в более ранних версиях Windows, хотя воспользоваться ими нельзя.<o:p></o:p></span></p> <p><b><span>Реализация специфических возможностей. </span></b><span>Определенная функциональность в Windows доступна только при использовании DLL Например, отдельные виды ловушек (устанавливаемых вызовом <b>SetWindowsHookEx</b><i> </i>и <b>SetWinEventHook</b><i> </i>можно задействовать при том условии, что функция уведомления ловушки размещена в DLL. Кроме того, расширение функциональности оболочки Windows возможно лишь за счет создания СОМ-объектов, существование которых допустимо только в DLL. Это же относится и к загружаемым Web-браузером ActiveX-элементам, позволяющим создавать Web-страницы с более богатой функциональностью.<o:p></o:p></span></p> <p><span>Список литературы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span> </span><span>Олифер, В.Г. Сетевые операционные системы / В.Г. Олифер, Н.А. Олифер. – СПб.: Питер, 2002.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> </div>
 <A HREF="../theory.htm">Оглавление</A>
<p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>