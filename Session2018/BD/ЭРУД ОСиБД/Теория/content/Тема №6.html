<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Теория по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" >Программа</A> | 
                                                    <strong>Теория</strong>|
                                                  <A HREF="../../Практика/practice.htm">Практика</A>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>

<table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../theory.htm">Оглавление</A>
                <p>&nbsp;</p>
                 <div> <p><a><b><span>Тема 6 Ввод-вывод данных в ОС<o:p></o:p></span></b></a></p> <span></span> <p><b><span>6.1 Устройства ввода-вывода и работа с ними в современных операционных системах <o:p></o:p></span></b></p> <p><span>Подсистема ввода-вывода любой ОС должна обеспечить эффективное управление устройствами ввода-вывода и предоставлять удобный и эффективный виртуальный интерфейс устройств ввода-вывода, позволяющий прикладным программистам просто считывать или сохранять данные, не обращая внимание на специфику устройств и проблемы распределения устройств между выполняющимися задачами.<o:p></o:p></span></p> <p><span>Система ввода-вывода, способная объединить в одной модели широкий спектр устройств, должна быть универсальной. Она должна учитывать потребности существующих устройств, от простой мыши до клавиатур, принтеров, графических дисплеев, дисковых накопителей, компакт-дисков и даже сетей. С другой стороны, необходимо обеспечить доступ к устройствам ввода-вывода для множества параллельно выполняющихся задач, причем так, чтобы они как можно меньше мешали друг другу.<o:p></o:p></span></p> <p><span>Поэтому самым главным является следующий принцип: любые операции по управлению вводом-выводом объявляются привилегированными и могут выполняться только кодом самой операционной системы. Для обеспечения этого принципа в большинстве процессоров даже вводятся режимы пользователя и супервизора.<o:p></o:p></span></p> <p><span>Последний еще называют привилегированным режимом, или режимом ядра. Как правило, в режиме супервизора выполнение команд ввода-вывода разрешено, а в пользовательском режиме </span><span>–</span><span> запрещено. Обращение к командам ввода-вывода в пользовательском режиме вызывает исключение, и управление через механизм прерываний передается коду операционной системы.<o:p></o:p></span></p> <p><span>Хотя возможны и более сложные схемы, в которых в ряде случаев пользовательским программам может быть разрешено непосредственное выполнение команд ввода-вывода. Еще раз подчеркнем, что мы, прежде всего, говорим о мультипрограммных операционных системах, для которых существует проблема разделения ресурсов, и одним из основных видов ресурсов являются устройства ввода-вывода и соответствующее программное обеспечение, с помощью которого осуществляется обмен данными между внешними устройствами и оперативной памятью. Помимо разделяемых устройств ввода-вывода (эти устройства допускают разделение посредством механизма доступа) существуют неразделяемые устройства.<o:p></o:p></span></p> <p><span>Управление вводом-выводом осуществляется компонентом операционной системы, который часто называют супервизором ввода-вывода. Основные задачи, возлагаемые на супервизор следующие:<o:p></o:p></span></p> <p><span>– модуль супервизора операционной системы, иногда называемый супервизором задач, получает запросы от прикладных задач на выполнение тех или иных операций, в том числе на ввод-вывод. Эти запросы проверяются на корректность и, если они соответствуют спецификациям и не содержат ошибок, то обрабатываются дальше. В противном случае задаче выдается соответствующее диагностическое сообщение о некорректности запроса.<o:p></o:p></span></p> <p><span>– </span> <span>Супервизор ввода-вывода получает запросы на ввод-вывод от супервизора задач или от программных модулей самой операционной системы.<o:p></o:p></span></p> <p><span>– Супервизор ввода-вывода вызывает соответствующие распределители каналов и контроллеров, планирует ввод-вывод (определяет очередность предоставления устройств ввода-вывода задачам, затребовавшим эти устройства). Запрос на ввод-вывод либо тут же выполняется, либо ставится в очередь на выполнение.<o:p></o:p></span></p> <p><span>– Супервизор ввода-вывода инициирует операции ввода-вывода (передает управление соответствующим драйверам) и в случае управления вводом-выводом с использованием прерываний предоставляет процессор диспетчеру задач с тем, чтобы передать его первой задаче, стоящей в очереди на выполнение.<o:p></o:p></span></p> <p><span>– При получении сигналов прерываний от устройств ввода-вывода супервизор идентифицирует эти сигналы и передает управление соответствующим программам обработки прерываний.<o:p></o:p></span></p> <p><span>– Супервизор ввода-вывода осуществляет передачу сообщений об ошибках, если таковые происходят в процессе управления операциями ввода-вывода.<o:p></o:p></span></p> <p><span>– Супервизор ввода-вывода посылает сообщения о завершении операции ввода-вывода запросившей эту операцию задаче и снимает ее с состояния ожидания ввода-вывода, если задача ожидала завершения операции.<o:p></o:p></span></p> <p><span>В случае, если устройство ввода-вывода является инициативным, управление со стороны супервизора ввода-вывода будет заключаться в активизации соответствующего вычислительного процесса (перевод его в состояние готовности к выполнению).<o:p></o:p></span></p> <p><span>Таким образом, прикладные программы (а в общем случае </span><span>–</span><span> все обрабатывающие программы) не могут непосредственно связываться с устройствами ввода-вывода независимо от того, в каком режиме используются эти устройства (монопольно или совместно), но, установив соответствующие значения параметров в запросе на ввод-выводу определяющие требуемую операцию и количество потребляемых ресурсов, обращаются к супервизору задач. Последний передает управление супервизору ввода-вывода, который и запускает необходимые логические и физические операции.<o:p></o:p></span></p> <p><span>Упомянутый выше запрос на ввод-вывод должен удовлетворять требованиям API той операционной системы, в среде которой выполняется приложение. Параметры, которые указываются в запросах на ввод-вывод, передаются не только в вызывающих последовательностях, создаваемых по спецификациям API, но и как данные, хранящиеся в соответствующих системных таблицах. Все параметры, которые будут стоять в вызывающей последовательности, предоставляются компилятором и отражают требования программиста, а также постоянные сведения об операционной системе и архитектуре компьютера в целом. Переменные сведения о вычислительной системе (ее конфигурация, состав оборудования, состав и особенности системного программного обеспечения) содержатся в специальных системных таблицах. Процессору, каналам прямого доступа в память и контроллерам необходимо передавать конкретную двоичную информацию, с помощью которой и осуществляется управление оборудованием. Эта конкретная двоичная информация в виде кодов и данных часто готовится с помощью препроцессоров, но часть ее хранится в системных таблицах.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>6.2 Понятие «прерывание»<o:p></o:p></span></b></p> <p><span>Система прерываний переводит процессор на выполнение потока команд, отличного от того, который выполнялся до сих пор, с последующим возвратом к исходному коду. Механизм прерываний очень похож на механизм выполнения процедур. Это на самом деле так, хотя между этими механизмами имеется важное отличие. Переключение по прерыванию отличается от переключения, которое происходит по команде безусловного или условного перехода, предусмотренной программистом в потоке команд приложения. Переход по команде происходит в заранее определенных программистам точках программы и в зависимости от исходных данных, обрабатываемых программой. Прерывание же происходит в произвольной точке потока команд программы, которую программист не может прогнозировать. Прерывание возникает либо в зависимости от внешних, по отношению к процессу выполнения программы событий, либо при появлении <i>непредвиденных</i> аварийных ситуаций в процессе выполнения данной программы. Сходство же прерываний с процедурами состоит в том, что в обоих случаях выполняется некоторая подпрограмма, обрабатывающая специальную ситуацию, а затем продолжается выполнение основной ветви программы.<o:p></o:p></span></p> <p><span>В зависимости от источника прерывания делятся на три больших класса: внешние; внутренние: программные.<o:p></o:p></span></p> <p><i><span>Внешние </span></i><span>прерывания могут возникать в результате действий пользователя или оператора за терминалом, или же в результате поступления сигналов от аппаратных устройств – сигналов завершения операций ввода-вывода, вырабатываемых контроллерами внешних устройств компьютера, такими как принтер или нако­питель на жестких дисках, или же сигналов от датчиков управляемых компьютером технических объектов. Внешние прерывания называют также <i>аппаратными</i>, отражая тот факт, что прерывание возникает вследствие подачи некоторой аппаратурой (например, контроллером принтера) электрического сигнала, который передается (возможно, проходя через другие блоки компьютера, например кон­троллер прерывании) на специальный вход прерывания процессора. Данный класс прерывании является <i>асинхронным </i>по отношению к потоку инструкций преры­ваемой программы. Аппаратура процессора работает так, что асинхронные пре­рывания возникают между выполнением двух соседних инструкций, при этом системе после обработки прерывания продолжает выполнение процесса, уже начиная со следующей инструкции.<o:p></o:p></span></p> <p><i><span>Внутренние </span></i><span>прерывания, называемые также <i>исключениями (ехерtion), </i>происхо­дят <i>синхронно </i>выполнению программы при появлении аварийной ситуации и ходе исполнения некоторой инструкции программы. Примерами исключений явля­ются деление на нуль, ошибки защиты памяти, обращения по несуществующему адресу, попытка выполнить привилегированную инструкцию в пользовательском режиме и т. п. Исключения возникают непосредственно в ходе выполнения так­тов команды («внутри»» выполнения).<o:p></o:p></span></p> <p><i><span>Программные </span></i><span>прерывания отличаются от предыдущих двух классов тем, что они по своей сути не являются «истинными» прерываниями. Программное прерыва­ние возникает при выполнении особой команды процессора, выполнение которой имитирует прерывание, то есть переход на новую последовательность инструк­ций. Причины использования программных прерываний вместо обычных инст­рукций вызова процедур будут изложены ниже, после рассмотрения механизма прерываний.<o:p></o:p></span></p> <p><span>Прерываниям<b> </b>приписывается приоритет, с помощью которого они ранжируются по степени важности и срочности. О прерываниях, имеющих одинаковое значе­ние приоритета, говорят, что они относятся к одному <i>уровню приоритета </i>преры­ваний.<o:p></o:p></span></p> <p><span>Прерывания обычно обрабатываются модулями операционной системы, так как действия, выполняемые по прерыванию, относятся к управлению разделяемыми ресурсами вычислительной системы - принтером, диском, таймером, процессо­ром и т. п. Процедуры, вызываемые по прерываниям, обычно называют <i>обработ­чиками прерываний, </i>или <i>процедурами обслуживания прерываний (1nterruptServiceRoutine, ISR). </i>Аппаратные прерывания обрабатываются драйверами соответствую­щих внешних устройств, исключения — специальными модулями ядра, а про­граммные прерывания - процедурами ОС, обслуживающими системные вызовы. Кроме этих модулей в операционной системе может находиться так называемый диспетчер прерываний, который координирует работу отдельных обработчиков прерывании.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span><o:p> </o:p></span></b></p> <p><b><span>6.3 Обработчики прерываний<o:p></o:p></span></b></p> <p><b><span>Механизм прерываний.</span></b><span><o:p></o:p></span></p> <p><span>Механизм прерывании поддерживается аппаратными средствами компьютера и программными средствами операционной системы. Аппаратная поддержка преры­ваний имеет спои особенности, зависящие от типа процессора и других аппарат­ных компонентов, передающих сигнал запроса прерывания от внешнего устрой­ства к процессору (таких, как контроллер внешнего устройства, шины подклю­чения внешних устройств, контроллер прерываний, являющийся посредником между сигналами шины и сигналами процессора). Особенности аппаратной реализации прерываний оказывают влияние на средства программной поддержки прерываний, работающие в составе ОС.<o:p></o:p></span></p> <p><span>Существуют два основных способа, с помощью которых шины выполняют прерывания: <i>векторный </i>(<i>vectored</i>) и <i>опрашиваемый (polled). </i>В обоих способах про­цессору предоставляется информация об уровне приоритета прерывания на шине подключения внешних устройств. В случае векторных прерывании в процессор передается также информация о начальном адресе программы обработки возник­шего прерывания - <i>обработчика прерываний.</i><o:p></o:p></span></p> <p><span>Устройствам, которые используют векторные прерывания, назначается <i>вектор прерываний. </i>Он представляет собой электрический сигнал, выставляемый на соответствующие шины процессора и несущий в себе информацию об определен­ном, закрепленном за данным устройством номере, который идентифицирует соответствующий обработчик прерываний. Этот вектор может быть фиксированным, конфигурируемым<b> </b>(например, с использованием переключателей) или программируемым. Операционная система может предусматривать процедуру регистра­ции вектора обработки прерывании для определенного устройства, которая свя­зывает некоторую подпрограмму обработки прерываний с определенным вектором. При получении сигнала запроса прерывания процессор выполняет специальный цикл подтверждения прерывания, в котором устройство должно идентифицировать себя. В течение этот цикла устройство отвечает, выставляя на шину вектор прерываний. Затем процессор использует этот вектор для нахождения обработ­чика данного прерывания. Примером шины подключения внешних устройств, которая поддерживает векторные прерывания, является шина VMEbus.<o:p></o:p></span></p> <p><span>При использовании опрашиваемых прерываний процессор получает от запросившего прерывание устройства только информацию об уровне приоритета прерывания (например, номере QRI на шине ISA или номере IPL на шине SBus компьютеров SPARC). С каждым уровнем прерываний может быть связано несколько устройств и соответственно несколько программ — обработчиков прерываний. При возникновении прерывания процессор должен определить, какое устройст­во из тех, которые связаны с данным уровнем прерываний, действительно запросило прерывание. Это достигается вызовом всех обработчиков прерываний для данного уровня приоритета, пока один из обработчиков не подтвердит, что пре­рывание пришло от обслуживаемого им устройства. Если же с каждым уровнем прерываний связано только одно устройство, то определение нужной программы обработки прерывания происходит немедленно, как и при векторном прерывании. Опрашиваемые прерывания поддерживают шины ISA, EISA, MCA, PCI и Sbus.<o:p></o:p></span></p> <p><span>Механизм прерываний некоторой аппаратной платформы может сочетать век­торный и опрашиваемый типы прерываний. Типичным примером такой реализа­ции является платформа персональных компьютеров на основе процессоров Intel Pentium. Шины PCI,ISA, EISA или MCA, используемые в этой платформе в ка­честве шин подключения внешних устройств, поддерживают механизм опрашиваемых прерываний. Контроллеры периферийных устройств выставляют на шину не вектор, а сигнал запроса прерывания определенного уровня IRQ. Одна­ко в процессоре Pentium система прерываний является векторной. Вектор прерываний в процессор Pentium поставляет контроллер прерываний, который ото­бражает поступающий от шины сигнал IRQ на определенный номер вектора.<o:p></o:p></span></p> <p><span>Вектор прерываний, передаваемый в процессор, представляет собой целое число в диапазоне от 0 до 255, указывающее на одну из 256 программ обработки пре­рываний, адреса которых хранятся в таблице обработчиков прерываний. В том случае, когда к каждой линии IRQ, подключается только одно устройство, проце­дура обработки прерываний работает так, как если бы система прерываний была чисто векторной, то есть процедура не выполняет никаких дополнительных опросов для выяснения того, какое именно устройство запросило прерывание. Однако при совместном использовании одного уровня IRQ несколькими уст­ройствами программа обработки прерываний должка работать в соответствии со схемой опрашиваемых прерываний, то есть дополнительно выполнить опрос всех устройств, подключенных к данному уровню IRQ.<o:p></o:p></span></p> <p><span>Механизм прерываний чаще всего поддерживает <i>прииритезацию </i>и <i>маскирование </i>прерываний. Приоритезация означает, что все источники прерываний делятся на классы и каждому классу назначается свой уровень приоритета запроса на преры­вание. Приоритеты могут обслуживаться как <i>относительные </i>и <i>абсолютные. </i>Об­служивание запросов прерываний по схеме с относительными приоритетами за­ключается в том, что при одновременном поступлении запросов прерываний из разных классов выбирается запрос, имеющий высший приоритет. Однако в дальнейшем при обслуживании<b> </b>этого запроса процедура обработки прерывания уже не откладывается даже в том случае, когда появляются более приоритетные запросы </span><span>–</span><span> решение о выборе нового запроса принимается только в момент за­вершения обслуживания очередного прерывания. Если же более приоритетным прерываниям разрешается приостанавливать работу процедур обслуживания ме­нее приоритетных прерываний, то это означает, что работает схема приоритезации с абсолютными приоритетами.<o:p></o:p></span></p> <p><span>Если процессор (или компьютер, когда поддержка приоритезации прерываний вынесена во внешний по отношению к процессору блок) работает по схеме с абсолютными приоритетами, то он поддерживает в одном из своих внутренних ре­гистров переменную, фиксирующую уровень приоритета обслуживаемого в дан­ный момент прерывания. При поступлении запроса из определенного класса его приоритет сравнивается с текущим приоритетом процессора, и если приоритет запроса выше, то текущая процедура обработки прерываний вытесняется, а по завершении обслуживания нового прерывания происходит возврат к прерван­ной процедуре.<o:p></o:p></span></p> <p><span>Упорядоченное обслуживание запросов прерываний наряду со схемами приоритетной обработки запросов может выполняться механизмом маскирования запросов. Собственно говоря, в описанной схеме абсолютных приоритетов выполняет­ся маскирование </span><span>–</span><span> при обслуживании некоторого запроса все запросы с равным или более низким приоритетом маскируются, то есть не обслуживаются. Схема маскирования предполагает возможность временного маскирования прерываний любого класса независимо от уровня приоритета.<o:p></o:p></span></p> <p><span>Обобщенно последовательность действий аппаратных и программных средств по обработке прерывания можно описать следующим образом:<o:p></o:p></span></p> <p><span>1. При возникновении сигнала (для аппаратных прерываний) или условия (для внутренних прерываний) прерывания происходит первичное аппаратное распознавание типа прерывания, Если прерывания данного типа в настоящий момент запрещены (приоритетной схемой или механизмом маскирования), то процессор продолжает поддерживать естественный ход выполнения команд. В противном случае в зависимости от поступившей в процессор информации (уровень прерывания, вектор прерывания или тип условия внутреннего прерывания) происходит автоматический вызов процедуры обработки прерывания, адрес которой находится в специальной таблице операционной системы размещаемой либо в регистрах процессора, либо в определенном месте оперативной памяти.<o:p></o:p></span></p> <p><span>2. Автоматически сохраняется некоторая часть контекста прерванного потока, которая позволит ядру возобновить исполнение потока процесса после обработки прерывания. В это подмножество обычно включаются значения счетчика команд, слова состояния машины, хранящего признаки основных режимов работы процессора (пример такого слова </span><span>–</span><span> регистр EFLAGS в Intel Pentium), а также нескольких регистров общего назначения, которые требуются программе обработки прерывания. Может быть сохранен и полный контекст процесса, если ОС обслуживает данное прерывание со сменой процесса. Однако в общем случае это не обязательно, часто обработка прерываний выполняется без вытеснения текущего процесса.<o:p></o:p></span></p> <p><span>3. Одновременно с загрузкой адреса процедуры обработки прерываний в счетчик команд может автоматически выполняться загрузка нового значения слов состояния машины (или другой системной структуры, например селектор кодового сегмента в процессоре Pentium), которое определяет режимы работы процессора при обработке прерывания, в том числе работу в привилегированном режиме. В некоторых моделях процессором переход в привилегированный режим за счет смены состояния машины при обработке прерывания является единственным способом смены режима. Прерывания практически во всех мультипрограммных ОС обрабатываются в привилегированном режиме модулями ядра, так как при этом обычно нужно выполнить ряд критических операций, с которых зависит жизнеспособность системы, - управлять внешними устройствами, перепланировать потоки и т. п.<o:p></o:p></span></p> <p><span>4. Временно запрещаются прерывания данного типа, чтобы не образовалась очередь вложенных друг в друга потоков одной и той же процедуры. Детали выполнения этой операции зависят от особенностей аппаратной платформы, например, может использоваться механизм маскирования прерывании. Многие процессоры автоматически устанавливают признак запрета прерываний в начале цикла обработки прерывания, в противном случае это делает программа обработки прерываний.<o:p></o:p></span></p> <p><span>5. После того как прерывание обработано ядром операционной системы, пре­рванный контекст восстанавливается и работа потока возобновляется с пре­рванного места. Часть контекста восстанавливается аппаратно по команде возврата из прерываний (например, адрес следующей команды и слово со­стояния машины), а часть </span><span>–</span><span> программным способом, с помощью явных ко­манд извлечения данных из стека. При возврате из прерывания блокировка повторных прерываний данного типа снимается.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><b><span>Программные прерывания.</span></b><span><o:p></o:p></span></p> <p><span>Программное порывание реализует один из способов перехода на подпрограм­му с помощью специальной инструкции процессора, такой как INT в процессо­рах Intel Pentium, trap в процессорах Motorola, syscall в процессорах MIPS или Ticc в процессорах SPARC. При выполнении команды программного прерывания процессор отрабатывает ту же последовательность действии, что и при возник­новении внешнего или внутреннего прерывания, но только происходит это в предсказуемой точке программы </span><span>–</span><span> там, где программист поместил данную ко­манду.<o:p></o:p></span></p> <p><span>Практически все современные процессоры имеют в системе команд инструкции программных прерываний. Одной из причин появления инструкций программ­ных прерываний в системе команд процессоров является то, что их использова­ние часто приводит к более компактному коду программ по сравнению с исполь­зованием стандартных команд выполнения процедур. Это объясняется тем, что разработчики процессора обычно резервируют для обработки прерываний не­большое число возможных подпрограмм, так что длина операнда в команде программного прерывания, который указывает на нужную подпрограмму, меньше, чем в команде перехода на подпрограмму. Например, в процессоре х86 преду­смотрена возможность применения 256 программ обработки прерываний, поэто­му в инструкции INT операнд имеет длину в один байт (а инструкция INT 3, кото­рая предназначена для вызова отладчика, вся имеет длину один байт). Значение операнда команды INT просто является индексом в таблице из 256 адресов под­программ обработки прерываний, один из которых и используется для перехода по команде INT. При использовании команды CALL потребовался бы уже не одно­байтовый, а двух- или четырехбайтовый операнд. Другой причиной применения программных прерываний вместо обычных инструкций вызова подпрограмм является возможность смены пользовательского режима на привилегированный, одновременно с вызовом процедуры </span><span>–</span><span> это свойство программных прерываний поддерживается большинством процессоров.<o:p></o:p></span></p> <p><span>В результате программные прерывания часто используются для выполнения ограниченного количества вызова функций ядра операционной системы, то есть системных вызовов.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>6.4 Понятие «драйвер»<o:p></o:p></span></b></p> <p><i><span>Аппаратные драйверы </span></i><span>выполняют все традиционные функции по управлению устройствами, включая обработку прерываний и непосредственное взаимодействие с устройствами ввода-вывода.<o:p></o:p></span></p> <p><span>Более точно, аппаратный драйвер имеет дело не с устройством, а с его контролле­ром. Контроллер, как правило, выполняет достаточно простые функции, например преобразует поток бит в блоки данных и осуществляют контроль и исправление возникающих в процессе обмена данными ошибок. Каждый контроллер имеет не­сколько регистров, которые используются для взаимодействия с центральным процес­сором. Обычно у контроллера имеются регистры данных, через которые осуществ­ляется обмен данными между драйвером и устройством, и управляющие регистры, в которые драйвер помещает команды. В некоторых типах компьютеров регистры являются частью физического адресного пространства, при этом в таких компьюте­рах отсутствуют специальные инструкции ввода-вывода — их функции выполняют инструкции обмена с памятью. В других компьютерах адреса регистров ввода-выво­да, называемых часто портами, образуют собственное адресное пространство за счет введения специальных операций ввода-вывода (например, команд IN и OUT в про­цессорах Intel Pentium).<o:p></o:p></span></p> <p><span>Внешнее устройство в общем случае состоит из механических и электронных ком­понентов. Обычно электронная часть устройства сосредоточивается в его кон­троллере, хотя это и не обязательно. Некоторые контроллеры могут управлять несколькими устройствами. Если интерфейс между контроллером и устройст­вом стандартизован, то независимые производители могут выпускать как совмес­тимые со стандартом контроллеры, так и совместимые устройства.<o:p></o:p></span></p> <p><span>Аппаратный драйвер выполняет ввод-вывод данных, записывая команды в реги­стры контроллера. Например, контроллер диска персонального компьютера при­нимает такие команды, как READ, WRITE, SEEK, FORMAT и т. д. Когда команда принята, процессор оставляет контроллер и занимается другой работой. По завершении команды контроллер генерирует запрос прерывания для того, чтобы передать управление процессором операционной системе, которая должна проверить ре­зультаты операции. Процессор получает результаты и данные о статусе устрой­ства, читая информацию из регистров контроллера.<o:p></o:p></span></p> <p><span>Аппаратные драйверы могут в своей работе опираться на <i>микропрограммные драй­веры (firmwaredrivers), </i>поставляемые производителем компьютера и находящиеся в постоянной памяти компьютера (в персональных компьютерах это программ­ное обеспечение получило название BIOS — Basic Input-Output System). Микро­программное обеспечение представляет собой самый нижний слой программно­го обеспечения компьютера, управляющий устройствами. Модули этого слоя выполняют функции транслирующих драйверов и конвертора экранирующих специфические интерфейсы аппаратуры данной компьютерной системы от опе­рационной системы и ее драйверов.<o:p></o:p></span></p> <p><span>Драйвер выполняет <i>операции} </i>ввода-вывода, которая представляет собой4 обмен т устройством заданным количеством байт по заданному адресу оперативкой па­мяти (и адресу устройства ввода-вывода в том случае, когда оно является адре­суемым). Примерами операций ввода-вывода могут служить чтение нескольких смежных секторов диска или печать на принтере нескольких строк документа. Операция задается одним системным вызовом ввода-вывода, например read или write.<o:p></o:p></span></p> <p><span>Операция отрабатывается драйвером в общем случае за несколько <i>действий. </i>Так, при выводе документа на принтер драйвер сначала выполняет некоторые начальные действия, приводящие принтер в состояние готовности к печати, за­тем выводит в буфер принтера первую порцию данных и ждет сигнала прерыва­ния, который свидетельствует об окончании контроллером принтера печати этой порции данных. После этого в буфер выводится вторая порция данных и т. д.<o:p></o:p></span></p> <p><span>Так как большинство действий драйвер выполняет асинхронно по отношению к вызвавшему драйвер процессу, то драйверу запрещается изменять контекст те­кущего процесса (который в общем случае отличается от вызвавшего). Кроме того, драйвер не может запрашивать у ОС выделения дополнительных ресурсов или отказываться от уже имеющихся у текущего процесса </span><span>–</span><span> драйвер должен пользоваться теми системными ресурсами, которые выделяются непосредствен'' но ему (а не процессу) на этапе загрузки в систему или старта очередной опера­ции ввода-вывода. Соблюдение этих условий необходимо для корректного рас­пределения ресурсов между процессами </span><span>–</span><span> каждый получает то, что запрашивал и что непосредственно ему выделила операционная система.<o:p></o:p></span></p> <p><span>В подсистеме ввода-вывода каждой современной операционной системы сущест­вует стандарт на структуру драйверов. Несмотря на специфику управляемых устройств, в любом драйвере можно выделить некоторые общие части, выпол­няющие определенный набор действий, такие как запуск операции ввода-выво­да, обработка прерывания от контроллера устройства и т. п. Рассмотрим принци­пы структуризации драйверов на примере операционных систем Windows NT и UNIX.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>6.5 Создание драйверов в Windows и Linux<o:p></o:p></span></b></p> <p><b><span>Драйвера в Windows</span></b><span><o:p></o:p></span></p> <p><span>Структура драйвера Windows NT Особенностью Windows NT является общая структура драйверов любого уровня и расширенное толкование самого понятия «драйвер». В Windows NT и аппарат­ный драйвер диска, и высокоуровневый драйвер файловой системы построены единообразно, поэтому другие модули ОС взаимодействуют с драйверами одним и тем же способом.<o:p></o:p></span></p> <p><span>Драйвер Windows NT состоит из следующих (не обязательно всех) процедур:<o:p></o:p></span></p> <p><i><span>Процедура инициализации драйвера. </span></i><span>Эта процедура выполняется при загрузке драйвера в подсистему ввода-вывода, при этом создаются системные объек­ты, которые позволяют менеджеру ввода-вывода найти нужный драйвер для управления определенным устройством или выполнения некоторых высоко­уровневых функций с информацией, получаемой от устройства или переда­ваемой на устройство.<o:p></o:p></span></p> <p><i><span>Набор диспетчерских процедур. </span></i><span>Эти процедуры составляют основу драйвера, так как именно они выполняют операции ввода-вывода, поддерживаемые данным драйвером, например чтение данных, запись данных, перемотку ленты и т. п.<o:p></o:p></span></p> <p><i><span>Стартовая процедура </span></i><span>предназначена для приведения устройства в исходное состояние перед началом очередной операции. Выполняет «открытие» <i>(open) </i>устройства.<o:p></o:p></span></p> <p><i><span>Процедура обработки прерывания </span></i><span>(ISR) включает наиболее важные действия, которые нужно выполнить при возникновении очередного аппаратного преры­вания от контроллера устройства. Процедура обработки прерывания драйвера имеет достаточно высокий приоритет запроса прерывания IRQL (например, выше приоритета диспетчера потоков), поэтому в нее рекомендуется вклю­чать только те функции, которые требуют незамедлительной реакции, чтобы не задерживать надолго работу других модулей и процессов. По завершении работы ISR может поставить в очередь диспетчера прерываний процедуру DPC драйвера.<o:p></o:p></span></p> <p><i><span>Процедура отложенных вызовов </span></i><span>(DPC). Эта процедура также состоит из функ­ций, которые нужно выполнить при возникновении прерывания от контрол­лера устройства, однако эти функции не требует такой быстрой реакции, как функции ISR. В результате процедура DPC обслуживается с более низким значением приоритета IRQL, давая возможность процедурам ISR и другим приоритетным запросам обслуживаться в первую очередь. Обычно большая часть действий драйвера по обработке прерывания включается в процедуру DPC.<o:p></o:p></span></p> <p><i><span>Процедура завершения операции </span></i><span>уведомляет менеджер ввода-вывода о том, что операция завершена и данные находятся в системной области памяти. Менед­жер при этом может вызвать драйвер более высокого уровня для продолже­ния обработки данных или же вызывать процедуру АРС для копирования данных из системной области в об­ласть памяти пользовательского процесса.<o:p></o:p></span></p> <p><i><span>Процедура отмены ввода-вывода. </span></i><span>Для разных стадий выполнения операции могут существовать разные процедуры отмены.<o:p></o:p></span></p> <p><i><span>Процедура выгрузки драйвера </span></i><span>вызывается при динамической выгрузке драйвера из подсистемы ввода-вывода. Удаляет созданные для драйвера объекты и освобождает системную память.<o:p></o:p></span></p> <p><i><span>Процедура регистрации ошибок. </span></i><span>При возникновении ошибки в процессе выполнения операции данная процедура уведомляет о ней менеджера ввода-вы­вода, который в свою очередь делает соответствующую запись в журнале ре­гистрации.<o:p></o:p></span></p> <p><span>Адреса всех перечисленных процедур представляют собой точки входа в драй­вер, известные менеджеру ввода-вывода. Эти адреса хранятся в объекте, создаваемом для каждого драйвера Windows NT, и менеджер использует такие объек­ты для вызова той или иной функции драйвера Процедура диспетчеризации используется как общая точка входа для нескольких процедур обмена данными (чтение, запись, управление и т. п.), набор которых изменяется от драйвера к драйверу и, следовательно, не может быть стандартизован.<o:p></o:p></span></p> <p><span>Большое количество стандартизованных функций драйвера Windows NT обуслов­лено желанием разработчиков этой ОС использовать единую модель для драйве­ров всех типов, от сравнительно простого аппаратного драйвера СОМ-порта до весьма сложного драйвера файловой системы NTFS. В результате некоторые функции для некоторого драйвера могут оказаться невостребованными. Напри­мер, для высокоуровневых драйверов не нужна секция обработки прерываний ISR, так как прерывания от устройства обрабатывает соответствующий низко­уровневый драйвер, который затем вызывает высокоуровневый драйвер с помо­щью менеджера ввода-вывода, не используя механизм прерываний.<o:p></o:p></span></p> <p><span>Рассмотрим особенности вызова функций аппаратного драйвера Windows NT на примере выполнения операции чтения с диска (см. рисунок 1). Диск рассматривается в этой операции как виртуальное устройство, следовательно, слой драйверов файловых систем в выполнении операции не участвует.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
 o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
 stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:432.75pt;
 height:333pt'>
 <v:imagedata src="Тема%20№6.files/image001.png" o:title=""/>
</v:shape><![endif]--> <img src="Тема%20№6.files/image002.jpg" v:shapes="_x0000_i1025"><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>1 – Работа аппаратного драйвера Windows NT<o:p></o:p></span></p> <p><span>Пусть в некоторый момент времени выполнения в пользовательской фазе про­цесс А запрашивает с помощью соответствующего системного вызова чтение некоторого количества блоков диска, начиная с блока определенного номера. Процесс А при этом переходит в состояние ожидания завершения запрошенной операции, а планировщик/диспетчер Sh активизирует ожидавший выполнения процесс В.<o:p></o:p></span></p> <p><span>При выполнении системного вызова управление с помощью менеджера ввода-вывода передается стартовой функции драйвера диска DD, которая проверяет, открыт ли виртуальный файл диска и готов ли контроллер диска к выполнению операции обмена данными. После возврата управления от стартовой процедуры менеджер вызывает функцию диспетчеризации драйвера, которой передается па­кет запроса ввода-вывода IRP, содержащий параметры операции — начальный адрес и количество блоков диска. В результате функция диспетчеризации драй­вера вызывает внутреннюю функцию чтения данных с диска, которая передает контроллеру диска запрос на чтение первой порции запрошенных данных. На рисунке работа всех перечисленных функций показана как один этап работы драйвера DD. Тот факт, что драйвер DD выполняет работу для процесса А, отме­чен на рисунке нижним индексом, то есть как DDA.<o:p></o:p></span></p> <p><span>После завершения чтения порции данных контроллер генерирует аппаратный за­прос прерывания, который вызывает процедуру обработки прерываний драйвера диска ISR, имеющую высокий уровень IRQL. После короткого периода выпол­нения самых необходимых действий с регистрами контроллера (этот период для упрощения рисунка не показан) эта процедура делает запрос на выполнение менее срочной DPC-процедуры драйвера, которая должна выполнить передачу имеющейся у контроллера порции данных в системную область. Запрос на вы­полнение DPC-процедуры драйвера DDA некоторое время стоит в очереди уров­ня DPC, так как в это время в процессоре выполняются более приоритетные ISR-процедуры DSB (драйвера стриммера для процесса В) и DPF (драйвера прин­тера для процесса F). После завершения этих процедур начинается выполнение DPC-процедуры драйвера DDA, при этом текущим для ОС процессом является процесс В, сменивший процесс А и прерванный на время ISR-процедурами. Од­нако на выполнение DPC-процедуры драйвера диска это обстоятельство не ока­зывает никакого влияния, так как данные перемещаются в системную область, общую для всех процессов.<o:p></o:p></span></p> <p><span>Кроме перемещения данных DPC-процедура драйвера выдает контроллеру дис­ка указание о чтении второй и последней для операции порции данных (если контроллер использует режим прямого доступа к памяти и самостоятельно переме­щает данные из своего буфера в системный буфер, то запуск нового действия будет единственной обязанностью DPC-процедуры). Контроллер выполняет чтение и вы­дает новый запрос прерывания, который снова вызывает процедуру обработки пре­рываний драйвера диска. Данная процедура ставит в IRQL-очереди две процедуры: DPC-процедуру, которая, как и в предыдущем цикле чтения, должна переписать данные из буфера контроллера в системный буфер, и АРС-процедуру, которая долж­на переписать все полученные данные из системного буфера в заданную пользова­тельскую область памяти процесса А.<o:p></o:p></span></p> <p><span>DPC-процедура вызывается раньше, так как имеет более высокий приоритет в очереди диспетчера прерываний. АРС-процедура ждет дольше, так как она име­ет более низкий приоритет и, кроме того, она обязана ждать до тех пор, пока те­кущим процессом не станет процесс А. DPC-процедура после выполнения своей работы фиксирует в операционной системе событие </span><span>–</span><span> завершение операции ввода-вывода. По наступлении события вызывается планировщик потоков, кото­рый переводит процесс А в состояние готовности (но не ставит его на выполнение, так как текущий процесс С еще не исчерпал своего кванта времени). И толь­ко после тою, как планировщик снимает процесс С с выполнения и делает текущим процесс А, вызывается АРС-процедура, которая вытесняет пользова­тельский код процесса А» имеющий низший приоритет IRQL; АРС-процедура переписывает считанные с диска данные из системного буфера в область данных процесса А. Для доступа к системному буферу АРС-процедура должна иметь нужный уровень привилегий. После завершения работы АРС-дроцедуры управ­ление возвращается пользовательскому коду приложения А, который обрабаты­вает запрошенные у диска данные.<o:p></o:p></span></p> <p><b><span>Драйвера в Unix и Linux</span></b><span><o:p></o:p></span></p> <p><b><span>Структура драйвера </span></b><b><span>UNIX</span></b><b><span>.</span></b><span><o:p></o:p></span></p> <p><span>В ОС </span><span>UNIX</span><span> вместо одной общей структуры драйвера существуют две стандарт­ные структуры, одна </span><span>–</span><span> для блок-ориентированных драйверов, а другая </span><span>–</span><span> для байт-ориентированных. По этой причине в </span><span>UNIX</span><span> используются две таблицы, </span><i><span>bdevsw</span></i><span> и </span><i><span>cdevsw</span></i><i><span>, </span></i><span>хранящие точки входа <i>в </i>функции драйверов. Каждая из таблиц имеет свою структуру, соответствующую стандартным функциям блок-ориенти­рованных и байт-ориентированных драйверов.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><b><span>Блок-ориентированные драйверы</span></b><span><o:p></o:p></span></p> <p><span>Драйвер блок-ориентированного устройства состоит из следующих функций:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>open</span><span> </span><span>–</span><span> выполняет процедуру логического открытия устройства;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>close</span><span> </span><span>–</span><span> выполняет процедуру логического закрытия устройства;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>strategy</span><span> </span><span>–</span><span> читает или записывает блок;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>print</span><span> </span><span>–</span><span> выводит сообщение об ошибке;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>size</span><span> </span><span>–</span><span> возвращает размер раздела, который представляет данное устройство.<o:p></o:p></span></p> <p><span>Указатели на эти функции (то есть их адреса) составляют строку в таблице </span><span>bdevsw</span><span>, описывающую один драйвер системы. Ядро </span><span>UNIX</span><span> вызывает нужную функцию драйвера, передавая ей параметры, необходимые для работы. Например, при вызове функции </span><span>open</span><span> ей передастся номер устройства (</span><span>minor</span><span>), режим открытия (для чтения, для записи, для чтения и записи и т. д.), а также указатель на идентифи­каторы безопасности процесса, открывающего файл.<o:p></o:p></span></p> <p><i><span>Процедуры обработки прерываний </span></i><span>драйвера в таблице </span><i><span>bdevsw </span></i><span>не указываются, их адреса помешаются в специальную системную структуру </span><span>–</span><span> таблицу прерываний. В </span><span>UNIX</span><span> все обработчики прерываний, в том числе и обработчики прерываний аппаратных драйверов, состоят из двух процедур, называемых соответственно </span><span>top</span><span>-</span><span>half</span><i><span> </span></i><span>–</span><i><span> </span></i><span>верхняя часть обработчика прерываний и </span><span>bottom</span><span>-</span><span>half</span><span> </span><span>–</span><span> нижняя часть обработчика прерываний. Верхняя часть обработчика прерываний соответствует по назначению 15</span><span>R</span><span>-процедуре драйвера </span><span>Windows NT</span><span> </span><span>–</span><span> она вызывается при воз­никновении аппаратного запроса прерывания от устройства, В обязанности верх­ней части входит быстрая реакция на событие в устройстве, вызвавшее генери­рование сигнала прерывания. При обработке верхних половин все прерывания с более низкими приоритетами блокируется аппаратно, за счёт управления контроллером прерываний (или аналогичным по назначению блоком компьютера). Верхняя половина отвечает за постановку в очередь на выполнение нижней половины обработчика прерываний драйвера, который выполнит менее срочную и более трудоёмкую работу.<o:p></o:p></span></p> <p><span>Нижние половины драйверов выполняются с низким уровнем приоритета, так что любые запросы прерываний устройств могут прервать их обработку. Нижние половины обработчиков прерываний драйверов </span><span>UNIX </span><span>по назначению соответствуют </span><span>DPC</span><span>-процедурам драйверов </span><span>Windows NT</span><span>. Часто единственной обязанностью верхней половины обработчика прерываний является постановка в очередь нижней половины для последующего выполнения.<o:p></o:p></span></p> <p><span>Функция стратегии драйвера </span><span>strategy </span><span>выполняет чтение и запись блока данных на основании информации в буфере – особой структуре ядра с именем </span><span>buf</span><span>, управляющей обменов данных с диском. Функция </span><span>strategy </span><span>выполняет обмен только с системной памятью, т.к. блок-ориентированный драйвер непосредственно не взаимодействует с пользовательским процессом. Между ним и пользовательским процессом всегда работает промежуточный программный слой или слои – либо слой дискового кэша вместе со слоем файловой системы, либо слой байт-ориентированного драйвера диска, с помощью которого пользовательский процесс может открыть специальный файл, соответствующий диску.<o:p></o:p></span></p> <p><span>В число наиболее важных элементов структуры </span><span>buf </span><span>входят следующие:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>flag</span><span> – набор бит, в котором задаются тип операции (чтение или запись), синхронный или асинхронный режим операции (при записи), признак ожидания буфера процессом и некоторые другие;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>forw</span><span>, </span><span>b</span><span>_</span><span>back</span><span> – указатели на последующий и предыдущий буферы в списке активных (используемых) буферов;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>av</span><span>_</span><span>forw</span><span>, </span><span>av</span><span>_</span><span>back</span><span> – указатели на последующий и предыдущий буферы в списке свободных буферов;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>dev</span><span> – номер драйвера (</span><span>major</span><span>) и номер устройства (</span><span>minor</span><span>) из индексного дескриптора специального устройства, для которого выполняется операция с данными;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>bcount</span><span> – количество байт, которые нужно передать;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>addr</span><span> – адрес, буфера памяти, куда нужно записать или откуда нужно прочитать данные;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>blkno</span><span> – номер блока в разделе диска;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>bufsize</span><span> – размер блока (в ранних версиях </span><span>UNIX</span><span> использовался только один размер блока – 512 байт, в версиях, основанных на коде </span><span>System V Release</span><span> 4, можно работать с блоками разного размера);<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>b</span><span>_</span><span>iodone</span><span> – указатель на функцию, которая вызывается по завершении операции ввода-вывода.<o:p></o:p></span></p> <p><span>Функция </span><span>strategy </span><span>при вызове получает указатель на структуру </span><span>buf</span><span>. Описывающую требуемую операцию. Функция </span><span>hd</span><span>_</span><span>strategy</span><span> преобразует логический номе блока в номера цилиндра, головки и сектора и помещает эту информацию в заголовок запроса операции для передачи ее контроллеру диска. В заголовок запроса помещается также другая информация, необходимая для работы контроллера, - это операция чтения или записи, адрес системной памяти, куда нужно поместить прочитанную информацию или откуда контроллеру нужно считать записываемые данные. Драйвер ведет две очереди для передачи запросов на выполнение операций чтения и записи контроллером запросы, и очередь приостановленных запросов, куда помещаются новые запросы в том случае, если рабочая очередь заполнена, а ее размер зависит от возможностей контроллера по параллельной обработке запросов.<o:p></o:p></span></p> <p><span>После помещения нового запроса в одну из очередей функция стратегии разрешает прерывания от данного устройства и завершает свою работу. Всю дальнейшую работу по обслуживанию поставленных в очереди запросов выполняют контроллер и обработчики прерываний. После выполнения запроса, когда данные либо записаны в системную память (чтение), либо переписаны из системной памяти в блок диска (запись), контроллер генерирует сигнал прерывания. По этому сигналу вызывается верхняя часть обработчика прерываний дискового драйвера (на рисунке не показана), которая просто ставит в очередь диспетчера прерываний нижнюю часть обработчика прерываний </span><span>hd</span><span>_</span><span>bottom</span><span>. Эта процедура считывает данные из регистра управления контроллера для того, чтобы определить, корректно ли завершилась запрошенная операция. Если признак ошибки в регистре не установлен, то в рабочую очередь контроллера помещается следующий заголовок запроса из очереди приостановленных запросов, а по завершении операции вызываются функция </span><span>iodone</span><span>, указатель на которую имеется в буфере </span><span>buf</span><span>.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span>Список литературы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Олифер, В.Г. Сетевые операционные системы / В.Г. Олифер, Н.А. Олифер. – СПб.: Питер, 2002.<o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Гордеев А.В. Операционные системы: Учебник для вузов.2-е изд. - СПб.: Питер, 2007. - 416 с.: ил.<o:p></o:p></span></p> <p><o:p> </o:p></p> </div> 
 <A HREF="../theory.htm">Оглавление</A>                
<p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>