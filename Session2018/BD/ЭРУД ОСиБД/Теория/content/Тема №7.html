<!-- (C) 2015 Rozum Halina, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../Оболочка/css/style.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html" charset="utf8">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title> Теория по дисциплине &quot;Операционные системы, базы данных&quot;</title>
    <base target="_top">
</HEAD>

<BODY>
    <table width="100%" border="0" cellpadding="0" cellspacing="3" background="../../Оболочка/images/background.jpg">
        <tr>
            <td width="13%" rowspan=3 align="center"><img src="../../Оболочка/images/logo_new.jpg" width=117 align="middle">
            </td>
            <tr>
                <td width="70%" colspan=2 align="center" valign="middle">
                    <H1 align="center">электронный
        ресурс по учебной дисциплине<BR>
        &quot;Операционные системы, базы данных&quot;<BR>
        для специальности: </H1> 1-58 01 01 - &quot;ИНЖЕНЕРНО-ПСИХОЛОГИЧЕСКОЕ ОБЕСПЕЧЕНИЕ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ&quot;.
                </td>
                <td width="12%" rowspan=3 align="center">&nbsp;</td>
  <Tr>
    <td align=center colspan=2><var class="normal">
                                                  <A HREF="../../index.htm">Оглавление</A> |
                                                  <A HREF="../../Программа/program.html" >Программа</A> | 
                                                    <strong>Теория</strong>|
                                                  <A HREF="../../Практика/practice.htm">Практика</A>|
                                                  <A HREF="../../Контроль_знаний/test.htm">Контроль знаний</A> |
                                                  <A HREF="../../Об авторах/author.htm">Об авторах</A>
     </var></var> </td>
  </tr>
    </table>

 
<table style="margin:0 auto;" width="90%" border="0" cellpadding="0" cellspacing="0">
            <td>
 <A HREF="../theory.htm">Оглавление</A>
                <p>&nbsp;</p>
                 <div> <p><a><b><span>Тема 7 Файловая система<o:p></o:p></span></b></a></p> <span></span> <p><b><span><br> 7.1 Понятие «файл»<o:p></o:p></span></b></p> <p><span>Одной из основных задач операционной системы является предоставление удобств пользователю при работе с данными, хранящимися на дисках. Для этого ОС подменяет физическую структуру хранящихся данных некоторой удобной для пользователя логической моделью. Логическая модель файловой системы материализуется в виде дерева каталогов, выводимого на экран такими утилитами, как </span><span>Norton Commander</span><span> или </span><span>Windows Explorer</span><span>, в символьных составных именах файлов, в командах работы с файлами. Базовым элементом этой модели является файл, который так же, как и файловая система в целом, может характеризоваться как логической, так и физической структурой.<o:p></o:p></span></p> <p><b><span>Файл</span></b><i><span> </span></i><span>–</span><i><span> </span></i><span>это именованная область внешней памяти, в которую можно записывать и из которой можно считывать данные. Файлы хранятся в памяти, на зависящей от энергопитания, обычно — на магнитных дисках. Однако нет правил без исключения. Одним из таких исключений является так называемый электронный диск, когда в оперативной памяти создается структура, имитирующая файловую систему.<o:p></o:p></span></p> <p><span>Основные цели использования файла перечислены ниже.<o:p></o:p></span></p> <p><i><span>Долговременное и надежное хранение информации. </span></i><span>Долговременность достигается за счет использования запоминающих устройств, не зависящих от питания, а высокая надежность определяется средствами защиты доступа к файлам и общей организацией программного кода ОС, при которой сбои аппаратуры чаще всего не разрушают информацию, хранящуюся в файлах.<o:p></o:p></span></p> <p><i><span>Совместное использование информации. </span></i><span>Файлы обеспечивают естественный и легкий способ разделения информации между приложениями и пользователями за счет наличия понятного человеку символьного имени и постоянства хранимой информации и расположения файла. Пользователь должен иметь удобные средства работы с файлами, включая каталоги-справочники, объединяющие файлы в группы, средства поиска файлов по признакам, набор команд для создания, модификации и удаления файлов. Файл может быть создан одним пользователем, а затем использоваться совсем другим пользователем, при этом создатель файла или администратор могут определить права доступа к нему других пользователей. Эти цели реализуются в ОС файловой системой.<o:p></o:p></span></p> <p><b><span>Файловая система (ФС)</span></b><i><span> </span></i><span>–<i> </i>это часть операционной системы, включающая:<o:p></o:p></span></p> <p> <span>совокупность всех файлов на диске;<o:p></o:p></span></p> <p> <span>наборы структур данных, используемых для управления файлами, такие, например, как каталоги файлов, дескрипторы файлов, таблицы распределения свободного и занятого пространства на диске;<o:p></o:p></span></p> <p> <span>комплекс системных программных средств, реализующих различные операции над файлами, такие как создание, уничтожение, чтение, запись, именование и поиск файлов.<o:p></o:p></span></p> <p><span>Файловая система позволяет программам обходиться набором достаточно простых операций для выполнения действий над некоторым абстрактным объектом, представляющим файл. При этом программистам не нужно иметь дело с деталями действительного расположения данных на диске, буферизацией данных и другими низкоуровневыми проблемами передачи данных с долговременного запоминающего устройства. Все эти функции файловая система берет на себя. Файловая система распределяет дисковую память, поддерживает именование файлов, отображает имена файлов в соответствующие адреса во внешней памяти, обеспечивает доступ к данным, поддерживает разделение, защиту и восстановление файлов.<o:p></o:p></span></p> <p><span>Таким образом, файловая система играет роль промежуточного слоя, экранирующего все сложности физической организации долговременного хранилища данных, и создающего для программ более простую логическую модель этого хранилища, а также предоставляя им набор удобных в использовании команд для манипулирования файлами.<o:p></o:p></span></p> <p><span>Задачи, решаемые ФС, зависят от способа организации вычислительного процесса в целом. Самый простой тип – это ФС в однопользовательских и однопрограммных ОС, к числу которых относится, например, </span><span>MS</span><span>-</span><span>DOS</span><span>. Основные функции в такой ФС нацелены на решение следующих задач:<o:p></o:p></span></p> <p> <span>именование файлов;<o:p></o:p></span></p> <p> <span>программный интерфейс для приложений;<o:p></o:p></span></p> <p> <span>отображения логической модели файловой системы на физическую организацию хранилища данных;<o:p></o:p></span></p> <p> <span>устойчивость файловой системы к сбоям питания, ошибкам аппаратных и программных средств.<o:p></o:p></span></p> <p><span>Задачи ФС усложняются в операционных однопользовательских мультипрограммных ОС, которые, хотя и предназначены для работы одного пользователя, но дают ему возможность запускать одновременно несколько процессов. Одной из первых ОС этого типа стала OS/2. К перечисленным выше задачам добавляется новая задача совместного доступа к файлу из нескольких процессов. Файл в этом случае является разделяемым ресурсом, а значит, файловая система должна решать весь комплекс проблем, связанных с такими ресурсами. В частности, в ФС должны быть предусмотрены средства блокировки файла и его частей, предотвращения гонок, исключение тупиков, согласование копий и т. п.<o:p></o:p></span></p> <p><span>В многопользовательских системах появляется еще одна задача: защита файлов одного пользователя от несанкционированного доступа другого пользователя. Еще более сложными становятся функции ФС, которая работает в составе сетевой ОС.<o:p></o:p></span></p> <p><b><span><br> 7.2 Типы файлов<o:p></o:p></span></b></p> <p><span>Файловые системы поддерживают несколько функционально различных типов файлов, в число которых, как правило, входят обычные файлы, файлы-каталоги, специальные файлы, именованные конвейеры, отображаемые в память файлы и другие.<o:p></o:p></span></p> <p><i><span>Обычные файлы, </span></i><span>или просто <i>файлы, </i>содержат информацию произвольного характера, которую заносит в них пользователь или которая образуется в результате работы системных и пользовательских программ. Большинство современных операционных систем (например, </span><span>UNIX</span><span>, </span><span>Windows</span><span>, OS/2) никак не ограничивает и не контролирует содержимое и структуру обычного файла. Содержание обычного файла определяется приложением, которое с ним работает. Например, текстовый редактор создает текстовые файлы, состоящие из строк символов, представленных в каком-либо коде. Это могут быть документы, исходные тексты программ и т. п. Текстовые файлы можно прочитать на экране и распечатать на принтере. Двоичные файлы не используют коды символов, они часто имеют сложную внутреннюю структуру, например исполняемый код программы или архивный файл. Все операционные системы должны уметь распознавать хотя бы один тип файлов – их собственные исполняемые файлы.<o:p></o:p></span></p> <p><i><span>Каталоги </span></i><span>–<i> </i>это особый тип файлов, которые содержат системную справочную информацию о наборе файлов, сгруппированных пользователями по какому-либо неформальному признаку (например, в одну группу объединяются файлы, содержащие документы одного договора, или файлы, составляющие один программный пакет). Во многих операционных системах в каталог могут входить файлы любых типов, в том числе другие каталоги, за счет чего образуется древовидная структура, удобная для поиска. Каталоги устанавливают соответствие между именами файлов и их характеристиками, используемыми файловой системой для управления файлами. В число таких характеристик входит, в частности, информация (или указатель на другую структуру, содержащую эти данные) о типе файла и расположении его на диске, правах доступа к файлу и датах его создания и модификации. Во всех остальных отношениях каталоги рассматриваются файловой системой как обычные файлы.<o:p></o:p></span></p> <p><i><span>Специальные файлы </span></i><span>– это фиктивные файлы, ассоциированные с устройствами ввода-вывода, которые используются для унификации механизма доступа к файлам и внешним устройствам. Специальные файлы позволяют пользователю выполнять операции ввода-вывода посредством обычных команд записи в файл или чтения из файла. Эти команды обрабатываются сначала программами файловой системы, а затем на некотором этапе выполнения запроса преобразуются операционной системой в команды управления соответствующим устройством.<o:p></o:p></span></p> <p><span>Современные файловые системы поддерживают и другие типы файлов, такие как символьные связи, именованные конвейеры, отображаемые в память файлы.<o:p></o:p></span></p> <p><b><span><br> 7.3 Логическая и физическая организация файловой системы<o:p></o:p></span></b></p> <p><span>Пользователи обращаются к файлам по символьным именам. Однако способности человеческой памяти ограничивают количество имен объектов, к которым пользователь может обращаться по имени. Иерархическая организация пространства имен позволяет значительно расширить эти границы. Именно поэтому большинство файловых систем имеет иерархическую структуру, в которой уровни создаются за счет того, что каталог более низкого уровня может входить в каталог более высокого уровня (рисунок 1, </span><span>a</span><span>).<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shapetype id="_x0000_t75"
 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
 filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="Рисунок_x0020_29" o:spid="_x0000_i1025" type="#_x0000_t75"
 style='width:329.25pt;height:382.5pt;visibility:visible'>
 <v:imagedata src="Тема%20№7.files/image001.png" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№7.files/image002.gif" v:shapes="Рисунок_x0020_29"></span><span><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок 1 – Иерархия файловых систем<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Граф, описывающий иерархию каталогов, может быть деревом или сетью. Каталоги образуют дерево, если файлу разрешено входить только в </span><span>один каталог; (рисунок 1, б),<i> </i>и сеть <span>–</span> если файл может входить сразу в несколько каталогов (рисунок 1, в).<i> </i>Например, в </span><span>MS</span><span>-</span><span>DOS</span><span> и </span><span>Windows</span><span> каталоги образуют древовидную структуру, а в </span><span>UNIX</span><span> <span>–</span> сетевую. В древовидной структуре каждый файл является <i>листом. </i>Каталог самого верхнего уровня называется <i>корневым каталогом, </i>или <i>корнем (</i></span><i><span>root</span></i><i><span>).</span></i><span><o:p></o:p></span></p> <p><span>При такой организации пользователь освобожден от запоминания имен всех файлов, ему достаточно примерно представлять, к какой группе может быть отнесен тот или иной файл, чтобы путем последовательного просмотра каталогов найти его. Иерархическая структура удобна для многопользовательской работы: каждый пользователь со своими файлами локализуется в своем каталоге или поддереве каталогов, и вместе с тем все файлы в системе логически связаны.<o:p></o:p></span></p> <p><span>Частным случаем иерархической структуры является одноуровневая организация, когда все файлы входят в один каталог (рисунок 1, a).<o:p></o:p></span></p> <p><span>Представление пользователя о файловой системе как об иерархически организованном множестве информационных объектов имеет мало общего с порядком хранения файлов на диске. Файл, имеющий образ цельного, непрерывающегося набора байт, на самом деле очень часто разбросан «кусочками» по всему диску, причем это разбиение никак не связано с логической структурой файла, например, его отдельная логическая запись может быть расположена в несмежных секторах диска. Логически объединенные файлы из одного каталога совсем не обязаны соседствовать на диске. Принципы размещения файлов, каталогов и системной информации на реальном устройстве описываются физической организацией файловой системы. Очевидно, что разные файловые системы имеют разную физическую организацию.<o:p></o:p></span></p> <p><span>Основным типом устройства, которое используется в современных вычислительных системах для хранения файлов, являются дисковые накопители. Эти устройства предназначены для считывания и записи данных на жесткие и гибкие магнитные диски. Жесткий диск состоит из одной или нескольких стеклянных или металлических пластин, каждая из которых покрыта с одной или двух сторон магнитным материалом. Таким образом, диск в общем случае состоит из пакета пластин (рисунок 2).<o:p></o:p></span></p> <p><span>На каждой стороне каждой пластины размечены тонкие концентрические кольца <span>–</span> <i>дорожка</i> (traks), на которых хранятся данные. Количество дорожек зависят от типа диска. Нумерация дорожек начинается с 0 от внешнего края к центру диска. Когда диск вращается, элемент, называемый головкой, считывает двоичные данные с магнитной дорожки или записывает их на магнитную дорожку.<o:p></o:p></span></p> <p><span>Головка может позиционироваться над заданной дорожкой. Головки перемещаются над поверхностью диска дискретными шагами, каждый шаг соответствует сдвигу на одну дорожку. Запись на диск осуществляется благодаря способности головки изменять магнитные свойства дорожки. В некоторых дисках вдоль каждой поверхности перемещается одна головка, а в других <span>–</span> имеется по головке на каждую дорожку. В первом случае для поиска информации головка должна перемещаться по радиусу диска. Обычно все головки закреплены на едином перемещающем механизме и двигаются синхронно. Поэтому, когда головка фиксируется на заданной дорожке одной поверхности, все остальные головки останавливаются над дорожками с такими же номерами. В тех же случаях, когда на каждой дорожке имеется отдельная головка, никакого перемещения головок с одной дорожки на другую не требуется, за счет этого экономится время, затрачиваемое на поиск данных.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape
 id="_x0000_i1026" type="#_x0000_t75" style='width:459.75pt;height:333.75pt'>
 <v:imagedata src="Тема%20№7.files/image003.png" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№7.files/image004.jpg" v:shapes="_x0000_i1026"><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок <a></a>2</span><span> </span><span>–</span><span> </span><span>Схема устройства жесткого диска<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Совокупность дорожек одного радиуса на всех поверхностях всех пластин пакета называется цилиндром (cylinder). Каждая дорожка разбивается на фрагменты, называемые секторами (sectors), или блоками (blocks), так что все дорожки имеют равное число секторов, в которые можно максимально записать одно и то же число байт. Сектор имеет фиксированный для конкретной системы размер, выражающийся степенью двойки. Чаще всего размер сектора составляет 512 байт. Учитывая, что дорожки разного радиуса имеют одинаковое число секторов, плотность записи становится тем выше, чем ближе дорожка к центру.<o:p></o:p></span></p> <p><span>Сектор <span>–</span> наименьшая адресуемая единица обмена данными дискового устройства с оперативной памятью. Для того чтобы контроллер мог найти на диске нужный сектор, необходимо задать ему все составляющие адреса сектора: номер цилиндра, номер поверхности и номер сектора.<o:p></o:p></span></p> <p><span>Так как прикладной программе в общем случае нужен не сектор, а некоторое количество байт, не обязательно кратное размеру сектора, то типичный запрос включает чтение нескольких секторов, содержащих требуемую информацию, и одного или двух секторов, содержащих наряду с требуемыми и избыточные данные.<o:p></o:p></span></p> <p><span>Операционная система при работе с диском использует, как правило, собственную единицу дискового пространства, называемую кластером (cluster). При создании файла место на диске ему выделяется кластерами. Например, если файл имеет размер 2560 байт, а размер кластера в файловой системе определен в 1024 байта, то файлу будет выделено на диске 3 кластера.<o:p></o:p></span></p> <p><span>Дорожки и секторы создаются в результате выполнения процедуры физического, или низкоуровневого, форматирования диска, предшествующей использованию диска. Для определения границ блоков на диск записывается идентификационная информация. Низкоуровневый формат диска не зависит от типа операционной системы, которая этот диск будет использовать.<o:p></o:p></span></p> <p><span>Разметку диска под конкретный тип файловой системы выполняют процедуры высокоуровневого, или логического, форматирования. При высокоуровневом форматировании определяется размер кластера и на диск записывается информация, необходимая для работы файловой системы, в том числе информация о доступном и неиспользуемом пространстве, о границах областей, отведенных под файлы и каталоги, информация о поврежденных областях. Кроме того, на диск записывается загрузчик операционной системы <span>–</span> небольшая программа, которая начинает процесс инициализации операционной системы после включения питания или рестарта компьютера.<o:p></o:p></span></p> <p><span>Прежде чем форматировать диск под определенную файловую систему, он может быть разбит на разделы. Раздел <span>–</span> это непрерывная часть физического диска, которую операционная система представляет пользователю как логическое устройство (используются также названия логический диск и логический раздел). Логическое устройство функционирует так, как если бы это был отдельный физический диск. Именно с логическими устройствами работает пользователь, обращаясь к ним по символьным именам, используя, например, обозначения А, В, С, SYS и т. п. Операционные системы разного типа используют единое для всех них представление о разделах, но создают на его основе логические устройства, специфические для каждого типа ОС. Так же как файловая система, с которой работает одна ОС, в общем случае не может интерпретироваться ОС другого типа, логические устройства не могут быть использованы операционными системами разного типа. На каждом логическом устройстве может создаваться только одна файловая система.<o:p></o:p></span></p> <p><span>В частном случае, когда все дисковое пространство охватывается одним разделом, логическое устройство представляет физическое устройство в целом. Если диск разбит на несколько разделов, то для каждого из этих разделов может быть создано отдельное логическое устройство. Логическое устройство может быть создано и на базе нескольких разделов, причем эти разделы не обязательно должны принадлежать одному физическому устройству. Объединение нескольких разделов в единое логическое устройство может выполняться разными способами и преследовать разные цели, основные из которых: увеличение общего объема логического раздела, повышение производительности и отказоустойчивости. Примерами организации совместной работы нескольких дисковых разделов являются так называемые RAID-массивы, подробнее о которых будет сказано далее.<o:p></o:p></span></p> <p><span>На разных логических устройствах одного и того же физического диска могут располагаться файловые системы разного типа. Все разделы одного диска имеют одинаковый размер блока, определенный для данного диска в результате низкоуровневого форматирования. Однако в результате высокоуровневого форматирования в разных разделах одного и того же диска, представленных разными логическими устройствами, могут быть установлены файловые системы, в которых определены кластеры отличающихся размеров.<o:p></o:p></span></p> <p><span>Операционная система может поддерживать разные статусы разделов, особым образом отмечая разделы, которые могут быть использованы для загрузки модулей операционной системы, и разделы, в которых можно устанавливать только приложения и хранить файлы данных. Один из разделов диска помечается как загружаемый (или активный). Именно из этого раздела считывается загрузчик операционной системы.<o:p></o:p></span></p> <p><b><span><br> 7.4 Работа с файлами в современных операционных системах<o:p></o:p></span></b></p> <p><span>Файловая система </span><span>–</span><span> часть операционной системы, управляющая размещением и доступом к файлам и каталогам на диске. <o:p></o:p></span></p> <p><span><span> </span><span> </span>С понятием файловой системы тесно связано понятие файловой структуры диска, под которой понимают, как размещаются на диске: главный каталог, подкаталоги, файлы, операционная система, а также какие для них выделены объемы секторов, кластеров, дорожек. <o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><b><span>Тип файла<o:p></o:p></span></b></p> <p><span><span> </span><span> </span>В основе любой операционной системы лежит принцип организации работы внешнего устройства хранения информации. Несмотря на то, что внешняя память может быть технически реализована на разных материальных носителях (например, в виде гибкого магнитного диска или магнитной ленты), их объединяет принятый в операционной системе принцип организации хранения логически связанных наборов информации в виде так называемых файлов. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Файл </span><span>–</span><span> логически связанная совокупность данных или программ, для размещения которой во внешней памяти выделяется именованная область. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Файл служит учетной единицей информации в операционной системе. Любые действия с информацией в MS DOS осуществляются над файлами: запись на диск, вывод на экран, ввод с клавиатуры, печать, считывание информации CD-ROM и пр. <o:p></o:p></span></p> <p><span><span> </span><span> </span>На диске файл не требует для своего размещения непрерывного пространства, обычно он занимает свободные кластеры в разных частях диска. Сведения о номерах этих кластеров хранятся в специальной FAT-таблице. Кластер является минимальной единицей пространства диска, которое может быть отведено файлу. Самый маленький файл занимает один кластер, большие файлы </span><span>–</span><span> несколько десятков кластеров.<o:p></o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span><o:p> </o:p></span></p> <p><span><o:p> </o:p></span></p> <p style="text-align: center;"><span><!--[if gte vml 1]><v:shape id="Рисунок_x0020_37"
 o:spid="_x0000_i1027" type="#_x0000_t75" style='width:392.25pt;height:101.25pt;
 visibility:visible'>
 <v:imagedata src="Тема%20№7.files/image005.gif" o:title=""/>
</v:shape><![endif]--><img src="Тема%20№7.files/image005.gif" v:shapes="Рисунок_x0020_37"></span><span><o:p></o:p></span></p> <p style="text-align: center;"><span>Рисунок 3 - Иерархическая структура файловой системы<o:p></o:p></span></p> <p><span><span> </span><span> </span>Файловая система представлена иерархической структурой, то есть существует несколько различных уровней иерархии каталогов, что отражается следующей схемой: <o:p></o:p></span></p> <p><i><span>Логическая организация файловой системы.<o:p></o:p></span></i></p> <p><span><span> </span><span> </span>Логически файл представляет собой совокупность записей, а система управления файлами представляет механизм доступа к отдельным записям. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Способы доступа: последовательный.<o:p></o:p></span></p> <p><span><span> </span><span> </span>Записи в файл упорядочены последовательными целыми числами. При таком способе организации файлов естественна. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Доступ организуется к записям файлов через ключевые поля записей. Необходимое условие </span><span>–</span><span> различие ключевых полей. <o:p></o:p></span></p> <p><i><span>Физическая организация файловой системы.<o:p></o:p></span></i></p> <p><span><span> </span><span> </span><span> </span>Система управления файлами осуществляет физическое размещение файлов на магнитных носителях. <o:p></o:p></span></p> <p><span><span> </span><span> </span><span> </span></span><span>–<span> </span></span><span>Способы размещения: с использованием смежностей (последовательный). Каждый файл во внешней памяти занимает совокупность последовательных блоков. Преимуществом этого способа является высокая эффективность последовательного доступа (тратится меньше времени). Недостатком является увеличение размера файла при отсутствии в его конце свободной памяти возможно только при полном копировании в свободную зону, что также не эффективно, а также раздробленность внешней памяти после определенного числа операций. <o:p></o:p></span></p> <p><span><span> </span><span> </span><span> </span></span><span>–<span> </span></span><span>Без использования смежностей. Без использования свойства размещения файла во внешней памяти требует определенных затрат времени на организацию связи между отдельными блоками файла. Для эффективной реализации все указатели на блоке файла, т.е. сведения о номерах кластеров объединяются в FAT-таблицы. <o:p></o:p></span></p> <p><b><span>Файловые операции.<o:p></o:p></span></b></p> <p><span><span> </span><span> </span>Для начала обозначим правила составления имени файла: имя файла всегда уникально и служит для отличия одного файла от другого. Имя файла образуется не более чем из восьми символов, причем используются только буквы латинского алфавита. <o:p></o:p></span></p> <p><span>Команда MOVE - перемещение файла. <o:p></o:p></span></p> <p><span>Команда EDIT - редактирование текстового файла. <o:p></o:p></span></p> <p><span>Команда TYPE - просмотр текстового файла. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Командой TYPE удобно пользоваться для просмотра содержимого текстового файла на экране дисплея или на принтере. После запуска команды текст (содержимое файла) выводится непрерывным потоком, причем скорость смены кадров с текстом на экране настолько велика, что прочесть его весьма затруднительно. Для приостановки вывода текста нажмите одновременно две клавиши CTRL+S. Нажатие любой клавиши возобновит вывод текста. <o:p></o:p></span></p> <p><span><span> </span>C:\>TYPE K1S.TXT - Вывод на экран содержимого текстового файла KIS.TXT, хранящегося в главном каталоге активного дисковода. <o:p></o:p></span></p> <p><span><span> </span></span><span>C:\>TYPE A:\RED\LEX\KNI. </span><span>TXT - Вывод на экран содержимого текстового файла KNI.TXT <o:p></o:p></span></p> <p><span><span> </span>C:\>TYPE \KRAB\BOM.TXT>PRN - Печать содержимого текстового файла ВОМ.ТХТ, хранящегося в подкаталоге первого уровня KRAB текущего дисковода С. <o:p></o:p></span></p> <p><span>Команда DEL </span><span>–</span><span> удаление файлов. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Командой DEL вы воспользуетесь для удаления файлов. Можно удалять как один файл, так и группу файлов, указывая в имени файла * или ?. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Параметр /Р служит для вывода на экран запроса на подтверждение удаления. При вводе команды удаления всех файлов (полное имя файла записывается в виде *.*) операционная система задает вопрос Are You sure (Y/N)? Если вы не передумали, нажмите клавишу <Y>, в противном случае - клавишу <N>. <o:p></o:p></span></p> <p><span><span> </span>C:\>DEL TOST.ASM - Удаление файла TOST.ASM из главного каталога текущего дисковода C. <o:p></o:p></span></p> <p><span><span> </span>C:\>DEL A:\AR\BIM.TXT - Удаление файла BIM.TXT из подкаталога 1-го уровня AR пассивного дисковода A. <o:p></o:p></span></p> <p><span><span> </span>C:\>DEL \A1\A2\*. BAS - Удаление всех файлов типа .BAS из подкаталога 2-го уровня A2 текущего дисковода C. <o:p></o:p></span></p> <p><span><span> </span>C:\F1>DEL F2\*.* /P - Удаление с подтверждением всех файлов из подчиненного текущему каталогу F1 подкаталога 2-го уровня F2 текущего дисковода C. <o:p></o:p></span></p> <p><span>Команда REN </span><span>–</span><span> переименование файла. <o:p></o:p></span></p> <p><span>Команда COPY </span><span>–</span><span> копирование файлов. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Этой командой вы будете пользоваться для создания копий существующих файлов. Помимо этой основной функции команда COPY будет полезна и для выполнения двух вспомогательных функций:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>вывода содержимого файла на внешнее устройство;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>объединения содержимого нескольких файлов.<o:p></o:p></span></p> <p><span><span> </span><span> </span>Команда COPY допускает выполнение функций над группой файлов, и тогда в именах файлов используются символы * и ?. Параметр /V контролирует процесс копирования. <o:p></o:p></span></p> <p><span><span> </span><span> </span><span> </span>В команде COPY указываются две группы параметров:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>названных источником для копируемого файла;<o:p></o:p></span></p> <p><![if !supportLists]><span><span>–<span> </span></span></span><![endif]><span>названных приемником для полученного файла.<o:p></o:p></span></p> <p><span><span> </span>Обязательным параметром является только полное имя файла источника. Все остальные параметры вы задаете по мере надобности. Если вы копируете файл (группу файлов) с тем же именем (именами), то достаточно указать только полное имя файла-источника. Имя дисковода и путь нужны при работе с пассивным дисководом и каталогом. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY KIT.PAS A: </span><span>–</span><span> Копирование файла KIT.PAS из главного каталога текущего дисковода С на гибкий диск А с тем же именем. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY A:\A2\KRIK.TXT \B1\B2\B3 </span><span>–</span><span> Копирование файла KRIK.TXT из каталога 2-го уровня А2 в каталог 3-го уровня В3 с тем же именем. Копирование производится на диск текущего дисковода <o:p></o:p></span></p> <p><span><span> </span><span> </span>C:\>COPY A:\TROS.BAS </span><span>–</span><span> Копирование файла TROS.BAS с диска пассивного дисковода А в главный каталог текущего дисковода С с тем же именем. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY A:\TEM.TXT A1\A2\SVET.TXT </span><span>–</span><span> Копирование файла ТЕМ.ТХТ с диска пассивного дисковода в каталог 2-го уровня А2 текущего дисковода. Полученной копии файла присваивается новое имя SVЕТ. ТХТ. <o:p></o:p></span></p> <p><span><span> </span>C:\A1>COPY *.BAS B:/V </span><span>–</span><span> Копирование всех файлов типа .BAS из текущего каталога 1-го уримня А1 дисковода С на диск пассивного дисковода В с одновременным контролем процесса копирования. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Имена объединяемых файлов перечисляются в команде COPY через знак плюс (+). Имя результирующего файла записывается последним и отделяется от имен объединяемых файлов пробелом. Содержимое результирующего файла представляет собой подсоединенное друг за другом содержимое исходных файлов в соответствии с порядком следования их имен в команде COPY. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY M1.TXT+M2.TXT \KAT1\SUM.TXT - Объединение двух текстовых файлов М1.ТХТ и М2.ТХТ в один файл SUM.TXT. который будет записан в каталог 1-го уровня КАТ1. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY T1.TXT+T2.TXT - Объединение двух текстовых файлов Т1.ТХТ и Т2.ТХТ. К содержимому файла Т1.ТХТ добавляется содержимое файла Т2.ТХТ, и результат объединения будет храниться в исходном файле Т1.ТХТ. <o:p></o:p></span></p> <p><span><span> </span><span> </span>Под внешним устройством здесь понимается любое устройство, кроме системного блока и дисководов. К внешним устройствам относятся клавиатура, дисплей, принтер, устройства, организующие связь с другим компьютером. В операционной системе приняты соглашения относительно имен внешних устройств. К наиболее употребительным относятся: <o:p></o:p></span></p> <p><span><span> </span>CON </span><span>–</span><span> клавиатура и дисплей (консоль), создание файла; <o:p></o:p></span></p> <p><span><span> </span>PRN или LPT1 </span><span>–</span><span>основной принтер. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY TON.TXT PRN - Печать содержимого текстового файла на принтере. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY CON SIM.TXT - Заполнение файла SIM.TXT поступающими с клавиатуры символами. <o:p></o:p></span></p> <p><span><span> </span>C:\>COPY CON PRN - Все символы, набираемые с клавиатуры, печатаются, минуя центральную часть компьютера, т.е. компьютер используется как пишущая машинка. Одновременно компьютер может обрабатывать информацию в соответствии с программой, где не требуется обращение к принтеру.<o:p></o:p></span></p> <p><b><span><br> 7.5 Создание, открытие и удаление файлов<o:p></o:p></span></b></p> <p><span>В </span><span>Windows </span><span>есть функция, которая создает или открывает дисковые файлы:<o:p></o:p></span></p> <p><b><span> </span></b><span><o:p></o:p></span></p> <p><span>HANDLE <b>CreateFile</b> (LPCSTR <i>lpFileName</i>,<o:p></o:p></span></p> <p><span>DWORD <i>dwDESIredAccess</i>,<o:p></o:p></span></p> <p><span>DWORD <i>dwShareMode</i>,<o:p></o:p></span></p> <p><span>LPSECURITY_ATTRIBUTES <i>pSecurityAttributes</i>,<o:p></o:p></span></p> <p><span>DWORD <i>dwCreationDistribution</i>, <o:p></o:p></span></p> <p><span>DWORD <i>dwFlagsAndAttributes</i>,<o:p></o:p></span></p> <p><span>HANDLE <i>hTemplateFile</i>); <o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>В 16-разрядной</span><span> Windows </span><span>файлы создаются и открываются функциями</span><span> <i>OpenFile</i></span><i><span>, _</span></i><i><span>lcreat </span></i><span>и</span><span> </span><i><span>_</span></i><i><span>lopen</span></i><i><span>.</span></i><i><span> </span></i><span>Для совместимости они перенесены и в Win32, но по возможности их следует избегать. В Win32-пpилoжeнияx файлы лучше создавать и открывать, используя гораздо более мощную функцию </span><i><span>CreateFile</span></i><i><span>.</span></i><span><o:p></o:p></span></p> <p><span>Параметр </span><i><span>lpFileName </span></i><span>идентифицирует одновременно и тип, и определенный экземпляр устройства.<o:p></o:p></span></p> <p><span>Открывая файл, можно передать полный путь к нему, длина которого не должна превышать _МАХ_РАТН символов. Однако в </span><span>Windows NT</span><span> это ограничение можно преодолеть, обратившись к <b>CreateFileW</b><i> </i>(</span><span>Unicode</span><span>-версии <b>CreateFile</b><i>) </i>и указав перед путем такой префикс: «\\?\». Если использовался этот префикс, <b>CreateFileW</b><i> </i>удалит его и разрешит передать путь, содержащий приблизительно до 32000 </span><span>Unicode</span><span>-символов. Но, указав данный префикс, необходимо задать полный, а не относительный путь.<o:p></o:p></span></p> <p><a></a><span>Параметр </span><i><span>dwDesiredAccess </span></i><span>определяет способ передачи данных. Он принимает одно из четырех значений:<o:p></o:p></span></p> <p><b><span>0</span></b><span> – Запись или чтение данных с устройства не предполагается.<o:p></o:p></span></p> <p><b><span>GENERIC_READ</span></b><span> – устройство доступно только для чтения.<o:p></o:p></span></p> <p><b><span>GENERIC_WRITE</span></b><span> – устройство доступно только для записи. Заметьте: установка GENERIC_WRITE не подразумевает автоматической установки GENERIC_READ. Это значение используется при передаче данных на принтер, а также программами резервного копирования.<o:p></o:p></span></p> <p><b><span>GENERIC_READ|GENERIC_WRITE – </span></b><span>устройство доступно как для чтения, так и для записи. Это значение встречается чаще всего, поскольку обеспечивает свободный обмен данными.<o:p></o:p></span></p> <p><span> Параметр </span><i><span>dwShareMode </span></i><span>определяет режим совместного использования устройства. В отличие от 16-разрядной </span><span>Windows</span><span>, в </span><span>Windows</span><span> 95 и </span><span>Windows NT</span><span> типична ситуация, когда к какому-то устройству одновременно обращаются несколько компьютеров (в сетевой среде) или процессов (в многопоточной среде). Допустимые зн<a></a>ачения параметра </span><i><span>dwShareMode</span></i><i><span>:</span></i><span><o:p></o:p></span></p> <p><b><span>0</span></b><span> – монопольный доступ к устройству. Если оно уже открыто, вызов CreateFile даст ошибку.<o:p></o:p></span></p> <p><b><span>FILE_SHARE_READ </span></b><span>– устройство доступно только для чтения. Если оно уже открыто для записи, вызов <b>CreateFile</b> даст ошибку.<o:p></o:p></span></p> <p><b><span>FILE_SHARE_WRITE</span></b><span> – устройство доступно только для записи. Если оно уже открыто на чтение, вызов <b>CreateFile</b> даст ошибку.<o:p></o:p></span></p> <p><b><span>FILE_SHARE_READ| FILE_SHARE_ WRITE</span></b><span> – устройство доступно как для чтения, так и для записи. Если устройство уже открыто в монопольном режиме, вызов CreateFile даст ошибку. Повторный вызов CreateFile с требованием предоставить доступ для чтения или записи завершится успешно.<o:p></o:p></span></p> <p><span>Четвертый параметр, </span><i><span>pSecurityAttributes</span></i><i><span>, </span></i><span>указывает на структуру </span><span>SECURITY</span><span>_</span><span>ATTRIBUTES</span><span>, которая позволяет задать атрибуты защиты для связанного с устройством объекта ядра и определить, будет ли возращенный описатель наследуемым (т. е. получит ли дочерний процесс доступ к устройству). Если устраивают атрибуты защиты по умолчанию и не нужен наследуемый описатель, то передаётся </span><span>NULL</span><span> вместо этого параметра.<o:p></o:p></span></p> <p><a></a><span>Параметр </span><i><span>dwCreationDistribution </span></i><span>важен, когда <b>CreateFile</b><i> </i>вызывается для открытия именно файла, а не устройства какого-то другого типа. Его допустимые значения:<o:p></o:p></span></p> <p><b><span>CREATE_NEW</span></b><span> – заставляет <b>CreateFile</b> создать новый файл. Если файл с указанным именем уже есть, функция даст ошибку.<o:p></o:p></span></p> <p><b><span>CREATE_ALWAYS </span></b><span>– заставляет CreateFile создать файл независимо от того, имеется ли файл с таким именем. Если есть, функция замещает его новым.<o:p></o:p></span></p> <p><b><span>OPEN_EXISTING</span></b><span> – заставляет CreateFile открыть существующий файл, а если его нет, сообщить об ошибке.<o:p></o:p></span></p> <p><b><span>OPEN_ALWAYS</span></b><span> – заставляет CreateFile открыть существующий файл, а если его нет, создать новый.<o:p></o:p></span></p> <p><b><span>TRUNCATE_EXISTING</span></b><span> – заставляет CreateFile открыть существующий файл, обрезав его длину до 0. Если такого файла нет, функция даст ошибку. Этот флаг можно использовать только вместе с флагом GENERIC_WRITE. <o:p></o:p></span></p> <p><span>Параметр </span><i><span>dwFlagsAndAttributes </span></i><span>служит двум целям: позволяет задавать флаги, тонко настраивающие взаимодействие с устройством, а если устройство является файлом, то и устанавливать атрибуты. Рассмотрим сначала флаги, потом — файловые атрибуты.<o:p></o:p></span></p> <p><span>Большая часть таких флагов сообщает системе, как будет производиться работа с устройством. После этого система оптимизирует алгоритмы кэширования, обеспечивая более эффективное выполнение программы.<o:p></o:p></span></p> <p><span>Флаг <b>FILE_FLAG_NO_BUFFERING</b> влияет на ввод/вывод в файловых системах. Чтобы повысить производительность, система кэширует данные, записываемые или считываемые с дисков. Обычно этот флаг не устанавливается, и диспетчер кэша сохраняет в памяти участки, к которым происходило обращение в последний раз. Если было считано несколько байтов из файла и будет считываться новая порция, то с большой долей вероятности эти данные уже находятся в памяти, и поэтому требуется лишь одно обращение к диску вместо двух (что увеличивает производительность системы).<o:p></o:p></span></p> <p><span>Установив флаг </span><span>FILE</span><span>_</span><span>FLAG</span><span>_</span><span>NO</span><span>_</span><span>BUFFERING</span><span>, можно заставить диспетчер кэша отказаться от буферизации каких-либо данных.<o:p></o:p></span></p> <p><span>Следующие два флага — <b>FILE_FLAG_SEQUENTIAL_SCAN</b> и <b>FILE_FLAG_RANDOM_ACCESS</b> — имеют смысл, только если система буферизует данные. Когда установлен режим</span><span>FILE</span><span>_</span><span>FLAG</span><span>_</span><span>NO</span><span>_</span><span>BUFFERING</span><span>, оба эти флага игнорируются.<o:p></o:p></span></p> <p><span>Флаги файловых атрибутов полностью игнорируются во всех случаях, кроме одного, — когда создаётся новый файл и функции </span><i><span>CreateFile </span></i><span>вместо параметра </span><i><span>hTemplateFile </span></i><span>передаётсязначение </span><span>NULL</span><span>. <o:p></o:p></span></p> <p><span>Последний параметр функции <b>CreateFile</b><i> — </i></span><i><span>hTemplateFile </span></i><span>— содержит или описатель открытого файла, или </span><span>NULL</span><span>. Если в </span><i><span>hTemplateFile </span></i><span>указан описатель файла, </span><i><span>CreateFile </span></i><span>игнорирует флаги атрибутов в параметре </span><i><span>dwFlagsAndAttributes</span></i><i><span> и </span></i><span>использует атрибуты того файла, на который указывает параметр </span><i><span>hTemplateFile</span></i><i><span>. </span></i><span>(Чтобы такая схема сработала, файл надо открыть с флагом</span><span>GENERIC</span><span>_</span><span>READ</span><span>.) Если </span><i><span>CreateFile </span></i><span>не создает новый файл, а открывает существующий, параметр </span><i><span>hTemplateFile </span></i><span>игнорируется<i>.</i><o:p></o:p></span></p> <p><span>Если </span><i><span>CreateFile </span></i><span>успешно создаст или откроет устройство или файл, она вернет описатель этого устройства или файла, а при ошибке — код </span><span>INVALID</span><span>_</span><span>HANDLE</span><span>_</span><span>VALUE</span><span>.<o:p></o:p></span></p> <p><span>Большинство </span><span>Win</span><span>32-функций при неудаче возвращают </span><span>NULL</span><span>, но </span><i><span>CreateFile </span></i><span>в таких случаях возвращает </span><span>INVALID</span><span>_</span><span>HANDLE</span><span>_</span><span>VALUE</span><span> (определенный как </span><span>OxFFFFFFFF</span><span>)<o:p></o:p></span></p> <p><span>Для удаления файла служит функция:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>BOOL <b>DeleteFile</b></span><span> (</span><span>LPCSTR </span><i><span>lpFileName</span></i><span>);<o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>Удалив файл, заданный в параметре <i>l</i></span><i><span>pFileName</span></i><i><span>, </span></i><span>функция возвращает </span><span>TRUE</span><span> при благополучном завершении или сообщает об ошибке, если файл не существует или открыт каким-то процессом.<o:p></o:p></span></p> <p><b><span><br> 7.6 Запись информации в файл и чтение информации из файла<o:p></o:p></span></b></p> <p><span>Запись в файл производится с помощью функции </span><b><span>WriteFile</span></b><b><span>:</span></b><span><o:p></o:p></span></p> <p><b><span> </span></b><span><o:p></o:p></span></p> <p><span>BOOL <b>WriteFile</b> (HANDLE <i>hFile</i>,<o:p></o:p></span></p> <p><span>LPCVOID <i>lpBuffer</i>,<o:p></o:p></span></p> <p><span>DWORD <i>nNumberOfBytesToWrite</i>,<o:p></o:p></span></p> <p><span>LPDWORD <i>lpNumberOfBytesWritten</i>,<o:p></o:p></span></p> <p><span>LPOVERLAPPED <i>lpOverlapped</i>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Данная функция записывает информацию в файл.<o:p></o:p></span></p> <p><span>Она имеет следующие параметры:<o:p></o:p></span></p> <p><i><span>hFile</span></i><span> – хэндл файла.<o:p></o:p></span></p> <p><i><span>lpBuffer</span></i><span> – указатель на буфер, данные из которого нужно записать.<o:p></o:p></span></p> <p><i><span>nNumberOfBytesToWrite </span></i><span>– число байтов, которые заисываются в файл.<o:p></o:p></span></p> <p><i><span>IpNumberOfBytesWritten</span></i><span> – указатель на буфер, в который после выполнения функции будет записано число байтов, записанных в файл.<o:p></o:p></span></p> <p><i><span>lpOverlapped</span></i><span> – указатель на структуру типа </span><span>OVERLAPPED</span><span>, которая используется в случае асинхронного ввода-вывода.<o:p></o:p></span></p> <p><span>В случае успешного выполнения функция возвращает</span><span><span> </span></span><span>TRUE</span><span>, в случае неудачи –</span><span><span> </span></span><span>FALSE</span><span>.<o:p></o:p></span></p> <p><b><span>Пример</span></b><span>. Необходимо в файл созданный ранее записать фразу «Системное программирование».<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>char Buffer</span><span>[]=”Системное программирование”; //строка для записи<o:p></o:p></span></p> <p><span>DWORD dwBytes</span><span>; // в эту переменную функция вернёт кол-во байт записанных в файл<o:p></o:p></span></p> <p><span>WriteFile</span><span> (<o:p></o:p></span></p> <p><span>myFile</span><span>, // хэндл файла в который производится запись<o:p></o:p></span></p> <p><span>Buffer</span><span>,<o:p></o:p></span></p> <p><span>sizeof</span><span>(</span><span>Buffer</span><span>), // размер записанной строки<o:p></o:p></span></p> <p><span>&</span><span>dwBytes</span><span>,<o:p></o:p></span></p> <p><span>NULL</span><span>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Чтение информации из файла производится с помощью функции <b>ReadFile</b>, которая имеет параметры, аналогичные функции </span><span>WriteFile</span><span>.<o:p></o:p></span></p> <p><b><span><br> 7.7 Понятие «файл, отображаемый на память»<o:p></o:p></span></b></p> <p><span>С приходом </span><span>Windows</span><span>'95 ситуация несколько изменилась. Одним из новшеств, предлагаемых этой операционной системой, были так называемые файлы, проецируемые в память. При использовании проецируемых в память файлов мы можем, практически не занимая оперативную память, обращаться к файлу, таким образом, словно файл полностью загружен в ОЗУ. Для анализа файлов более удобного средства, наверное, и не придумаешь, так как можно обойтись без операций файлового ввода – вывода и буферизации.<o:p></o:p></span></p> <p><span>Для того чтобы отобразить файл в память нужно выполнить три операции:<o:p></o:p></span></p> <p><span>1. Создать или открыть объект ядра «файл», идентифицирующий дисковый файл, который будет использован как проецируемый в память.<o:p></o:p></span></p> <p><span>2. Создать объект ядра «проекция файла», чтобы сообщить системе размер файла и способ доступа к нему.<o:p></o:p></span></p> <p><span>3. Указать системе, как спроецировать в адресное пространство процесса объект «проекция файла» — целиком или частично.<o:p></o:p></span></p> <p><span>Закончив работу с проецируемым в память файлом, следует выполнить тоже три операции:<o:p></o:p></span></p> <p><span>1. Сообщить системе об отмене проецирования на адресное пространство процесса объекта ядра «проекция файла».<o:p></o:p></span></p> <p><span>2. Закрыть этот объект.<o:p></o:p></span></p> <p><span>3. Закрыть объект ядра «файл».<o:p></o:p></span></p> <p><b><span><br> 7.8 Проецирование файловых данных на адресное пространство процесса и отключение от него<o:p></o:p></span></b></p> <p><span>Когда объект «проекция файла» создан, нужно, чтобы система, зарезервировав регион адресного пространства под данные файла, передала их как физическую память, отображенную на регион. Это</span><span> </span><span>делает</span><span> </span><span>функция</span><span> <b>MapViewOfFile</b></span><span>:<o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>LPVOID <b>MapViewOfFile</b> </span><span>(</span><span>HANDLE <i>hFileMappingObject</i></span><span>,<o:p></o:p></span></p> <p><span> DWORD <i>dwDESIredAcceSS</i></span><span>,<o:p></o:p></span></p> <p><span> DWORD <i>dwFileOffsetHigh</i>,<o:p></o:p></span></p> <p><span> DWORD <i>dwFileOffsetLow</i>,<o:p></o:p></span></p> <p><span> SIZE_T <i>dwNumberOfBytesToMap</i>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Параметр </span><i><span>hFileMappingObject </span></i><span>идентифицирует описатель объекта «проекция файла», возвращаемый предшествующим вызовом либо </span><span>CreateFileMapping</span><span>.<o:p></o:p></span></p> <p><span>Параметр </span><i><span>dwDESIredAccess </span></i><span>идентифицирует вид доступа к данным. Остальные три параметра относятся к резервированию региона адресного пространства и к отображению на него физической памяти. При этом необязательно проецировать на адресное пространство весь файл сразу. Напротив, можно спроецировать лишь малую его часть. Проецируя на адресное пространство процесса представление файла, нужно сделать две вещи. Во-первых, сообщить системе, какой байт файла данных считать в представлении первым. Для этого предназначены параметры <i>dwFileOffsetHigh </i>и <i>dwFileOffsetLow. </i>Поскольку Windows поддерживает файлы длиной до 16 экзабайтов, приходится определять смещение в файле как 64-разрядное число: старшие 32 бита передаются в параметре <i>dwFileOffsetHigh, </i>а младшие 32 бита — в параметре <i>dwFile</i></span><i><span>O</span></i><i><span>ffsetLow.</span></i><span><o:p></o:p></span></p> <p><span>Во-вторых, размер проецируемого блока нужно указать в параметре <i>dwNumberO</i></span><i><span>f</span></i><i><span>BytesToMap.</span></i><span><o:p></o:p></span></p> <p><span>Если функция потерпела неудачу, то возвращается </span><span>NULL</span><span>.<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><b><span>Пример. </span></b><span>Зарезервируем регион адресного пространства под первый байт файла и передадим его как физическую память с доступом по чтению и записи:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>HANDLE hMapFile;<o:p></o:p></span></p> <p><span>LPVOID lpMapFile;<o:p></o:p></span></p> <p><span>lpMapFile = MapViewOfFile(<o:p></o:p></span></p> <p><span> hMapFile, //хэндл проекции файла<o:p></o:p></span></p> <p><span> FILE_MAP_READ|FILE_MAP_WRITE, //файловые данные<o:p></o:p></span></p> <p><span>//можно читать и записывать<o:p></o:p></span></p> <p><span> 0, //смещение в файле равно 0<o:p></o:p></span></p> <p><span> 0,<o:p></o:p></span></p> <p><span> 1); //резервируем один байт<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Когда необходимость в данных файла (спроецированного на регион адресного пространства процесса) отпадет, регион освобождается вызовом:<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p style="text-align: center;"><span>BOOL <b>UnmapViewOfFile</b> (</span><span>L</span><span>P</span><span>C</span><span>VOID <i>lpBaseAddress</i>);<o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>Ее единственный параметр, </span><i><span>l</span></i><i><span>pBaseAddress, </span></i><span>указывает базовый адрес возвращаемого системе региона. Он должен совпадать со значением, полученным после вызова. Для повышения производительности при работе с представлением файла система буферизует страницы данных в файле и не обновляет немедленно дисковый образ файла. При необходимости можно заставить систему записать измененные данные (все или частично) в дисковый образ файла, вызвав функцию <b>FlushViewOfFile:</b><o:p></o:p></span></p> <p><span> <o:p></o:p></span></p> <p><span>BOOL <b>FlushViewOfFile</b></span><span>(</span><span>PVOID <i>pvAddress</i></span><span>,<o:p></o:p></span></p> <p><span> SIZE</span><span>_</span><span>T <i>dwNumberOfBytesToFlush</i></span><span>);<o:p></o:p></span></p> <p><span> </span><span><o:p></o:p></span></p> <p><span>В случае успеха функция возвращает </span><span>TRUE</span><span>, в случае неудачи – </span><span>FALSE</span><span>.<o:p></o:p></span></p> <p><span>Ее первый параметр принимает адрес байта, который содержится в границах представления файла, проецируемого в память. Переданный адрес округляется до значения, кратного размеру страниц. Второй параметр определяет количество байтов, которые надо записать в дисковый образ файла. Если <b>FlushViewOfFile</b><i> </i>вызывается в отсутствие измененных данных, она просто возвращает управление. В случае успеха функция возвращает </span><span>TRUE</span><span>, в случае неудачи – </span><span>FALSE</span><span>.<o:p></o:p></span></p> <p><span>Список литературы:<o:p></o:p></span></p> <p><![if !supportLists]><span><span>1.<span> </span></span></span><![endif]><span>Олифер, В.Г. Сетевые операционные системы / В.Г. Олифер, Н.А. Олифер. – СПб.: Питер, 2002.</span><span><o:p></o:p></span></p> <p><![if !supportLists]><span><span>2.<span> </span></span></span><![endif]><span>Рихтер, Дж. Windows для профессионалов. Создание эффективных Win42-приложений с учетом специфики 64-разрядной версии Windows / Дж. Рихтер // Пер.с англ., 4-е изд. – СПб.: Питер; М.: Издательско-торговый дом «Русская Редакция», 2004.</span><span><o:p></o:p></span></p> <p><o:p> </o:p></p> </div> 
 <A HREF="../theory.htm">Оглавление</A>                
<p>&nbsp;</p>
        </table>
<table width="100%" height=25px border="0" cellpadding="0" cellspacing="3" bordercolor="#316AC5" background="../Оболочка/images/background.jpg">
  <tr >
  <td align=center><var><B><b>(С)  БГУИР</b></var></td>
  </tr>
</table>
</BODY></HTML>